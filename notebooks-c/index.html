<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="C++课堂笔记，包含了网课在内。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://blog.gddfeng.com/notebooks-c/index.html">
<meta property="og:site_name" content="孤独的風">
<meta property="og:description" content="C++课堂笔记，包含了网课在内。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-26T08:40:16.000Z">
<meta property="article:modified_time" content="2021-12-11T08:40:00.000Z">
<meta property="article:author" content="gddFeng">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="课堂笔记">
<meta name="twitter:card" content="summary"><title>C++ | 孤独的風</title><link ref="canonical" href="http://blog.gddfeng.com/notebooks-c/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/课堂笔记/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">课堂笔记</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">编程语言</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/编程语言/c/"><span class="header-nav-submenu-item__text">C++</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">考研学习</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/考研学习/计算机网络/"><span class="header-nav-submenu-item__text">计算机网络</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/考研学习/计算机操作系统/"><span class="header-nav-submenu-item__text">计算机操作系统</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">渗透测试</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/渗透测试/SQL注入/"><span class="header-nav-submenu-item__text">SQL注入</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">C++</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-12-11</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">34.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">234分</span></span></div></header><div class="post-body">
        <h1 id="第1单元-初识C"   >
          <a href="#第1单元-初识C" class="heading-link"><i class="fas fa-link"></i></a><a href="#第1单元-初识C" class="headerlink" title="第1单元 初识C++"></a>第1单元 初识C++</h1>
      
        <h2 id="1-1-C-简介"   >
          <a href="#1-1-C-简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-C-简介" class="headerlink" title="1.1 C++简介"></a>1.1 C++简介</h2>
      
        <h3 id="1-1-1-C-的发展简史"   >
          <a href="#1-1-1-C-的发展简史" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-1-C-的发展简史" class="headerlink" title="1.1.1 C++的发展简史"></a>1.1.1 C++的发展简史</h3>
      
        <h4 id="1-1-1-1-课程介绍"   >
          <a href="#1-1-1-1-课程介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-1-1-课程介绍" class="headerlink" title="1.1.1.1 课程介绍"></a>1.1.1.1 课程介绍</h4>
      
        <h5 id="书籍介绍"   >
          <a href="#书籍介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#书籍介绍" class="headerlink" title="书籍介绍"></a>书籍介绍</h5>
      <ul>
<li>C++ Prime </li>
<li>大话数据结构</li>
</ul>

        <h4 id="1-1-1-2-编程环境"   >
          <a href="#1-1-1-2-编程环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-1-2-编程环境" class="headerlink" title="1.1.1.2 编程环境"></a>1.1.1.2 编程环境</h4>
      <p>推荐使用Visual Studio 2019 </p>
<p>不过我用的是VS Code</p>

        <h4 id="1-1-1-3-C-发展史"   >
          <a href="#1-1-1-3-C-发展史" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-1-3-C-发展史" class="headerlink" title="1.1.1.3 C++发展史"></a>1.1.1.3 C++发展史</h4>
      <p>前期的阶段老师没讲</p>

        <h5 id="重要的C-版本"   >
          <a href="#重要的C-版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#重要的C-版本" class="headerlink" title="重要的C++版本"></a>重要的C++版本</h5>
      <ul>
<li>C++98</li>
<li>C++11</li>
<li>C++20</li>
</ul>
<p>我们学的是C++11版本的</p>
<p>同时编译器使用的是2019版本的，因为编译器往往需要过两年才能适配新版本的语法。</p>

        <h5 id="C-的主要用途"   >
          <a href="#C-的主要用途" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-的主要用途" class="headerlink" title="C++的主要用途"></a>C++的主要用途</h5>
      <ul>
<li>服务器端编程</li>
<li>算法设计</li>
<li>通过Qt进行Linux、国产化操作系统的桌面应用程序开发，自主可控的软件开发。</li>
</ul>

        <h3 id="1-1-2-C-的特点"   >
          <a href="#1-1-2-C-的特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-2-C-的特点" class="headerlink" title="1.1.2 C++的特点"></a>1.1.2 C++的特点</h3>
      
        <h4 id="1-1-2-1支持四种编程范式"   >
          <a href="#1-1-2-1支持四种编程范式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-2-1支持四种编程范式" class="headerlink" title="1.1.2.1支持四种编程范式"></a>1.1.2.1支持四种编程范式</h4>
      <p>Java号称是纯面向对象的语言，他的main封装在class类里面。</p>
<p>四种编程范式：面向过程、面向对象、泛型编程、函数式编程</p>
<ul>
<li>面向过程<ul>
<li>瀑布式开发模型<ul>
<li>其实就是正常的程序流程构设</li>
<li>非常理想化，没有考虑在实际开发过程中可能产生的需求变化和将来的软件升级。</li>
<li>在软件开发过程中唯一不变的是变化！</li>
</ul>
</li>
</ul>
</li>
<li>面向对象，OOP(Object-Oriented Programming)<ul>
<li>三个基本特征：封装、继承、多态</li>
</ul>
</li>
<li>泛型编程 <ul>
<li>与类型无关的编程，是通过模板实现的。以模板为基础，STL实现通用的容器类。</li>
<li>感觉上就是调用库。</li>
</ul>
</li>
<li>函数式编程</li>
</ul>

        <h4 id="1-1-2-2-适合编写大型应用程序"   >
          <a href="#1-1-2-2-适合编写大型应用程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-2-2-适合编写大型应用程序" class="headerlink" title="1.1.2.2 适合编写大型应用程序"></a>1.1.2.2 适合编写大型应用程序</h4>
      <ol>
<li>不适合编写操作系统，操作系统的内核还是由C语言完成的。</li>
<li>C++的一些语法设计，考虑了很多人同时开发，例如命名空间namespace。</li>
<li>面向对象程序设计（OOP），根本上解决了需求发生变化、软件升级的问题</li>
</ol>

        <h4 id="1-1-2-3-可复用、可扩充、可维护和灵活性好"   >
          <a href="#1-1-2-3-可复用、可扩充、可维护和灵活性好" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-2-3-可复用、可扩充、可维护和灵活性好" class="headerlink" title="1.1.2.3 可复用、可扩充、可维护和灵活性好"></a>1.1.2.3 可复用、可扩充、可维护和灵活性好</h4>
      
        <h4 id="1-1-2-4-C-的缺点"   >
          <a href="#1-1-2-4-C-的缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-2-4-C-的缺点" class="headerlink" title="1.1.2.4 C++的缺点"></a>1.1.2.4 C++的缺点</h4>
      <ul>
<li>C++的强大在于提供高级抽象的同时又不放弃对程序的细节控制。</li>
<li>过于频繁的更换，除了增加功能以外，也使得C++变得越来越复杂。苦了人脑，幸福电脑。</li>
</ul>

        <h2 id="1-2-第一个C-程序"   >
          <a href="#1-2-第一个C-程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-第一个C-程序" class="headerlink" title="1.2 第一个C++程序"></a>1.2 第一个C++程序</h2>
      
        <h3 id="1-2-1-Hello-World"   >
          <a href="#1-2-1-Hello-World" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-1-Hello-World" class="headerlink" title="1.2.1 Hello World"></a>1.2.1 Hello World</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1-2-1-1-C-与C的不同"   >
          <a href="#1-2-1-1-C-与C的不同" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-1-1-C-与C的不同" class="headerlink" title="1.2.1.1 C++与C的不同"></a>1.2.1.1 C++与C的不同</h4>
      <ol>
<li>头文件没有后缀名</li>
<li>C++兼容C，可以在C语言头文件名称前加上<strong>c</strong>后去除后缀名进行引用。</li>
<li>基本输出不同</li>
</ol>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello,World!\n&quot;</span>;</span><br><span class="line"><span class="comment">//std::cout是标准命名空间中定义、ostream类型的全局变量，代表显示器。</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>std是标准命名空间（standard）</li>
<li>::是域操作符（相当于的）</li>
<li>cout是控制台输出设备</li>
<li>&lt;&lt;是输出运算符</li>
</ul>

        <h2 id="1-3-C-对C语言的扩充"   >
          <a href="#1-3-C-对C语言的扩充" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-C-对C语言的扩充" class="headerlink" title="1.3 C++对C语言的扩充"></a>1.3 C++对C语言的扩充</h2>
      
        <h3 id="1-3-1-命名空间"   >
          <a href="#1-3-1-命名空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-1-命名空间" class="headerlink" title="1.3.1 命名空间"></a>1.3.1 命名空间</h3>
      <p>为了解决合作开发时命名冲突的问题，C++引用了命名空间。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Li&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInt</span><span class="params">()</span></span>&#123;std::cout &lt;&lt; a &lt;&lt; std::endl;&#125;</span><br><span class="line">    <span class="comment">//endl是标准命名空间定义的换行符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Han&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">200</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInt</span><span class="params">()</span></span>&#123;std::cout &lt;&lt; a &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在不同的namespace中可以重复定义相同的函数或相同的变量。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Han::a = <span class="number">300</span>;</span><br><span class="line">    Li::<span class="built_in">printInt</span>();<span class="comment">//输出100</span></span><br><span class="line">    Han::<span class="built_in">printInt</span>();<span class="comment">//输出300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1-3-1-1-命名空间简写方法"   >
          <a href="#1-3-1-1-命名空间简写方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-1-1-命名空间简写方法" class="headerlink" title="1.3.1.1 命名空间简写方法"></a>1.3.1.1 命名空间简写方法</h4>
      <ol>
<li>使用 <strong>::</strong> 引用命名空间中定义的元素<br><code>std::cout &lt;&lt; &quot;C++&quot; &lt;&lt; std::endl;</code></li>
<li>使用using引用命名空间中的某个元素</li>
</ol>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li>使用using引用命名空间<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h3 id="1-3-2-控制台输入输出"   >
          <a href="#1-3-2-控制台输入输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-2-控制台输入输出" class="headerlink" title="1.3.2  控制台输入输出"></a>1.3.2  控制台输入输出</h3>
      
        <h4 id="C-的I-O解决方案"   >
          <a href="#C-的I-O解决方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-的I-O解决方案" class="headerlink" title="C++的I/O解决方案"></a>C++的I/O解决方案</h4>
      <ul>
<li>使用 <strong>cin</strong> 接收从键盘输入的数据，用 <strong>cout</strong> 向屏幕上输出数据（这2个过程又称为“标准I/O”）。</li>
<li>C++也对从文件中读取数据和向文件中写入数据做了支持（统称为“文件I/O”）。</li>
</ul>

        <h4 id="C-标准库中包含了“流类”"   >
          <a href="#C-标准库中包含了“流类”" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-标准库中包含了“流类”" class="headerlink" title="C++标准库中包含了“流类”"></a>C++标准库中包含了“流类”</h4>
      <ul>
<li>istream：常用语接收从键盘输入的数据；</li>
<li>ostream：常用语将数据输出到屏幕上；</li>
<li>ifstream： 用于读取文件中的数据；</li>
<li>ofstream： 继承自istream和ostream类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出；</li>
<li>fstream：兼ifstream和ofstream类功能于一身，既能读取文件中的数据，又能向文件中写入数据。</li>
<li>cin是istream类的对象，cout是ostream类的对象，在<iostream>头文件中声明。</li>
<li>使用cin和cout需要包含<iostream>头文件，当然还需要使用std命名空间。</li>
</ul>

        <h4 id="输入"   >
          <a href="#输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入" class="headerlink" title="输入"></a>输入</h4>
      <ul>
<li>输入流对象cin和输入运算符&gt;&gt;配合，用于用户输入</li>
<li>在连续输入多个变量时，以空白(空格、回车、制表符)为分隔符</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">//如果是字符型的话，分隔符会被识别成数据。</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="输出"   >
          <a href="#输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出" class="headerlink" title="输出"></a>输出</h4>
      <ul>
<li>输出对象cout和输出运算符&lt;&lt;配合，用于用户输出</li>
<li>可以连续输出多个不同类型的常量或变量</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;Hello,C++&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//注意流的方向，要指向cout</span></span><br></pre></td></tr></table></div></figure>

<ol>
<li><strong>两个运算符都是从左向右结合</strong></li>
<li>cin&gt;&gt;a的返回值时cin,cout&gt;&gt;”Hello,C++”的返回值是cout。所以可以连续执行。</li>
</ol>

        <h4 id="小例子"   >
          <a href="#小例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please Enter Two Integers:&quot;</span></span><br><span class="line">    cin &gt;&gt;a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; a+b &lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>C语言中的<code>scanf</code>是不安全的函数，如果要使用需要<code>#define _CRT_SECURE_NO_WARNINGS</code></p>

        <h3 id="1-3-3-增强类型"   >
          <a href="#1-3-3-增强类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-3-增强类型" class="headerlink" title="1.3.3 增强类型"></a>1.3.3 增强类型</h3>
      <ol>
<li>const常变量</li>
<li>bool布尔类型</li>
<li>enum枚举类型</li>
</ol>

        <h4 id="1-3-3-1-const的基本概念"   >
          <a href="#1-3-3-1-const的基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-3-1-const的基本概念" class="headerlink" title="1.3.3.1 const的基本概念"></a>1.3.3.1 const的基本概念</h4>
      <ul>
<li>定义只读变量的关键字</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//const的量一定要赋值进行初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pa = &amp;a;</span><br><span class="line"> <span class="comment">//const int * 类型的值不能用于初始化int*类型的实体</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>在C语言中const变量不能定义数组长度，但是在C++中可以。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> arr[size];</span><br></pre></td></tr></table></div></figure>


        <h4 id="1-3-3-2-const与指针"   >
          <a href="#1-3-3-2-const与指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-3-2-const与指针" class="headerlink" title="1.3.3.2 const与指针"></a>1.3.3.2 const与指针</h4>
      <ul>
<li>指向<code>常量</code>的指针，称为<strong>常量指针</strong>。<ul>
<li>解释：所指的量是一个常量。</li>
<li>int * const p</li>
<li>当使用是形参时，传入变量地址就可以。</li>
</ul>
</li>
<li><code>不能指向其他变量</code>的指针，称为<strong>指针常量</strong>。<ul>
<li>const int * p;</li>
<li>int const * p;</li>
<li>解释：只能指向某一量，设定后无法更改。</li>
<li>数组就是<strong>指针常量</strong></li>
</ul>
</li>
<li>指向整型常量的指针常量。<ul>
<li>const int * const p;</li>
</ul>
</li>
</ul>

        <h3 id="1-3-3-布尔类型"   >
          <a href="#1-3-3-布尔类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-3-布尔类型" class="headerlink" title="1.3.3 布尔类型"></a>1.3.3 布尔类型</h3>
      <p>在C语言的C99版本中可以引用&lt;stdbool.h&gt;来使用bool类型</p>
<ul>
<li>enum</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEASON</span>&#123;</span>SPRIG,SUMMER,AUTUMN,WINTER&#125;;</span><br><span class="line">SEASON s1 = SUMMER；</span><br></pre></td></tr></table></div></figure>


        <h3 id="1-3-4-参数默认值"   >
          <a href="#1-3-4-参数默认值" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-4-参数默认值" class="headerlink" title="1.3.4 参数默认值"></a>1.3.4 参数默认值</h3>
      <p>直接在形参中初始化</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=<span class="number">1</span>,<span class="keyword">int</span> z=<span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;x+y+z&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>);     <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li>参数默认值可在函数声明中出现一次，如果没有函数声明，只有函数定义，那么可以在函数定义中设定</li>
</ol>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fun.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">1</span>,<span class="keyword">int</span> c=<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">//fun.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li>默认参数赋值的顺序时自右向左</li>
</ol>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这种是错的</span></span></span><br></pre></td></tr></table></div></figure>


        <h3 id="1-3-5-函数重载"   >
          <a href="#1-3-5-函数重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-5-函数重载" class="headerlink" title="1.3.5 函数重载"></a>1.3.5 函数重载</h3>
      <ul>
<li>所谓函数重载，是指在同一个作用域内、函数名相同、参数列表不同的多个函数。</li>
<li>编译器会根据所给的参数自动选择相应的函数。</li>
<li>参数列表不同：<ol>
<li>参数类型不同</li>
<li>参数个数不同</li>
<li>参数类型、个数均不同</li>
</ol>
<ul>
<li><strong>形参变量名不同不构成重载！</strong></li>
</ul>
</li>
<li>当重载函数有默认值时，要防止二义性！<ul>
<li>两个同名函数之间，只差若干个默认值，当未指定默认值时，程序就不知道使用哪个函数了。</li>
</ul>
</li>
</ul>

        <h3 id="1-3-6-引用"   >
          <a href="#1-3-6-引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-6-引用" class="headerlink" title="1.3.6 引用"></a>1.3.6 引用</h3>
      
        <h4 id="1-3-6-1-引用的基本概念"   >
          <a href="#1-3-6-1-引用的基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-6-1-引用的基本概念" class="headerlink" title="1.3.6.1 引用的基本概念"></a>1.3.6.1 引用的基本概念</h4>
      <ul>
<li>引用就是给变量取的一个别名</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ra = a;</span><br><span class="line">ra = <span class="number">200</span>;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>引用的语法<ul>
<li>类型 &amp; 引用名 = 变量名；</li>
</ul>
</li>
<li>&amp;的含义<ol>
<li>int &amp; ra = a;    在定义变量的时候使用&amp;，表示引用</li>
<li>int *p;p=&a;     一元操作，表示取地址</li>
<li>a &amp; b;           二元运算符，表示运算中的按位与</li>
<li>a &amp;&amp; b;            表示逻辑与</li>
</ol>
</li>
<li>使用引用的注意事项<ol>
<li>引用必须初始化</li>
<li>不能引用常量</li>
<li>不能引用数组</li>
<li>引用只能时某个固定变量的引用，不能再引用其他变量。</li>
</ol>
</li>
<li>没必要在一个函数内使用引用，通常在两个函数之间使用引用<ul>
<li>形参是引用<ul>
<li>在C语言中，函数参数的两种形式<ul>
<li>传值</li>
<li>传地址</li>
</ul>
</li>
</ul>
</li>
<li>返回值是引用</li>
</ul>
</li>
</ul>

        <h4 id="1-3-6-2-函数参数的三种形式"   >
          <a href="#1-3-6-2-函数参数的三种形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-6-2-函数参数的三种形式" class="headerlink" title="1.3.6.2 函数参数的三种形式"></a>1.3.6.2 函数参数的三种形式</h4>
      
        <h5 id="1-传值"   >
          <a href="#1-传值" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-传值" class="headerlink" title="1. 传值"></a>1. 传值</h5>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">int</span> temp=x;x=y;y=temp&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>,b=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">Swap1</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>传值，子函数无法改变调用函数中变量的值。</li>
<li>每个函数的一次运行都会有一个自动分配的栈，局部变量位于栈中。形参也是局部变量。</li>
</ul>
<p>函数每一次运行都会有一个独立的栈，用来存放局部变量。这就导致了<code>主函数</code>和<code>自定义函数</code>中分别定义的变量不互通，主函数传入变量的时候仅仅传入了值，而非变量本身。</p>

        <h5 id="2-传地址"   >
          <a href="#2-传地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-传地址" class="headerlink" title="2. 传地址"></a>2. 传地址</h5>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap2</span><span class="params">(<span class="keyword">int</span> *p,inty *q)</span></span>&#123;<span class="keyword">int</span> temp=*p;*p=*q;*q=temp;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>,b=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">Swap2</span>(&amp;a,&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>传地址，子函数可以修改调用函数中变量的值</li>
<li>下面是比较常见的初学者的错误写法</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Swap3</span>(<span class="keyword">int</span> *p,<span class="keyword">int</span> *q)&#123;<span class="keyword">int</span> *temp=p;p=q;q=temp;&#125;</span><br></pre></td></tr></table></div></figure>

<p>这种方式直接传输地址，使得不同函数可以直接读取或写入<code>其他函数栈</code>中<code>相应地址</code>的<code>变量</code>。</p>

        <h5 id="3-传引用"   >
          <a href="#3-传引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-传引用" class="headerlink" title="3. 传引用"></a>3. 传引用</h5>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap4</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">int</span> temp=x;x=y;y=temp&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>,b=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">Swap4</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>传引用，可以达到传指针同样的效果，但是调用更方便。</li>
<li>与传地址不同的地方就是函数定义不是<code>*x</code>了，而是<code>&amp;x</code>，这样传入的可以直接传入变量</li>
<li>个人理解：直接将传入函数<code>命名别名</code>后，在函数中进行使用。</li>
<li>尽管在形参中没有认为进行初始化，但是<code>从形参到实参的过程就是初始化！</code></li>
</ul>

        <h4 id="1-3-6-3-引用——函数的返回值"   >
          <a href="#1-3-6-3-引用——函数的返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-6-3-引用——函数的返回值" class="headerlink" title="1.3.6.3 引用——函数的返回值"></a>1.3.6.3 引用——函数的返回值</h4>
      <p>不会在一个函数内部使用引用，引用仅应用于两个函数之间</p>
<ol>
<li>函数参数是引用类型</li>
<li>函数的返回值是引用</li>
</ol>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">At</span><span class="params">(<span class="keyword">int</span> b[],<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">At</span>(a,<span class="number">1</span>) = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//b[index]等价于a[1]</span></span><br><span class="line">    <span class="comment">//等价于a[1] = 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>也就是说，可以让<code>函数调用作为左值</code>。</li>
<li>可以避免返回值被拷贝</li>
<li>注意：不能返回局部变量的引用<ul>
<li>因为局部变量存在函数的栈中，函数一旦运行结束，栈会被释放清空，那么这个数据就不存在了。</li>
</ul>
</li>
</ul>

        <h4 id="1-3-6-4-引用——常引用"   >
          <a href="#1-3-6-4-引用——常引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-6-4-引用——常引用" class="headerlink" title="1.3.6.4 引用——常引用"></a>1.3.6.4 引用——常引用</h4>
      <ul>
<li>int &amp; a=b;a就是b。</li>
<li>针对引用类型的函数参数，形参就是实参。这带来两种用途：<ol>
<li>子函数可以通过引用类型的参数来修改调用函数中的变量，并且不用使用指针（都不喜欢指针，能不用尽量不用）。</li>
<li>避免了形参到实参的初始化过程，从而提高了效率。</li>
</ol>
</li>
<li>如果只想2，而不想1，可以使用<code>常引用</code><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> XYZ &amp; r)</span></span>&#123;……&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>在面向对象编程中，类类型属于自定义类型，比简单类型占用更多的内存空间。如果函数的参数类型是类类型，为了提高效率，我们往往使用常引用。</li>
</ul>

        <h3 id="1-3-7-内存管理——堆、栈"   >
          <a href="#1-3-7-内存管理——堆、栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-7-内存管理——堆、栈" class="headerlink" title="1.3.7 内存管理——堆、栈"></a>1.3.7 内存管理——堆、栈</h3>
      <ul>
<li>不是数据结构中的堆和栈</li>
</ul>
<ol>
<li>C语言的内存区域<ul>
<li>堆<ul>
<li>堆是用于存放进程运行中被动态分配的<code>内存段</code>。当进程调用<code>malloc/free</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被剔除（堆被缩减）。</li>
</ul>
</li>
<li>栈<ul>
<li>栈又称堆栈，存放<code>程序的局部变量</code>(但不包括static声明的变量)和<code>函数被调用时的参数和返回值</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>从低位地址到高位地址逐个是：</p>
<ol>
<li>代码区：函数代码块的二进制代码。</li>
<li>数据区</li>
<li>文字常量区：常量字符串存放于此</li>
<li>未初始化静态变量区：没有初始化的全局变量和静态变量</li>
<li>已初始化的静态变量区：初始化的全局变量和静态变量</li>
<li>堆区：动态分配的数据</li>
<li>栈区：局部变量存放于此</li>
<li>命令行参数区：命令行参数和局部变量</li>
</ol>
</li>
</ul>
<ol start="2">
<li> C++内存区域</li>
</ol>
<ul>
<li>C++中内存分成5个区：<ol>
<li>栈：内存由编译器在需要时<code>自动</code>分配和释放。通常用来存储局部变量和函数参数。（为运行函数而分配的局部变量、函数参数、返回地址等存放在<code>栈区</code>）</li>
<li>堆：内存使用<code>new</code>进行分配，使用<code>delete</code>释放。如果未能对内存进行正确的释放，会造成<code>内存泄漏</code>。</li>
<li>自由存储区：使用<code>malloc</code>进行分配，使用<code>free</code>进行回收。</li>
<li>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。(全局变量、静态数据、常量存放在<code>全局数据区</code>)</li>
<li>常量存储区：存储常量，不允许被修改。</li>
</ol>
</li>
<li>栈和堆的对比<ul>
<li>栈<ol>
<li>内个函数的第一次运行都会有一个独立的栈</li>
<li>自动分配、自动释放</li>
<li>通过变量直接使用</li>
</ol>
</li>
<li>堆<ol>
<li>全局只有一个堆</li>
<li>手动分配、手动释放</li>
<li>通过指针间接使用</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">&#125;<span class="comment">//函数运行结束，栈被自动释放</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行了两次，有两个栈，栈中的a都为1</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p =<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="comment">//这里*p是局部变量，存在栈中。同时堆中开辟了一块int类型大小的空间。</span></span><br><span class="line">    *p = <span class="number">100</span>;<span class="comment">//p指向的内存单元为100，也就是堆中相应内存单元为100.</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="comment">//将堆中数据回收，但*p还在，仍然指向堆中的那个地址，称为“野指针”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="1-3-8-new-delete"   >
          <a href="#1-3-8-new-delete" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-8-new-delete" class="headerlink" title="1.3.8 new/delete"></a>1.3.8 new/delete</h3>
      <ul>
<li><p>在C语言中，动态分配内存用<code>malloc()</code>函数，释放内存用<code>free()</code>函数。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));<span class="comment">//分配一个int型的内存空间</span></span><br><span class="line"><span class="comment">//将int大小的空间分配给p并将无类型的p进行强制类型转换</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放内存</span></span><br><span class="line"><span class="comment">//分配在堆中</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>C++新增了两个关键字，使用起来更简介</p>
<ul>
<li><code>new</code>用来动态分配内存<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//分配一个int型的内存空间</span></span><br></pre></td></tr></table></div></figure></li>
<li>delete用来释放内存<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<ol>
<li>根据后面的数据类型来<code>自动推断所需空间大小</code></li>
<li>返回具体类型的指针，不需要进行类型转换</li>
</ol>
<ul>
<li><p>分配一组连续的数据（动态数组）</p>
<ul>
<li>C语言版本<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></div></figure></li>
<li>版本<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>new/delete的优点</p>
<ul>
<li><code>new</code>可以自动推断所需空间大小，而<code>malloc</code>需要通过<code>sizeof</code>进行计算。</li>
<li><code>new</code>自动返回所需类型指针，而<code>malloc</code>返回的是<code>void *</code>，还需要类型转换</li>
<li><code>new</code>在分配空间的同时还可以初始化，而<code>malloc</code>只能分配空间<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//将p初始化为100</span></span><br></pre></td></tr></table></div></figure></li>
<li>我们可以笼统的说<code>new</code>和<code>malloc</code>都是在<code>堆</code>中分配内存，但仍然有差别，所以<code>new/delete</code>和<code>malloc/free</code>不能混用。</li>
<li><code>new/delete</code>支持C++的新特性，包括：重载、调用构造/析构函数。</li>
</ul>
</li>
</ul>

        <h3 id="1-3-8-静态数组、动态数组"   >
          <a href="#1-3-8-静态数组、动态数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-8-静态数组、动态数组" class="headerlink" title="1.3.8 静态数组、动态数组"></a>1.3.8 静态数组、动态数组</h3>
      <ul>
<li>静态数组<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;<span class="comment">//SIZE是常量</span></span><br><span class="line"><span class="keyword">int</span> a[SIZE]; <span class="comment">// 定义数组时，数组的大小必须是常量</span></span><br></pre></td></tr></table></div></figure></li>
<li>动态数组<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">100</span>;<span class="comment">//size是变量</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[size];<span class="comment">//可以在内存中分配任意大小的内存</span></span><br></pre></td></tr></table></div></figure></li>
<li>指针p和数组名a都指向内存中一段内存的首地址，且用法都是一样的<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(a+<span class="number">10</span>)=<span class="number">123</span>;</span><br><span class="line">p[<span class="number">10</span>]=<span class="number">123</span>;</span><br><span class="line"><span class="comment">//相互等价</span></span><br></pre></td></tr></table></div></figure></li>
<li>差别在于，a是<code>指针常量</code>，p是<code>指针变量</code>,<code>p++</code>可以，<code>a++</code>不行。</li>
</ul>

        <h3 id="1-3-9-各种指针和指针数组"   >
          <a href="#1-3-9-各种指针和指针数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-9-各种指针和指针数组" class="headerlink" title="1.3.9 各种指针和指针数组"></a>1.3.9 各种指针和指针数组</h3>
      <p>因为指针的存在，所以C/C++的程序可以直接访问内存，从而提高程序的运行速度。</p>
<p>在大型程序中，核心数据不可能存放在栈中，一定是存放在堆中，所以只有通过指针进行访问。换言之，<strong>核心数据一定是<code>new</code>出来的</strong>！</p>
<ul>
<li>在开发的过程中，能不用指针运算，尽量不用指针运算。<ul>
<li>使用下标运算，而不是用<code>*</code>运算，例如：<code>*(P+1)等价于p[i]</code>，不过<code>*p</code>比<code>p[0]</code>好看一些。</li>
<li>能够使用引用，尽量使用引用，例如：通过指针和引用都可以实现交换函数，<code>swap(&amp;a,&amp;b)</code>肯定不如<code>swap(a,b)</code>。</li>
</ul>
</li>
</ul>
<p>struct和class中指针类型的成员变量，习惯上不会使用引用，而是指针</p>

        <h4 id="各种指针"   >
          <a href="#各种指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#各种指针" class="headerlink" title="各种指针"></a>各种指针</h4>
      <ol>
<li>指针和const组合：<ul>
<li>常量指针：指向常量的指针</li>
<li>指针常量：<code>int a[100]</code>;</li>
</ul>
</li>
<li>指针和数组结合：<ul>
<li>指向数组的指针：<code>int *p = a</code></li>
<li>指针数组：数组的每一个元素都是指针。<ul>
<li><code>int *a[100]</code></li>
</ul>
</li>
</ul>
</li>
<li>指针的指针：<ul>
<li>指针和自己结合，<code>int **p</code></li>
<li>不仅仅数组名是指针常量，函数名也是指针常量<ul>
<li>通过函数指针，C语言也能做到面向对象</li>
<li>函数指针-&gt;仿函数-&gt;Lambda表达式</li>
</ul>
</li>
</ul>
</li>
</ol>

        <h2 id="1-4-C-中的两个新语法"   >
          <a href="#1-4-C-中的两个新语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-C-中的两个新语法" class="headerlink" title="1.4 C++中的两个新语法"></a>1.4 C++中的两个新语法</h2>
      
        <h3 id="1-4-1-nullptr——野指针"   >
          <a href="#1-4-1-nullptr——野指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-1-nullptr——野指针" class="headerlink" title="1.4.1 nullptr——野指针"></a>1.4.1 nullptr——野指针</h3>
      <p>野指针主要是因为这些疏忽而出现的删除或申请访问受限内存区域的指针。</p>
<ol>
<li>指针变量未初始化<ul>
<li>任何指针变量刚被创建时不会自动称为空指针，它的缺省值是随机的，它会乱指一气。这个时候，通过指针访问内存就会出错。所以，指针变量在创建的同时应该被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li>
</ul>
</li>
<li>指针释放后未置空<ul>
<li>有时指针在free或delete后未赋值NULL，便会是人认为是合法的。他们只是吧指针所指的内存给释放掉，并没有吧指针本身干掉，此时指针指向的就是垃圾内存。释放后的指针应立即将指针归置为NULL，防止产生“野指针”。</li>
</ul>
</li>
<li>指针操作超越变量作用域<ul>
<li>在子函数中定义的局部变量指针，当函数运行结束后会被释放，此时再通过指针访问内存，就会报错。</li>
</ul>
</li>
</ol>
<p>不能将<code>nullptr</code>转换为int类型。</p>

        <h3 id="1-4-2-基于范围的for循环"   >
          <a href="#1-4-2-基于范围的for循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-2-基于范围的for循环" class="headerlink" title="1.4.2 基于范围的for循环"></a>1.4.2 基于范围的for循环</h3>
      <p>类似于Python的for语法</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e:v)</span><br><span class="line">    cout&lt;&lt;e&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    cout&lt;&lt;v[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></div></figure>


        <h1 id="第2单元-类与对象"   >
          <a href="#第2单元-类与对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#第2单元-类与对象" class="headerlink" title="第2单元 类与对象"></a>第2单元 类与对象</h1>
      
        <h2 id="2-1-面向对象程序设计思想"   >
          <a href="#2-1-面向对象程序设计思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-面向对象程序设计思想" class="headerlink" title="2.1 面向对象程序设计思想"></a>2.1 面向对象程序设计思想</h2>
      
        <h3 id="2-1-1-面向对象的编程思想"   >
          <a href="#2-1-1-面向对象的编程思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-1-面向对象的编程思想" class="headerlink" title="2.1.1 面向对象的编程思想"></a>2.1.1 面向对象的编程思想</h3>
      <p>对于<strong>面向对象</strong>程序设计而言，最重要的一个特征就是<strong>数据封装</strong>。</p>
<p>所谓<strong>数据封装</strong>，就是通过类来实现信息的抽象和隐藏。学习了类的相关知识，才能真正走进面向程序设计的世界。</p>

        <h4 id="面向过程程序设计"   >
          <a href="#面向过程程序设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向过程程序设计" class="headerlink" title="面向过程程序设计"></a>面向过程程序设计</h4>
      <p><strong>面向过程程序设计</strong>对于较为简单的需求通常能够很好地满足。如果<strong>问题比较复杂</strong>，在项目开始之初就完成模块的<strong>合理划分</strong>往往比较困难。当<strong>数据结构</strong>改变时，所有相关的<strong>处理过程</strong>都要进行相应的修改，程序的<strong>可用性极差</strong>。</p>
<p>在程序中使用对象映射现实中的事物，利用对象之间的关系描述事物之间的联系，这种思想就是面向对象。</p>
<p>Object-Oriented，简称OO。</p>
<p>把构成问题的事物按照一定的规则划分为多个独立的对象，然后通过调用对象的方法解决问题。</p>
<p>当应用程序功能发生变更时，只需要修改个别对象就可以了。</p>

        <h4 id="面向对象程序设计思想"   >
          <a href="#面向对象程序设计思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象程序设计思想" class="headerlink" title="面向对象程序设计思想"></a>面向对象程序设计思想</h4>
      <ol>
<li>分析(OOAnalyse)</li>
<li>设计(OODesign)</li>
<li>开发(OOProgramming)</li>
<li>C++是一个面向对象的编程语言(OOPLanguage)</li>
</ol>

        <h4 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h4>
      <p><strong>面向对象程序设计</strong>描述的是客观世界中的事物，以<strong>对象</strong>代表一个<strong>具体的事物</strong>，把<strong>数据和数据的操作方法</strong>放在一起而形成的一个<strong>相互依存</strong>又不可分割的整体。</p>
<p>由此可见，<strong>面向对象程序设计</strong>所强调的基本原则就是<strong>直接面对客观存在的事实</strong>，将人们在日常生活中习惯的<strong>思维方式和思维表达式</strong>应用<strong>软件开发</strong>中，使<strong>软件开发</strong>从过分专业化的<strong>方法、规则</strong>中回到客观世界，回到人们通常的<strong>思维方式</strong>。<strong>面向对象</strong>的思想更适合用于<strong>大型系统项目</strong>的开发。</p>

        <h3 id="2-1-2-面向对象的三大特征"   >
          <a href="#2-1-2-面向对象的三大特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-2-面向对象的三大特征" class="headerlink" title="2.1.2 面向对象的三大特征"></a>2.1.2 面向对象的三大特征</h3>
      
        <h4 id="面向对象的三大特征"   >
          <a href="#面向对象的三大特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4>
      <p>三大特征具有承上启下的关系，而且适用于所有面向对象的编程语言。</p>
<ul>
<li>封装<ul>
<li>封装就是隐藏。它将数据(属性)和数据处理过程(行为)封装成一个独立性很强的模块(类)。对外提供接口，不需要让外界知道具体的实现细节。</li>
<li>不封装会有哪些问题？<ul>
<li>容易因为传参错误出现逻辑错误。</li>
<li>面向对象的程序设计过程中，数据和处理数据的函数封装在一个类中，不存在跨模块处理数据的问题。</li>
</ul>
</li>
</ul>
</li>
<li>继承<ul>
<li>继承描述的是父类和子类的关系。通过继承，子类可以扩展父类的功能，从而提高了代码的<strong>可重用性</strong>，降低了代码维护的难度。</li>
<li>共同的功能写在父类中</li>
<li>不同的功能写在子类中</li>
</ul>
</li>
<li>多态<ul>
<li>是指不同事物对统一信息产生的不同行为。</li>
</ul>
</li>
</ul>

        <h2 id="2-2-初始类和对象"   >
          <a href="#2-2-初始类和对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-初始类和对象" class="headerlink" title="2.2 初始类和对象"></a>2.2 初始类和对象</h2>
      
        <h3 id="2-2-1-类的定义"   >
          <a href="#2-2-1-类的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-1-类的定义" class="headerlink" title="2.2.1 类的定义"></a>2.2.1 类的定义</h3>
      <p>C++中的类(class)可以看做C语言中的结构体(struct)的升级版。</p>
<p>结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的成员，只是他们的取值不一样。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;今年&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;岁，&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;考了&quot;</span> &lt;&lt; score &lt;&lt; <span class="string">&quot;分&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    s1.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="comment">//这里有问题，会在之后的章节里探讨</span></span><br><span class="line">    sl.age = <span class="number">15</span>;</span><br><span class="line">    sl.score = <span class="number">95</span>;</span><br><span class="line">    sl.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li>关键字从<code>struct</code>变成了<code>class</code></li>
<li>访问权限<code>public</code>表示共有，是为了可以从外部访问。</li>
<li><code>Display</code>从全局函数变成了成员函数，也就是对象s1的成员函数，所以函数参数、函数中通过形参引用<code>name</code>等成员，都省略了</li>
<li>Display(s1)写成了s1.Display();</li>
</ol>

        <h4 id="类的语法格式"   >
          <a href="#类的语法格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的语法格式" class="headerlink" title="类的语法格式"></a>类的语法格式</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    成员访问限定符:</span><br><span class="line">        数据成员;</span><br><span class="line">    成员访问限定符:</span><br><span class="line">        成员函数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>标识符的命名规范:</p>
<ol>
<li>只能包含字母、数字、下划线</li>
<li>只能以字母、下划线开头</li>
<li>不能是关键字</li>
</ol>
<p>限定访问规则：<br><code>puiblic &gt; protected &gt; private</code></p>
<p>类是事物的抽象描述，若想定义类就需要抽象出事物的属性及方法。</p>

        <h3 id="2-2-2-类外定义成员函数"   >
          <a href="#2-2-2-类外定义成员函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-2-类外定义成员函数" class="headerlink" title="2.2.2 类外定义成员函数"></a>2.2.2 类外定义成员函数</h3>
      <p>成员函数的函数体既可以写在类中，也可以类外实现。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Student.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::Stundy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;学习C++&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Stundent.cpp -&gt; Stundent.lib,然后和Stundent.h一起发布供第三方调用</p>

        <h1 id="第2次上课"   >
          <a href="#第2次上课" class="heading-link"><i class="fas fa-link"></i></a><a href="#第2次上课" class="headerlink" title="第2次上课"></a>第2次上课</h1>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//在Visual Studio中，*要跟int后面</span></span><br></pre></td></tr></table></div></figure>

<p>一定要提防野指针，编译器无法识别！人工纠错非常的困难！</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//在堆中分配内存，新建栈中指针p并指向堆</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//回收堆中内存，但p的指向还在</span></span><br><span class="line">*p = <span class="number">100</span></span><br><span class="line"><span class="comment">//编译器不会报错，运行的时候会随机报错，因为p指向的空间已经无法使用，无法写入数据！</span></span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//重新申请内存并使p指向这个内存。</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="网课"   >
          <a href="#网课" class="heading-link"><i class="fas fa-link"></i></a><a href="#网课" class="headerlink" title="网课"></a>网课</h1>
      
        <h3 id="2-2-3-对象的创建和使用"   >
          <a href="#2-2-3-对象的创建和使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-3-对象的创建和使用" class="headerlink" title="2.2.3 对象的创建和使用"></a>2.2.3 对象的创建和使用</h3>
      <ul>
<li>对象的定义语法：</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 [= 初始值];</span><br><span class="line">类名 对象名 [(初始值列表)];</span><br></pre></td></tr></table></div></figure>

<ul>
<li>上述定义的对象和变量一样，仍然在栈中(自动分配和释放)</li>
<li>访问对象的公有成员(含成员变量、成员函数)，和结构体变量</li>
<li>访问成员的方法一致：<ul>
<li>对象名.成员变量</li>
<li>对象名.成员函数(实例列表)</li>
</ul>
</li>
<li>也可以在堆中创建对象：<ul>
<li><code>Student* ps = new Student; delete ps;</code></li>
</ul>
</li>
<li>指针是栈里的局部变量，指向堆(手动分配和释放)里面的对象</li>
<li>访问对象的公有成员(含成员变量、成员函数)，和结构体指针访问成员的方法一致：<ul>
<li>指针-&gt;成员变量</li>
<li>指针-&gt;成员函数(实例参数)</li>
</ul>
</li>
</ul>

        <h4 id="字符串类string的使用"   >
          <a href="#字符串类string的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串类string的使用" class="headerlink" title="字符串类string的使用"></a>字符串类string的使用</h4>
      <ul>
<li><p>C语言不存在字符串类型，都是用字符数组(字符指针)处理字符串</p>
</li>
<li><p>C++支持字符数组，另外还提供了字符串类：string。使用前必须<code>#include &lt;string&gt;</code></p>
</li>
<li><p>使用string定义字符串，无须担心长度、空间等问题，且string重载了大量运算符，实现了大量成员函数，足以满足字符串的日常处理操作。</p>
</li>
<li><p>用法</p>
<ul>
<li>访问字符串中的字符与数组相同，可以连等。</li>
<li>字符串间可以用加号链接<ul>
<li><code>cout&lt;&lt;S1+S2&lt;&lt;endl;</code></li>
<li><code>cout&lt;&lt;S1+=S2&lt;&lt;endl;</code></li>
</ul>
</li>
<li>字符串的比较<ul>
<li><code>cout&lt;&lt;(S1&lt;S2)&lt;&lt;endl;</code></li>
</ul>
</li>
<li>计算字符串的长度<ul>
<li><code>cout&lt;&lt;S1.length()&lt;&lt;endl</code></li>
<li>一个汉字两个长度</li>
</ul>
</li>
<li>字符串交换<ul>
<li><code>S1.swap(S2)</code></li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="2-3-封装"   >
          <a href="#2-3-封装" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-封装" class="headerlink" title="2.3 封装"></a>2.3 封装</h2>
      <ul>
<li><p>C++的封装是通过类类型(简称类)实现的，通过类把具体事物抽象成一个由属性(成员变量)和行为(成员函数)组成的独立单位(即类)。</p>
</li>
<li><p>在类的封装设计中，通过访问权限控制类成员访问，</p>
<ul>
<li>需要隐藏的、内部实现的细节设为私有<code>private</code>，仅供内部访问；</li>
<li>允许子类访问的设为保护<code>protected</code></li>
<li>需要对外提供访问接口的设为共有<code>public</code></li>
</ul>
</li>
<li><p>成员函数的简单分类</p>
<ul>
<li>构造函数和析构函数<ul>
<li>构造函数用于对象的创建和初始化</li>
<li>析构函数用于对象的释放</li>
</ul>
</li>
<li>针对成员变量的Set/Get、Add/Del函数<ul>
<li>大多数变量往往设为私有，通过共有的Set/Get函数可以访问私有成员</li>
<li>针对数组类型的成员变量，往往有Add/Del函数。</li>
</ul>
</li>
<li>其他功能性函数<ul>
<li>与应用程序具体的功能、业务规则有关</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通常，成员变量是私有的，对每个成员变量会对应有一对共有的Set/Get函数</p>

        <h2 id="2-4-this指针"   >
          <a href="#2-4-this指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4-this指针" class="headerlink" title="2.4 this指针"></a>2.4 this指针</h2>
      <ul>
<li>类中每个对象的<strong>数据成员</strong>都占用独立空间，但<strong>成员函数</strong>是共享的，可是各个<strong>对象调用相同的函数</strong>时，显示的是对象<strong>各自的信息</strong>。</li>
<li><code>this</code>是C++中的一个关键字，也是一个<strong>常量指针</strong>，它指向当前对象，通过它可以访问当前对象的所有成员。</li>
<li><code>this</code>实际上是成员函数的一个<strong>隐式</strong>的形参，在调用成员函数时将对象的地址作为实参传递给<code>this</code>。所谓“隐式”，是说它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</li>
<li>三个作用：<ul>
<li>如果成员函数的形参与类的成员变量重名，可以用<code>this</code>指针解决。</li>
<li>如果成员函数需要返回当前对象，应该写成<code>return *this;</code></li>
<li>可以在成员函数中，以<code>this</code>指针为实参，调用其他函数。</li>
</ul>
</li>
<li>三点注意事项：<ul>
<li><code>this</code>只能在成员函数内部使用，用在其他地方没有意义，也是非法的。</li>
<li><code>this</code>是指针常量，它的值是不能被修改的，一切企图修改该指针的操作，如复制、递增、递减等都是不允许的。</li>
<li>只有当对象被创建后<code>this</code>才有意义，因此不能在<code>static</code>成员函数中使用</li>
</ul>
</li>
</ul>

        <h2 id="2-5-构造函数"   >
          <a href="#2-5-构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-构造函数" class="headerlink" title="2.5 构造函数"></a>2.5 构造函数</h2>
      
        <h3 id="2-5-1-自定义构造函数"   >
          <a href="#2-5-1-自定义构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-1-自定义构造函数" class="headerlink" title="2.5.1 自定义构造函数"></a>2.5.1 自定义构造函数</h3>
      <p>在C++中，如何<strong>自动进行对象初始化</strong>，并在对象撤销时，<strong>自动执行清理任务</strong></p>
<ul>
<li>构造函数是类的特殊成员函数，用于初始化对象。</li>
<li>构造函数在创建对象时会<strong>自动/隐式</strong>调用。</li>
<li>C++中的每个类至少要有一个构造函数</li>
<li>如果类中没有定义构造函数，系统会提供一个<strong>默认构造函数</strong>。</li>
<li>默认构造函数没有参数，也没有函数体，不具有实际的初始化意义。</li>
<li>构造函数有严格的接口形式，有四个特点：<ul>
<li>与类同名</li>
<li>不能设置返回值类型，void也不写，不能使用return语句返回</li>
<li>可以由参数，可以重载；</li>
<li>一般设为<code>public</code></li>
</ul>
</li>
</ul>

        <h4 id="自定义有参构造函数"   >
          <a href="#自定义有参构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义有参构造函数" class="headerlink" title="自定义有参构造函数"></a>自定义有参构造函数</h4>
      <ul>
<li>参数可以由默认值</li>
<li>参数默认值写在声明处</li>
<li>建议尽量使用初始化表。某些情况下，<strong>必须使用</strong>初始化表进行初始化！</li>
<li>常变量、引用必须初始化，所以常成员变量、引用类型的成员变量，只能通过初始化进行初始化！成员对象也需要通过初始化表初始化。</li>
</ul>

        <h3 id="2-5-2-重载构造函数"   >
          <a href="#2-5-2-重载构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-2-重载构造函数" class="headerlink" title="2.5.2 重载构造函数"></a>2.5.2 重载构造函数</h3>
      <ul>
<li>函数重载：<ul>
<li>同一作用域内</li>
<li>函数名相同</li>
<li>但参数列表不同</li>
</ul>
</li>
<li>三点注意：<ul>
<li>不以返回值不同来作为重载的条件；</li>
<li>形参变量名不同不意味着参数列表不同；</li>
<li>有参数默认值时，要防止二义性</li>
</ul>
</li>
</ul>

        <h3 id="2-5-3-含有成员对象的类的构造函数"   >
          <a href="#2-5-3-含有成员对象的类的构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-3-含有成员对象的类的构造函数" class="headerlink" title="2.5.3 含有成员对象的类的构造函数"></a>2.5.3 含有成员对象的类的构造函数</h3>
      <ul>
<li>什么是成员对象？<ul>
<li>C++允许将一个对象作为另一个类的成员变量，即类中的成员变量可以是其他类的对象，这样的成员变量称为类的子对象或成员对象。</li>
<li>创建含有成员对象的对象时，先执行成员对象的构造函数，再执行类的构造函数。</li>
</ul>
</li>
</ul>
<p>委托</p>

        <h3 id="2-5-4-三角形项目的分析与设计"   >
          <a href="#2-5-4-三角形项目的分析与设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-4-三角形项目的分析与设计" class="headerlink" title="2.5.4 三角形项目的分析与设计"></a>2.5.4 三角形项目的分析与设计</h3>
      <ol>
<li>分析<ul>
<li>需求分析，开发人员经过深入细致的调研和分析，准确理解用户和项目的功能、性能、可靠性等具体要求，将用户非形式的需求表述转化为完整的希求定义，从而确定系统必须做什么的过程。</li>
<li>在学习过程中，老师就是用户，main函数中的测试代码，以及预期的运行结果就是我们的需求。</li>
</ul>
</li>
<li>设计<ul>
<li>要把软件“做什么”转换为“怎么做”。即确定程序是由哪些模块组成的，以及模块之间的关系。</li>
<li>在学习过层中，一个或若干个类就是一个模块。对应UML中的类图，也就是类的.h头文件。</li>
</ul>
</li>
<li>实现<ul>
<li>也就是编码的过程。也就是.cpp文件中每个成员函数具体是如何实现的。</li>
</ul>
</li>
</ol>

        <h4 id="分析"   >
          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h4>
      <ol>
<li>能够根据三个顶点的坐标，或者三条边的长度，构造三角形对象</li>
<li>能够按照三个点的坐标显示三角形，其中每个顶点的x、y坐标能用方括号括起来，三个点用花括号括起来</li>
<li>能够计算三角形的面积，如果三条边长不合理，则面积为零。</li>
</ol>

        <h4 id="设计"   >
          <a href="#设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计" class="headerlink" title="设计"></a>设计</h4>
      <ul>
<li>三类成员函数<ul>
<li>构造函数/析构函数</li>
<li>Set/Get函数</li>
<li>功能函数</li>
</ul>
</li>
<li>从调用者的角度来讲，应该把公有成员写在<strong>前面</strong>。但是在编码过程中，<strong>首先</strong>写成员变量。这二者不矛盾！</li>
</ul>
<p>点类的设计：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Distance</span><span class="params">(<span class="keyword">const</span> Point&amp; other)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetX</span><span class="params">(<span class="keyword">float</span> xx)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetY</span><span class="params">(<span class="keyword">float</span> yy)</span></span>;</span><br><span class="line">  <span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>三角形类的设计：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="keyword">const</span> Point&amp; ppl,<span class="keyword">const</span> Point&amp; pp2, <span class="keyword">const</span> Point&amp; pp3);</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> c);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Point p1;</span><br><span class="line">    Point p2;</span><br><span class="line">    Point p3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-5-5-三角形项目的实现"   >
          <a href="#2-5-5-三角形项目的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-5-三角形项目的实现" class="headerlink" title="2.5.5 三角形项目的实现"></a>2.5.5 三角形项目的实现</h3>
      <p>没听懂这里为什么float不用常引用而正常的要用</p>

        <h3 id="2-5-6-三角形项目的调试"   >
          <a href="#2-5-6-三角形项目的调试" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-6-三角形项目的调试" class="headerlink" title="2.5.6 三角形项目的调试"></a>2.5.6 三角形项目的调试</h3>
      <p>形参是int类型，实参是float类型，变量赋值转换的时候0.9会被转成0！</p>

        <h2 id="2-6-析构函数"   >
          <a href="#2-6-析构函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-析构函数" class="headerlink" title="2.6 析构函数"></a>2.6 析构函数</h2>
      <ul>
<li>构造函数<ul>
<li>分配内存</li>
<li>初始化工作</li>
</ul>
</li>
<li>析构函数<ul>
<li>回收内存</li>
<li>清理工作</li>
</ul>
</li>
</ul>
<p>析构函数的语法：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ABC.h 类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABC</span>&#123;</span></span><br><span class="line">  <span class="built_in">ABC</span>();<span class="comment">//构造函数的声明</span></span><br><span class="line">  ~<span class="built_in">ABC</span>();<span class="comment">//析构函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ABC.cpp 成员函数的类外实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ABC.h&quot;</span></span></span><br><span class="line">ABC::<span class="built_in">ABC</span>()&#123;……;&#125;<span class="comment">//构造函数的类外实现</span></span><br><span class="line">ABC::~<span class="built_in">ABC</span>()&#123;……;&#125;<span class="comment">//析构函数的类外实现</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>析构函数时类的特殊成员函数，用于释放对象</p>
</li>
<li><p>析构函数在释放对象时会<strong>自动/隐式</strong>调用</p>
</li>
<li><p>C++中的每个类有且只有一个析构函数</p>
</li>
<li><p>如果类中没有定义析构函数，系统会提供一个<strong>默认析构函数</strong></p>
</li>
<li><p>默认析构函数没有参数，也没有函数体，不具有实际的意义</p>
</li>
<li><p>与类同名，前面加<code>~</code></p>
</li>
<li><p>不能设置返回值类型，不写<code>void</code>，不能使用<code>return</code>语句返回</p>
</li>
<li><p>没有参数，不能重载</p>
</li>
<li><p>父类的析构函数通常是虚拟析构函数</p>
</li>
<li><p>释放对象的三种时机：</p>
<ol>
<li>在函数中定义对象；当函数调用结束-&gt;释放栈-&gt;释放对象</li>
<li>使用<code>static</code>修饰的静态对象，程序运行结束-&gt;释放静态内存空间-&gt;释放静态对象</li>
<li>使用<code>new</code>运算符创建的对象，调用<code>delete</code>释放对象</li>
</ol>
</li>
<li><p>栈中对象的析构函数的调用顺序，与析构函数的调用顺序相反</p>
<ul>
<li>因为栈是先进后出的顺序，从最后一个开始释放</li>
</ul>
</li>
</ul>

        <h3 id="2-6-1-指针类型的成员变量"   >
          <a href="#2-6-1-指针类型的成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-1-指针类型的成员变量" class="headerlink" title="2.6.1 指针类型的成员变量"></a>2.6.1 指针类型的成员变量</h3>
      <ul>
<li>如果一个类中有指针类型的成员变量，就需要在构造函数中通过<code>new</code>分配了内存，也就需要使用手动释放该段内存，即在析构函数中通过<code>delete</code>释放内存。</li>
<li>从另一个角度讲：如果没有指针类型的成员变量，程序员也不需要实现析构函数，默认析构函数就可以</li>
</ul>
<p>类函数传入指针字符串变量的时候，类使用的是堆内的字符串，是公共的，类内没有自己的字符串，如果通过外部修改了这个字符串，那么类内的字符串也会被修改！因此强烈建议在类内开辟单独的内存，然后把字符串复制进去！</p>

        <h3 id="2-6-2-正确处理指针类型的成员变量"   >
          <a href="#2-6-2-正确处理指针类型的成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-2-正确处理指针类型的成员变量" class="headerlink" title="2.6.2 正确处理指针类型的成员变量"></a>2.6.2 正确处理指针类型的成员变量</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">//忽略安全问题，继续使用strcpy等字符串函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">int</span> a):<span class="built_in">age</span>(a)&#123; <span class="comment">//const char *对应字符串常量</span></span><br><span class="line">      name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s)+<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">strcpy</span>(name,s);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;<span class="keyword">delete</span>[] name;&#125; <span class="comment">//new[]对应deletep[]</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">age</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">  age = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>,<span class="number">20</span>)</span></span>; <span class="comment">//调用构造函数-&gt;new-&gt;拷贝Alice</span></span><br><span class="line">  Student* s2 = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;Bob&quot;</span>,<span class="number">30</span>);</span><br><span class="line">  <span class="keyword">delete</span> s2; <span class="comment">//调用析构函数-&gt;释放Bob</span></span><br><span class="line">&#125; <span class="comment">//调用析构函数-&gt;释放Alice</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>如何处理<code>void Student::SetName(const char* s)</code>？<ol>
<li>不能让<code>name=s</code>，只能使用<code>strcpy</code>，以保证对象有自己<strong>独立</strong>的字符串。</li>
<li>要考虑新名字比老名字长的问题。</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放老名字</span></span><br><span class="line"><span class="keyword">delete</span>[] name;</span><br><span class="line"><span class="comment">//重新分配内存空间</span></span><br><span class="line">name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s)+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//字符串拷贝，以拥有自己的名字</span></span><br><span class="line"><span class="built_in">strcpy</span>(name,s);</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-7-拷贝构造函数"   >
          <a href="#2-7-拷贝构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-7-拷贝构造函数" class="headerlink" title="2.7 拷贝构造函数"></a>2.7 拷贝构造函数</h2>
      
        <h3 id="2-7-1-拷贝构造函数"   >
          <a href="#2-7-1-拷贝构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-7-1-拷贝构造函数" class="headerlink" title="2.7.1 拷贝构造函数"></a>2.7.1 拷贝构造函数</h3>
      <ul>
<li><p>简单类型变量：</p>
<ul>
<li>int a(0);</li>
<li>int b(a);</li>
</ul>
</li>
<li><p>类类型</p>
<ul>
<li>Triangle t1(3.4.5); //自定义带参构造函数</li>
<li>Triangle t2(t1); //拷贝构造函数-自身类型的变量/对象</li>
</ul>
</li>
<li><p>拷贝构造函数</p>
<ul>
<li>共性：是一种特殊的构造函数，拥有构造函数的所有特性。</li>
<li>特性：并且使用自身类型的对象的引用作为构造函数的参数。</li>
<li>目的：通过一个对象初始化另一个对象。</li>
</ul>
</li>
</ul>
<p>语法：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    构造函数名(<span class="keyword">const</span> 类名&amp; 对象名)&#123;……&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h4 id="函数调用中的拷贝构造函数"   >
          <a href="#函数调用中的拷贝构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数调用中的拷贝构造函数" class="headerlink" title="函数调用中的拷贝构造函数"></a>函数调用中的拷贝构造函数</h4>
      <p>结论：函数参数为引用类型，因为实参就是形参，所以不会调用拷贝构造函数</p>

        <h3 id="2-7-2-浅拷贝"   >
          <a href="#2-7-2-浅拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-7-2-浅拷贝" class="headerlink" title="2.7.2 浅拷贝"></a>2.7.2 浅拷贝</h3>
      <ul>
<li>如果程序没有自定义拷贝构造函数，C++会提供一个<strong>默认拷贝构造函数</strong>。</li>
<li>默认拷贝构造函数的运行方式是：<strong>按位(bit by bit)复制</strong>，相当于自然界的克隆。</li>
<li>如果有指针类型的成员变量，简单的按位复制会导致两个对象中的指针指向同一段内存。而由于构造函数使用<code>new</code>分配内存，析构函数使用delete释放内存，进而导致一段内存会被释放两次，程序崩溃。</li>
</ul>
<p>类成员套类成员的时候，不会调用构造函数，如果构造函数有cpy的拷贝功能的话，会造成两个成员的字符串指针相同。同时释放函数栈的时候会调用两次析构函数，如果析构函数中有内存释放的话，会造成程序崩溃！</p>
<ul>
<li>结论<ul>
<li>如果没有指针类型的成员变量，默认析构函数、默认拷贝构造函数已经足够用了。</li>
<li>如果有指针类型的成员变量，必须自定义析构函数、自定义拷贝构造函数。</li>
<li>两个指针指向同一段内存，最容易造成<strong>指针悬挂</strong>。</li>
<li>两个指针指向非法的内存地址，那么这个指针就是悬挂指针，也叫<strong>野指针</strong>。意为无法正常使用的指针。</li>
</ul>
</li>
</ul>

        <h3 id="2-7-3-深拷贝"   >
          <a href="#2-7-3-深拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-7-3-深拷贝" class="headerlink" title="2.7.3 深拷贝"></a>2.7.3 深拷贝</h3>
      <ul>
<li>在含有指针类型成员变量的情况下，使用默认拷贝构造函数，按照按位复制的方法，则会产生<strong>浅拷贝</strong>。所以，我们要自定义拷贝构造函数以实现<strong>深拷贝</strong>。</li>
<li>新拷贝可以为新对象的指针分配一块内存空间，并将数据复制到新空间，以确保两个对象的指针指向各自的空间。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Demo::<span class="built_in">Demo</span>(<span class="keyword">const</span> Demo&amp; d)&#123;</span><br><span class="line">  name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(d.name)+<span class="number">1</span>];<span class="comment">//分配空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(name,d.name);<span class="comment">//拷贝函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Demo</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s); <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">Demo</span>(<span class="keyword">const</span> Demo&amp; d); <span class="comment">//拷贝构造函数</span></span><br><span class="line">  ~<span class="built_in">Demo</span>();</span><br><span class="line">  <span class="keyword">char</span>* name;  <span class="comment">//设置为公有成员变量，是为了方便观察</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Demo::<span class="built_in">Demo</span>(<span class="keyword">const</span> cahr* s)&#123;</span><br><span class="line">  name = <span class="keyword">new</span> <span class="keyword">char</span>][<span class="built_in">strlen</span>(s)+<span class="number">1</span>]; <span class="comment">//分配空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(name,s); <span class="comment">//拷贝数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Demp::<span class="built_in">Demo</span>(<span class="keyword">const</span> Demo&amp; d)&#123;</span><br><span class="line">  name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(d.name)+<span class="number">1</span>]; <span class="comment">//分配空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(name,d.name); <span class="comment">// 拷贝数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Demo::~<span class="built_in">Demo</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="提前剧透：赋值运算符"   >
          <a href="#提前剧透：赋值运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#提前剧透：赋值运算符" class="headerlink" title="提前剧透：赋值运算符"></a>提前剧透：赋值运算符</h4>
      <ul>
<li><p>在定义的同时进行赋值叫做初始化，定义完成以后再赋值(不管在定义的时候有没有赋值)就叫做赋值。初始化只能有一次，赋值可以有多次。</p>
</li>
<li><p>编译器提供默认赋值运算符，其机制也是“按位复制”。</p>
</li>
<li><p>int a(10); //Student s1(“Alice”);//带参构造函数</p>
</li>
<li><p>int b(a); Student s2(s1);//拷贝构造函数</p>
</li>
<li><p>a = b; s2 = s1; //赋值运算符</p>
</li>
</ul>

        <h4 id="“空”类的五个默认"   >
          <a href="#“空”类的五个默认" class="heading-link"><i class="fas fa-link"></i></a><a href="#“空”类的五个默认" class="headerlink" title="“空”类的五个默认"></a>“空”类的五个默认</h4>
      <ul>
<li><code>class A&#123;&#125;;</code>是一个空类</li>
<li>空类中至少包含四个成员函数<ol>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>默认拷贝构造函数</li>
<li>默认赋值运算符</li>
</ol>
</li>
<li>非静态成员函数拥有默认参数<code>this</code>。</li>
</ul>

        <h2 id="2-8-关键字修饰类的成员"   >
          <a href="#2-8-关键字修饰类的成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-8-关键字修饰类的成员" class="headerlink" title="2.8 关键字修饰类的成员"></a>2.8 关键字修饰类的成员</h2>
      <ul>
<li><p>const</p>
</li>
<li><p>static</p>
</li>
<li><p>&amp;</p>
</li>
<li><p>他们都是int类型</p>
</li>
<li><p>他们都需要初始化</p>
<ul>
<li>差别在于静态变量<strong>默认</strong>初始化为0</li>
</ul>
</li>
</ul>

        <h3 id="2-8-1-常成员"   >
          <a href="#2-8-1-常成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-8-1-常成员" class="headerlink" title="2.8.1 常成员"></a>2.8.1 常成员</h3>
      <ul>
<li><p><code>const int a</code></p>
</li>
<li><p>const和指针结合，有指向常量的指针、指针常量两种形式，而数字名是指针常量。</p>
</li>
<li><p>在类中：</p>
<ol>
<li>const修饰成员变量，常成员变量</li>
<li>const修饰成员函数，常成员函数</li>
</ol>
</li>
</ul>

        <h4 id="常成员变量"   >
          <a href="#常成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#常成员变量" class="headerlink" title="常成员变量"></a>常成员变量</h4>
      <ul>
<li>常成员变量，也是常变量，具有只读属性，所以不能作为左值(即不能出现在赋值运算符的左侧)，所以只能通过初始化表进行初始化。</li>
</ul>

        <h4 id="常成员函数"   >
          <a href="#常成员函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h4>
      <ul>
<li><p>使用const修饰的成员函数称为常成员函数</p>
</li>
<li><p>常成员函数的类内声明如下：</p>
<ul>
<li>返回值类型 函数名(参数列表)const;</li>
</ul>
</li>
<li><p>长成员函数的类外实现如下：</p>
<ul>
<li>返回值类型 类名::函数名(参数列表) const{函数体}</li>
</ul>
</li>
<li><p>常成员函数的用法</p>
<ol>
<li>常成员函数只能读取成员变量，而不能修改成员变量</li>
<li>常成员函数只能调用类内的其他成员函数，不能调用非常成员函数</li>
<li>常对象只能调用常函数</li>
<li>类中的常成员函数和非常成员函数，若函数名相同，及时参数列表也相同，也构成重载</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;x=<span class="number">100</span>;&#125; <span class="comment">//f1是非常成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span><span class="keyword">const</span></span>&#123; <span class="comment">//f2是常成员函数</span></span><br><span class="line">      x = <span class="number">100</span>;  <span class="comment">//常成员函数不能修改成员变量对的值</span></span><br><span class="line">      <span class="built_in">f1</span>(); <span class="comment">//常成员函数不能调用非常成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Domo d1; <span class="comment">//d1是一个对象</span></span><br><span class="line">  d1.<span class="built_in">f1</span>(); <span class="comment">//d1既可以调用普通的成员函数</span></span><br><span class="line">  d1.<span class="built_in">f2</span>(); <span class="comment">//也能调用常成员函数</span></span><br><span class="line">  <span class="keyword">const</span> Demo d2; <span class="comment">//d2是一个常对象</span></span><br><span class="line">  d2.<span class="built_in">f1</span>(); <span class="comment">//常对象不能调用非常成员函数</span></span><br><span class="line">  d2.<span class="built_in">f2</span>(); <span class="comment">//常对象只能调用常成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-8-2-静态成员"   >
          <a href="#2-8-2-静态成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-8-2-静态成员" class="headerlink" title="2.8.2 静态成员"></a>2.8.2 静态成员</h3>
      <ul>
<li><p>回忆静态static局部变量的知识点</p>
</li>
<li><p>静态变量存储在静态区域中</p>
</li>
<li><p>静态局部变量默认初始值为0</p>
</li>
<li><p>静态局部变量可以被一个函数的每次调用所 “共享”</p>
</li>
<li><p>一个类的静态成员变量可以被该类的所有对象所“共享”</p>
</li>
<li><p>静态成员变量需要类外初始化</p>
<ul>
<li>类型 类名::静态成员变量(初始值);</li>
</ul>
</li>
<li><p>使用static修饰的成员函数，称为静态成员函数。</p>
</li>
<li><p>成员函数都有默认参数this指针，指向当前对象。由于静态成员属于类、而不属于某个对象，所以静态成员函数的参数中没有默认的this指针。所以，静态成员函数无法调用非静态成员。</p>
</li>
</ul>

        <h3 id="2-8-3-单例模式"   >
          <a href="#2-8-3-单例模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-8-3-单例模式" class="headerlink" title="2.8.3 单例模式"></a>2.8.3 单例模式</h3>
      <ul>
<li><p>单例模式属于23种经典设计模式中最简单的一个，是唯一一个非面向对象的设计模式。</p>
</li>
<li><p>设计模式是软件开发人员你在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
</li>
<li><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</li>
<li><p>动机：在软件系统中，经常有这样一些特殊的类，必须保证他们在系统中只存在一个实例，才能确保它们逻辑正确性以及良好的效率。</p>
</li>
<li><p>这应该是类的设计者的责任，而不是使用者的责任。</p>
<ul>
<li>应该通过技术来保证，而非文字或口头来约束！</li>
</ul>
</li>
<li><p>单例模式属于创建型模式。单利类负责创建自己的对象，同时确保对象的唯一性。即：</p>
<ol>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ol>
</li>
<li><p>单例模式到底怎么实现呢？需要用到哪些技术呢？</p>
<ul>
<li>静态成员属于类而不属于某个对象，具备唯一性。</li>
<li>可以通过类名直接访问静态成员，而不是创建对象，提供了良好的访问方式。</li>
</ul>
</li>
<li><p>第一步，置之死地而后生</p>
<ul>
<li>由于构造函数一般都是共有的，所以程序员可以任意的创建或定义对象。</li>
<li>为了确保对象的唯一性，我们从“任意创建”的极端走向另一个极端，通过私有构造函数，确保无法从外部创建对象，而只能从内部创建对象，以确保对象的数量可控。</li>
</ul>
</li>
<li><p>第二步：为了确保唯一性应该是类的功能，而不是调用者的责任，所以内部要封装一个<strong>唯一实例的指针</strong>。</p>
</li>
<li><p>第三步：根据成员变量设计静态成员变量读取函数。</p>
</li>
<li><p>第四步：实现静态成员变量读取函数。</p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="keyword">static</span> Singleton* _instance;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(_instance == <span class="literal">nullptr</span>)</span><br><span class="line">    _instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">  <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Singleton::SetName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">  name = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Singleton::GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Singleton* p = Singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">  p-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Singleton* p = Singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">  q-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">  <span class="built_in">fun</span>();</span><br><span class="line">  cout &lt;&lt; q-&gt;<span class="built_in">GetName</span>() &lt;&lt; endl1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li>无需实例化一个对象</li>
<li>任何地方的修改都是针对同一个对象</li>
</ol>

        <h2 id="2-9-友元"   >
          <a href="#2-9-友元" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-9-友元" class="headerlink" title="2.9 友元"></a>2.9 友元</h2>
      <ul>
<li>友元，friend，好朋友</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;<span class="comment">//声明fun为友元</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetX</span><span class="params">(<span class="keyword">int</span> xx)</span></span>&#123;_x=xx;&#125;</span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Demo d;</span><br><span class="line">  d._x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>friend关键字把“外部”细分成了两类，好友的权限扩大了，非好友仍然严格执行访问权限。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherModule</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Demo d;</span><br><span class="line">  d._x = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">  d.<span class="built_in">Set</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>一般来说，只把用一个模块内部的函数或类声明为友元。友元一般用来给同一个模块内部的其他函数、类开了一个后门，可以直接访问私有成员。</li>
</ul>
<p>在类中将某一函数添加为友元后，可以直接在函数内部调用私有成员变量。</p>
<ul>
<li>友元函数<ul>
<li>把普通函数声明为友元函数</li>
<li>把其他类的成员函数声明为友元函数</li>
</ul>
</li>
<li>友元类</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>关于友元函数<ul>
<li>友元函数不是成员函数</li>
<li>友元函数的声明可以写在类中任意位置</li>
<li>友元函数不受访问权限的影响</li>
</ul>
</li>
<li>关于友元<ul>
<li>友元是单向的；如果需要互为好友，就必须各自单独声明</li>
<li>友元不具备传递性</li>
<li>友元关系不能被继承——好朋友的好朋友不是好朋友</li>
</ul>
</li>
</ul>

        <h3 id="高内聚、低耦合"   >
          <a href="#高内聚、低耦合" class="heading-link"><i class="fas fa-link"></i></a><a href="#高内聚、低耦合" class="headerlink" title="高内聚、低耦合"></a>高内聚、低耦合</h3>
      <ul>
<li>高内聚低耦合，是软件工程中的概念，是判断软件设计好坏的标准，主要用于程序的面向对象的设计。</li>
<li>目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。</li>
<li>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系</li>
<li>耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li>
</ul>

        <h2 id="2-10-总结"   >
          <a href="#2-10-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-10-总结" class="headerlink" title="2.10 总结"></a>2.10 总结</h2>
      <ul>
<li>对象数组如果没有初始化，则要求对象的无参构造函数。<ul>
<li>默认可以传数组进</li>
<li>设置了一个构造函数，数组可能会不能进去</li>
<li>想要值和数组都近要么设置两个构造函数，要么带默认参数</li>
</ul>
</li>
<li>函数以<code>char*</code>或者<code>const char*</code>作为参数，如果需要默认值，则该是<code>&quot;&quot;</code>，表示空字符串，而非<code>nullptr</code>。<ul>
<li>如果使用空指针的话，程序会直接报错。</li>
</ul>
</li>
<li>表示访问权限的三个关键字在类中可以出现多次，也没有顺序限制。</li>
<li>为什么有一些成员变量名要以<code>_</code>开头？<ul>
<li>系统级核心变量，避免重名，是一种习惯</li>
<li>私有成员变量有些人也习惯在前面加上<code>_</code></li>
</ul>
</li>
<li>class的默认访问权限是private</li>
<li>在C++中，struct具有和class完全相同的功能，只是它的默认访问权限是public</li>
</ul>

        <h1 id="第3单元-运算符重载"   >
          <a href="#第3单元-运算符重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#第3单元-运算符重载" class="headerlink" title="第3单元 运算符重载"></a>第3单元 运算符重载</h1>
      
        <h2 id="3-1-运算符重载概述"   >
          <a href="#3-1-运算符重载概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-运算符重载概述" class="headerlink" title="3.1 运算符重载概述"></a>3.1 运算符重载概述</h2>
      
        <h3 id="3-1-1-运算符重载的语法"   >
          <a href="#3-1-1-运算符重载的语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-1-运算符重载的语法" class="headerlink" title="3.1.1 运算符重载的语法"></a>3.1.1 运算符重载的语法</h3>
      <ul>
<li>C++的一大特性就是重载Overload</li>
<li>重载使得代码简洁高效</li>
<li>不仅仅可以针对函数进行重载，也可以针对运算符进行重载。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>): <span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)&#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Point&amp; other)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Point</span>(x+other.x,y+other.y);<span class="comment">//这里用了匿名函数，直接定义了一个函数省略了变量名，一次性的。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;]&quot;</span>;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>运算符重载的本质就是函数重载。注：但是不能说运算符的本质是函数，运算符和函数对应的二进制代码还是有很大差别的。</li>
<li>运算符的操作数，等价于函数参数</li>
<li>使用<code>operator运算符</code>替代函数名即可</li>
<li>例如，用<code>operator+</code>替换<code>add</code></li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)&#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Point &amp; other)</span></span>;</span><br><span class="line">    Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point &amp; other);<span class="comment">//加号运算符重载，重新定义+的功能。</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">Point::Add</span><span class="params">(<span class="keyword">const</span> Point &amp; other)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(x + other.x,y + other.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">1.2</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">3.4</span>)</span>,c</span>;</span><br><span class="line">  c = a.<span class="built_in">Add</span>(b);</span><br><span class="line">  c = a.<span class="keyword">operator</span>+(b); <span class="comment">//按照函数的方式调用operator+</span></span><br><span class="line">  c = a + b;<span class="comment">//按照运算符的方式调用operator+</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>充分证明：运算符重载的本质就是函数重载</p>

        <h4 id="运算符重载的规则"   >
          <a href="#运算符重载的规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算符重载的规则" class="headerlink" title="运算符重载的规则"></a>运算符重载的规则</h4>
      <ul>
<li>只能重载C++中已有的运算符，且不能创建新的运算符。</li>
<li>重载后运算符不能改变优先级和结合性，也不能改变操作数和语法结构。</li>
<li>运算符重载的目的是针对实际运算数据类型的需要，重载要保持原有运算符的语义，且要避免没有目的地使用运算符重载。</li>
<li>并非所有C++运算符都可以重载。不可重载的运算符包括：<ul>
<li>::</li>
<li>?:<ul>
<li>这个是那个三元表达式</li>
</ul>
</li>
<li>.</li>
<li>.*<ul>
<li>成员指针运算符</li>
</ul>
</li>
<li>sizeof</li>
<li>typeid</li>
<li>等</li>
</ul>
</li>
<li>可重载的运算符<ul>
<li>单目运算符</li>
<li>双目运算符<ul>
<li>[]下标运算符是双目运算符</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="3-1-3-运算符重载的形式"   >
          <a href="#3-1-3-运算符重载的形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-3-运算符重载的形式" class="headerlink" title="3.1.3 运算符重载的形式"></a>3.1.3 运算符重载的形式</h3>
      <ul>
<li>运算符重载有两种形式<ul>
<li>重载为类的成员变量</li>
<li>重载为全局函数，往往声明为类的友元函数</li>
</ul>
</li>
</ul>

        <h4 id="重载为类的成员函数"   >
          <a href="#重载为类的成员函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#重载为类的成员函数" class="headerlink" title="重载为类的成员函数"></a>重载为类的成员函数</h4>
      <ul>
<li>双目运算符<ul>
<li>左操作数是对象本身，由this指针指出<ul>
<li>运算符能否作为成员函数重载的条件</li>
</ul>
</li>
<li>右操作数通过函数参数传递</li>
</ul>
</li>
<li>单目运算符<ul>
<li>操作数就是对象本身，由this指针指出；参数列表为空</li>
<li>如果运算符区分前置、后置两种操作，例如++、–，则函数需要带一个整形参数，即<code>operator++(int)</code><ul>
<li>这是人为规定的。由于该参数不参与运算，所以无需变量名。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">    Point <span class="keyword">operator</span>++();<span class="comment">//前置++的声明</span></span><br><span class="line">    Point <span class="keyword">operator</span>++(<span class="keyword">int</span>)<span class="comment">//后置++的声明</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point Point::<span class="keyword">operator</span>++()&#123;<span class="comment">//前置++的实现</span></span><br><span class="line">  ++x;<span class="comment">//先++</span></span><br><span class="line">  ++y;<span class="comment">//先++</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//再返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point Point::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;<span class="comment">//后置++的实现</span></span><br><span class="line">  <span class="comment">//先返回，再++</span></span><br><span class="line">  <span class="function">Point <span class="title">r</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//用r记录需要返回的数据</span></span><br><span class="line">  ++(*<span class="keyword">this</span>);<span class="comment">//当前对象++</span></span><br><span class="line">  <span class="keyword">return</span> r;<span class="comment">//返回以前的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-1-4-重载为全局函数"   >
          <a href="#3-1-4-重载为全局函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-4-重载为全局函数" class="headerlink" title="3.1.4 重载为全局函数"></a>3.1.4 重载为全局函数</h3>
      <ul>
<li>重载为全局函数，往往声明为类的友元函数</li>
<li>重载为全局函数时，所有操作数都需要通过参数进行传递。</li>
<li>重载为全局函数，还是成员函数，一般没有差别。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> Point <span class="keyword">operator</span>-(cosnt Point&amp; p1.<span class="keyword">const</span> Point&amp; p2);<span class="comment">//减法声明为友元</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Point</span>(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">  Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp; other); <span class="comment">//加法重载为的成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::Show</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;]&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line">Point Point::<span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp; other)&#123; <span class="comment">//加法重载为成员函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(x+other.x,y+other.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)&#123; <span class="comment">//减法重载为全局函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(p1.x - p2.x, p1.y-p2.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-2-常用运算符重载"   >
          <a href="#3-2-常用运算符重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-常用运算符重载" class="headerlink" title="3.2 常用运算符重载"></a>3.2 常用运算符重载</h2>
      
        <h3 id="3-2-1-输入输出运算符的重载"   >
          <a href="#3-2-1-输入输出运算符的重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-1-输入输出运算符的重载" class="headerlink" title="3.2.1 输入输出运算符的重载"></a>3.2.1 输入输出运算符的重载</h3>
      <ul>
<li>C++的IO系统提供了<code>&gt;&gt;</code>和<code>&lt;&lt;</code>两个运算符执行IO操作。但标准库只定义了基本数据类型的IO……</li>
<li>输入输出运算符重载是双目运算符</li>
<li>双目运算符重载为成员函数<ul>
<li>左操作数十对象本身，由this指针指出</li>
<li>右操作数通过函数参数传递</li>
</ul>
</li>
<li>输入输出运算符只能重载为全局函数。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream <span class="keyword">operator</span>&lt;&lt;(ostream o, <span class="keyword">const</span> Point&amp; p)&#123;</span><br><span class="line"> ……;</span><br><span class="line"> <span class="keyword">return</span> o;<span class="comment">//输出运算符从左往右的顺序结合，左边运算符的返回值就是下一个运算符的左操作数</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<ul>
<li>外部设备具有唯一性，代表外部设备的cout对象也不能有两个！</li>
<li>形参到实参的拷贝，函数的返回值，都会调用拷贝构造函数</li>
<li>为了避免在内存中有两个对象代表同一个设备，因此左操作数和返回值都是ostream&amp;</li>
<li>输入和输出肯定要涉及数据的读写操作，所以不能是const</li>
</ul>
<p>自定义<code>class Demo</code>的输出运算符虫子啊，往往是一下形式：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Demo&amp; d);</span><br><span class="line">  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; i,<span class="keyword">const</span> Demo&amp; d);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Demo&amp; d)&#123;……;<span class="keyword">return</span> o;&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; i,<span class="keyword">const</span> Demo&amp; d)&#123;……;<span class="keyword">return</span> i;&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>流输出运算符重载的知识点<ul>
<li>为什么流输出运算符只能重载为全局函数，不能重载为成员函数？<ul>
<li>重载为成员函数的条件是：左操作数是当前类型的对象，而流输出运算符的左操作数cout的类型是ostream。</li>
</ul>
</li>
<li>流输出运算符重载的函数原型，使用了三处引用，有什么区别？<ul>
<li>右操作数是当前类型的常引用，是为了避免实参到形参的拷贝以及起到制度作用；左操作数和返回值实际上都是cout，代表设备，类型都是<code>ostream&amp;</code>，是为了确保<strong>设备对象的唯一性</strong>。</li>
</ul>
</li>
<li>流输出运算符为什么要返回左操作数？<ul>
<li>返回左操作数，也就是返回cout，是为了实现流输出运算符的连续使用。</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="3-2-2-关系运算符重载"   >
          <a href="#3-2-2-关系运算符重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-2-关系运算符重载" class="headerlink" title="3.2.2 关系运算符重载"></a>3.2.2 关系运算符重载</h3>
      <ul>
<li>让数据有序是改进算法、提高程序运行速度的最基本的方法。</li>
<li>如何对一个Point数组按照到原点的距离从小到大进行排序？<ul>
<li>难点：需要重载&gt;运算符，因为Point类型无法进行比较</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(Point arr[],<span class="keyword">int</span> len)</span></span>&#123;……&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o, Point arr[])&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">    o &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Point allPoints[SIZE] = &#123;<span class="built_in">Point</span>(<span class="number">3</span>,<span class="number">4</span>),<span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">8</span>),<span class="built_in">Point</span>(<span class="number">3</span>,<span class="number">6</span>),<span class="built_in">Point</span>(<span class="number">4</span>,<span class="number">7</span>)&#125;;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;排序前：&quot;</span>&lt;&lt;allPoints&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">bubbleSort</span>(allPoints,SIZE);</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;排序后&quot;</span>&lt;&lt;allPoints&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>两个浮点数不能用逻辑<code>==</code>判断是否相等</strong></li>
</ul>
<p><code>(abs(x-other.x)&lt;1e-7)&amp;&amp;(abs(y-other.y)&lt;1e-7)</code></p>
<p>例子：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Point中重载&lt;</span></span><br><span class="line"><span class="comment">//规则：首先判断x，x小的，point对象也小，x相等的，在判断y</span></span><br><span class="line"><span class="keyword">bool</span> Point::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point&amp; other)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">abs</span>(x-other.x)&lt;<span class="number">1e-7</span>)<span class="comment">//即x==other.x</span></span><br><span class="line">    <span class="keyword">return</span> y&lt;other.y;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> x&lt;other.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-2-3-重载赋值运算符"   >
          <a href="#3-2-3-重载赋值运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-3-重载赋值运算符" class="headerlink" title="3.2.3 重载赋值运算符"></a>3.2.3 重载赋值运算符</h3>
      <ul>
<li><p>初始化运算符和赋值运算符是两个运算符，但都使用了<code>=</code>。</p>
</li>
<li><p>在定义变量(或对象)的时候，使用<code>=</code>，是初始化运算符。针对对象，会调用构造函数。例如：<code>int a = 3</code></p>
</li>
<li><p>针对已经存在的变量(或对象)使用<code>=</code>，则是赋值。例如：<code>int a;a=3;</code></p>
</li>
<li><p>赋值运算符可以重载</p>
</li>
<li><p>如果程序员不提供赋值运算符，则编译器会提供一个<strong>默认</strong>的赋值运算符。</p>
<ul>
<li>默认复制运算符<strong>按位拷贝</strong>。除了调用时机不一样，赋值运算符与拷贝构造函数基本一致。</li>
<li>如果有指针类型的成员变量，则是<strong>浅拷贝</strong>。此时，应重载赋值运算符实现<strong>深拷贝</strong></li>
</ul>
</li>
<li><p>赋值运算符的结合顺序是：从右向左，一致<code>Point a(1,2),b,c;</code></p>
</li>
<li><p>左侧=的右操作数是表达式<code>b=a</code>的值，所以赋值运算符的返回值类型是Point。为了提高效率(减少一次拷贝构造函数的调用)，返回值类型是<code>Point&amp;</code>。</p>
</li>
<li><p><code>MyString s1(&quot;Hello&quot;);</code></p>
</li>
<li><p><code>MyString s2(s1);</code></p>
</li>
<li><p><code>MyString s3(6,&#39;A&#39;);</code></p>
</li>
<li><p><code>s1=s3;</code></p>
</li>
<li><p><code>cout &lt;&lt; s1 &lt;&lt; &quot;,&quot; &lt;&lt; s2 &lt;&lt; &quot;,&quot; &lt;&lt; s3 &lt;&lt; endl;</code> </p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;</span><br><span class="line">  _s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];<span class="comment">//分配内存空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(_s,str);<span class="comment">//拷贝数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; other)&#123;</span><br><span class="line">  _s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other,_s)+<span class="number">1</span>];<span class="comment">//分类内存空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(_s,other._s);<span class="comment">//拷贝数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; other)&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _s;  <span class="comment">//对象创建的时候已经new[]了，必须先释放</span></span><br><span class="line">  _s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other._s)+<span class="number">1</span>];  <span class="comment">//才能分配新的空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(_s,other._s);  <span class="comment">//拷贝数据</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回当前</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">int</span> count,<span class="keyword">char</span> c)&#123;</span><br><span class="line">  _s = <span class="keyword">new</span> <span class="keyword">char</span>[count+<span class="number">1</span>]; <span class="comment">//分配内存空间</span></span><br><span class="line">  <span class="built_in">memset</span>(_s,c,count); <span class="comment">//前面设置count个c</span></span><br><span class="line">  _s[count]=<span class="string">&#x27;\0&#x27;</span>; <span class="comment">//最后一位设置结束标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::~<span class="built_in">MyString</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">  o&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>&lt;&lt;str._s&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>;  <span class="comment">//转义字符</span></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-2-4-下标运算符重载"   >
          <a href="#3-2-4-下标运算符重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-4-下标运算符重载" class="headerlink" title="3.2.4 下标运算符重载"></a>3.2.4 下标运算符重载</h3>
      <ul>
<li>[]运算符<ul>
<li>通常用于<strong>读、写</strong>数组中的某一个元素</li>
<li>是一个双目运算符</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> MyString::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">  <span class="keyword">return</span> _s[index];<span class="comment">//相当于*(_s+index)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">str</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;<span class="comment">//str的成员变量_s指向了&quot;abc&quot;</span></span><br><span class="line">  cout&lt;&lt;str[<span class="number">1</span>]&lt;&lt;endl;<span class="comment">//输出str.s[1],也就是&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>重载下标运算符的目的<ul>
<li>采用“下标”这一程序员习惯的编写形式，读取/修改对象的部分内容。</li>
<li>下标运算符的右操作数不一定是从0开始的自然数，可以是任意类型。</li>
<li>可以实现<code>关键字到值的映射</code></li>
<li>可以对下标进行越界检查</li>
</ul>
</li>
</ul>

        <h3 id="3-2-6-MyString"   >
          <a href="#3-2-6-MyString" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-6-MyString" class="headerlink" title="3.2.6 MyString"></a>3.2.6 MyString</h3>
      <ul>
<li>前++</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyString MyString::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(_s);</span><br><span class="line">  <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//空串直接返回</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* temp = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">2</span>];</span><br><span class="line">  temp[<span class="number">0</span>] = _s[<span class="number">0</span>];  <span class="comment">//复制最前的字符串</span></span><br><span class="line">  <span class="built_in">strcpy</span>(temp+<span class="number">1</span>,s); <span class="comment">//复制旧字符串</span></span><br><span class="line">  <span class="keyword">delete</span>[] _s;      <span class="comment">//释放旧字符串</span></span><br><span class="line">  _s=temp;          <span class="comment">//更新当前对象</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>后++</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyString MyString::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(_s);</span><br><span class="line">  <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//空字符串直接返回</span></span><br><span class="line"></span><br><span class="line">  <span class="function">MyString <span class="title">r</span><span class="params">(_s)</span></span>;<span class="comment">//准备好返回值，即当前字符串</span></span><br><span class="line">  <span class="keyword">char</span>* temp = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(temp,_s);      <span class="comment">//复制旧字符串</span></span><br><span class="line">  temp[len]=_s[len<span class="number">-1</span>];  <span class="comment">//复制最后的字符</span></span><br><span class="line">  temp[len+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;     <span class="comment">//结束标志</span></span><br><span class="line">  <span class="keyword">delete</span>[] _s;          <span class="comment">//释放旧字符串</span></span><br><span class="line">  _s = temp;            <span class="comment">//更新当前对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>前–</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString MyString::<span class="keyword">operator</span>--()&#123;</span><br><span class="line">  <span class="keyword">char</span>* temp = _s;</span><br><span class="line">  <span class="keyword">if</span>(*temp)<span class="comment">//如果不为空，等价于*temp!=&#x27;\0&#x27;</span></span><br><span class="line">  <span class="comment">//吧后面的字符依次向前拷贝，</span></span><br><span class="line">    <span class="keyword">while</span>(*temp=*(temp+<span class="number">1</span>))<span class="comment">//遇见&#x27;\0&#x27;为止</span></span><br><span class="line">      ++temp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>后–</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString MyString::<span class="keyword">operator</span>--(<span class="keyword">int</span>)&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">r</span><span class="params">(_s)</span></span>;<span class="comment">//准备好返回的当前对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* temp = _s;</span><br><span class="line">  <span class="keyword">if</span>(*temp)&#123;  <span class="comment">//如果不为空，等价于*temp!=&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span>(*(temp+<span class="number">1</span>))++temp;<span class="comment">//找到最后一个字符</span></span><br><span class="line">    *temp = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//把最后一个字符置零</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>-=删除字符’b’<ul>
<li>需要<strong>复制</strong>字符<ul>
<li>拷贝</li>
<li>src指向下一个字符</li>
<li>dst指向下一个字符</li>
</ul>
</li>
<li>需要<strong>删除</strong>字符<ul>
<li>src指向下一个字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法一</span></span><br><span class="line">MyString MyString::<span class="keyword">operator</span>-=(<span class="keyword">char</span> c)&#123;</span><br><span class="line">  <span class="keyword">int</span> src = <span class="number">0</span>,dst = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(_s);</span><br><span class="line">  <span class="keyword">while</span>(src&lt;len)&#123; <span class="comment">//循环遍历</span></span><br><span class="line">    <span class="keyword">if</span>(_s[src]==c)<span class="comment">//如果要删除字符</span></span><br><span class="line">      src++;      <span class="comment">//准备处理下一个字符</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//如果要复制字符，先复制、再移动</span></span><br><span class="line">      _s[dst++]=_s[src++];</span><br><span class="line">  &#125;</span><br><span class="line">  _s[dst] = <span class="number">0</span>;  <span class="comment">//设置结束标志</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法二</span></span><br><span class="line">MyString MyString::<span class="keyword">operator</span>-=(<span class="keyword">char</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> src = <span class="number">0</span>,dst = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(_s);<span class="function">l</span></span><br><span class="line"><span class="function">  <span class="title">while</span><span class="params">(src&lt;len)</span></span>&#123; <span class="comment">//循环遍历</span></span><br><span class="line">    <span class="keyword">if</span>(_s[src]!=c)</span><br><span class="line">      _s[dst++]=_s[src];</span><br><span class="line">    src++;</span><br><span class="line">  &#125;</span><br><span class="line">  _s[dst] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>原字符串复制n变<code>*=</code></li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyString MyString::<span class="keyword">operator</span>*=(<span class="keyword">int</span> n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(_s);</span><br><span class="line">  <span class="keyword">char</span>* temp = <span class="keyword">new</span> <span class="keyword">char</span>[len * n+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memset</span>(temp,<span class="number">0</span>,len*n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    <span class="built_in">strcat</span>(temp,s);</span><br><span class="line">  <span class="keyword">delete</span>[] _s;</span><br><span class="line">  _s = temp;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-3-类型转换"   >
          <a href="#3-3-类型转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-类型转换" class="headerlink" title="3.3 类型转换"></a>3.3 类型转换</h2>
      
        <h3 id="3-3-1-转换构造函数"   >
          <a href="#3-3-1-转换构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-1-转换构造函数" class="headerlink" title="3.3.1 转换构造函数"></a>3.3.1 转换构造函数</h3>
      
        <h3 id="3-3-2-1-转换构造函数"   >
          <a href="#3-3-2-1-转换构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-2-1-转换构造函数" class="headerlink" title="3.3.2.1 转换构造函数"></a>3.3.2.1 转换构造函数</h3>
      <ul>
<li>如果构造函数只有一个参数，且参数不是本类的常引用，称之为<strong>转换构造函数</strong>。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(B b); <span class="comment">//B是一个简单类型</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> C&amp; c);  <span class="comment">//C是一个复杂类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li><p>将简单类型的变量，或者复杂类型的对象，转换成当前类型。</p>
</li>
<li><p>调用函数的时候，强调的是实参和形参类型匹配。</p>
</li>
<li><p>如果不一致，但是匹配，则编译器会自动调用默认类型转换或者类型转换函数。</p>
</li>
</ul>

        <h3 id="3-3-2-2-返回匿名对象、返回引用、转换构造函数、运算符重载"   >
          <a href="#3-3-2-2-返回匿名对象、返回引用、转换构造函数、运算符重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-2-2-返回匿名对象、返回引用、转换构造函数、运算符重载" class="headerlink" title="3.3.2.2 返回匿名对象、返回引用、转换构造函数、运算符重载"></a>3.3.2.2 返回匿名对象、返回引用、转换构造函数、运算符重载</h3>
      <ul>
<li><p>匿名对象、临时对象</p>
</li>
<li><p>匿名对象仅在当前语句有效，当前语句执行完毕后会被释放(调用析构函数)。</p>
</li>
<li><p>生存周期仅在当前这一行</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x=<span class="number">0</span>)&#123;……;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个场景</span></span><br><span class="line"><span class="function">A <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//A result(100);</span></span><br><span class="line">  <span class="comment">//return result;</span></span><br><span class="line">  <span class="comment">//return A result(100);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">100</span>);<span class="comment">//这里就是一个匿名函数，省略了对象名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(<span class="built_in">A</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A allAs[] = &#123;<span class="built_in">A</span>(<span class="number">1</span>),<span class="built_in">A</span>(<span class="number">2</span>),<span class="built_in">A</span>(<span class="number">3</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>编译器会尝试把int转换成匿名对象</p>
</li>
<li><p>建议</p>
<ul>
<li>直接返回匿名对象，编译器会自动优化，把匿名对象和返回值合二为一</li>
</ul>
</li>
<li><p>能否返回引用？</p>
<ul>
<li>函数不能返回局部变量的引用</li>
<li>在能够返回引用的情况下，返回引用能够提高程序的运行效率</li>
</ul>
</li>
<li><p>全局函数和成员函数不构成重载(函数之间没有重载关系)，但能构成某一运算符的重载</p>
</li>
</ul>

        <h3 id="3-3-3-类型转换函数"   >
          <a href="#3-3-3-类型转换函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-3-类型转换函数" class="headerlink" title="3.3.3 类型转换函数"></a>3.3.3 类型转换函数</h3>
      <ul>
<li>转换构造函数可以实现<strong>任意类型=&gt;当前类类型</strong>的转换</li>
<li>C++提供了类型转换函数实现当前类类型到任意类型的转换。</li>
<li>自定义类型可以自己设计，但是如果要重新定义封装好的类型，就只能类型转换了</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span></span>;<span class="comment">//A=&gt;B</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>如果B是自定义类类型</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">  <span class="built_in">B</span>(<span class="keyword">const</span> A&amp; a);<span class="comment">//A=&gt;B</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure></li>
<li><p>实例：</p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;……;&#125;</span><br><span class="line">    <span class="comment">/*int*/</span><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">strlen</span>(_s);&#125;<span class="comment">//省略了返回值类型</span></span><br><span class="line">    <span class="comment">//一是为了保持简洁的风格，而是因为省略了返回值类型不会造成歧义</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;Hello,World!&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> len=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>另一个实例：</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> Name&amp; name);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>;</span><br><span class="line">  string&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> string&amp; index);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string firstName; <span class="comment">//名字</span></span><br><span class="line">  string midName;   <span class="comment">//中间名</span></span><br><span class="line">  string lastName;  <span class="comment">//姓氏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Name::<span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>&#123;</span><br><span class="line">  stringstream ss;  <span class="comment">//定义字符串流对象，#include &lt;sstream&gt;</span></span><br><span class="line">  ss&lt;&lt;firstName&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;midName&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;lastName;</span><br><span class="line">  <span class="keyword">return</span> ss.<span class="built_in">str</span>();  <span class="comment">//把流对象转换成字符串并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Name James;</span><br><span class="line">  James[<span class="string">&quot;first&quot;</span>]=<span class="string">&quot;James&quot;</span>;</span><br><span class="line">  James[<span class="string">&quot;mid&quot;</span>]=<span class="string">&quot;Robert&quot;</span>;</span><br><span class="line">  James[<span class="string">&quot;last&quot;</span>]=<span class="string">&quot;Smith&quot;</span>;</span><br><span class="line">  string str = James; <span class="comment">//两侧类型不一致，编译器自动进行类型转换</span></span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-4-仿函数——重载-运算符"   >
          <a href="#3-4-仿函数——重载-运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4-仿函数——重载-运算符" class="headerlink" title="3.4 仿函数——重载()运算符"></a>3.4 仿函数——重载()运算符</h2>
      <ul>
<li><p><code>()</code>，函数运算符，是函数的标志，用来标志参数列表。</p>
</li>
<li><p>不是有()就是函数</p>
</li>
<li><p>仿函数指的是：在类中重载了<code>()</code>之后，这个类的对象可以像函数一样使用。</p>
</li>
<li><p>仿函数在<code>STL的算法</code>中使用非常广泛。<code>Lambda表达式</code>也是对仿函数的扩展。</p>
</li>
<li><p>C语言中通过<code>函数指针</code>也可以达到仿函数、Lambda表达式的效果。</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string str)</span><span class="comment">//()运算符重载函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> num)</span><span class="comment">//()运算符重载函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num*num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Show s;</span><br><span class="line">  <span class="built_in">s</span>(<span class="string">&quot;abcdef&quot;</span>);  <span class="comment">//  把对象当做函数调用</span></span><br><span class="line">  cout&lt;&lt;<span class="built_in">s</span>(<span class="number">4</span>)&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="第4单元-继承与派生"   >
          <a href="#第4单元-继承与派生" class="heading-link"><i class="fas fa-link"></i></a><a href="#第4单元-继承与派生" class="headerlink" title="第4单元 继承与派生"></a>第4单元 继承与派生</h1>
      
        <h2 id="4-1-继承"   >
          <a href="#4-1-继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-继承" class="headerlink" title="4.1 继承"></a>4.1 继承</h2>
      
        <h3 id="4-1-1-继承的概念"   >
          <a href="#4-1-1-继承的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-1-继承的概念" class="headerlink" title="4.1.1 继承的概念"></a>4.1.1 继承的概念</h3>
      <ul>
<li><p>面向对象提供了继承机制</p>
<ul>
<li>可以在原有类的基础上，通过简单的程序构造功能更加强大的新类，从而实现<strong>代码复用</strong>，提高软件开发效率。</li>
<li>换言之，继承就是一个类从另一个类获取成员变量和成员函数的过程。例如类B继承与类A，那么B就拥有A的成员变量和成员函数。</li>
</ul>
</li>
<li><p>派生</p>
<ul>
<li>在C++中，派生(Derive)和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。</li>
</ul>
</li>
<li><p>新构建的类称为<strong>子类</strong>或<strong>派生类</strong>，现有类称为<strong>父类</strong>或<strong>基类</strong>。</p>
</li>
<li><p>C++中可以通过派生形成类的层次结构，称之为<strong>类族</strong>，即一个基类可以是另一个更高层次的派生类，而派生类也可以继续产生派生类。</p>
</li>
<li><p>派生类的语法</p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span>继承方式 基类名&#123;</span><br><span class="line">  派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>小例子：</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span><span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span><span class="keyword">public</span> Animal&#123;&#125;;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>派生类和基类的关系也称之为“is-a”，也就是：鱼是一种动物</p>
</li>
<li><p>还有一种关系叫做“has-a”，即组合。</p>
</li>
<li><p>几点注意事项</p>
<ol>
<li>积累的<strong>构造/析构函数不能被继承</strong><ul>
<li>派生类拥有自己的构造/析构函数。同时，也拥有基类的所有成员(包括基类的构造/析构函数)，只是不能作为派生类的构造/析构函数来使用。</li>
</ul>
</li>
<li>派生类继承基类的<strong>全部</strong>成员<ul>
<li>拥有但不一定有访问权限</li>
</ul>
</li>
<li>基类和派生类是<strong>多对多</strong>的关系<ol>
<li>一个基类可以对多个派生类</li>
<li>一个派生类可以对应多个基类</li>
</ol>
</li>
<li>派生类可以<strong>新增成员</strong>，用于实现新功能</li>
</ol>
</li>
</ul>

        <h3 id="Animal-Project实践"   >
          <a href="#Animal-Project实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#Animal-Project实践" class="headerlink" title="Animal Project实践"></a>Animal Project实践</h3>
      <blockquote>
<p>AnimalProject.cpp</p>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Animal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Fish <span class="title">fish</span><span class="params">(<span class="string">&quot;海棠&quot;</span>)</span></span>;</span><br><span class="line">  fish.<span class="built_in">Eat</span>();</span><br><span class="line">  fish.<span class="built_in">Swim</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>Animal.h</p>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Animal</span>(string str);</span><br><span class="line">   <span class="function">string <span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span> <span class="comment">//派生类拥有基类的所有成员</span></span><br><span class="line">  <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fish</span>(string str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>Animal.cpp</p>
</blockquote>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Animal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Animal::<span class="built_in">Animal</span>(string str):<span class="built_in">name</span>(str)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Animal::GetName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::Eat</span><span class="params">()</span></span>&#123;cout&lt;&lt;name&lt;&lt;<span class="string">&quot; eating&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">Fish::<span class="built_in">Fish</span>(string str):<span class="built_in">Animal</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fish::Swim</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="built_in">GetName</span>()&lt;&lt;<span class="string">&quot; swiming&quot;</span>&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>总结<ul>
<li>继承的主要作用是实现<strong>代码复用</strong>。把类的相同成员那些在基类中，把类的不同成员写在派生类中。</li>
<li>派生类拥有基类的所有成员，但是，派生类不能直接访问基类的私有成员。</li>
</ul>
</li>
</ul>

        <h3 id="4-1-2-继承方式"   >
          <a href="#4-1-2-继承方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-2-继承方式" class="headerlink" title="4.1.2 继承方式"></a>4.1.2 继承方式</h3>
      <ul>
<li>派生类拥有基类的所有成员，但是能否访问不仅受到成员自身的访问权限属性影响，还受继承方式影响。</li>
<li>类的继承方式有三种：<ul>
<li>共有public继承<ul>
<li>最常用继承方式</li>
<li>类内、子类、类外可以访问</li>
</ul>
</li>
<li>保护protect继承<ul>
<li>类内、子类可以访问</li>
</ul>
</li>
<li>私有private继承<ul>
<li>默认继承方式</li>
<li>类内可以访问，子类不能访问</li>
</ul>
</li>
</ul>
</li>
<li>继承方式和访问权限是两个概念，只是使用了相同的关键字。</li>
</ul>
<ol>
<li>基类成员在派生类中的访问权限不得高于继承方式中指定的权限<ul>
<li>继承方式中的<code>public private</code>是用来指明基类成员在派生类中的<strong>最高访问权限</strong>的。</li>
</ul>
</li>
<li>不管继承方式如何，基类中的private成员以及不可访问成员，在派生类中始终<strong>不能直接使用</strong>。</li>
</ol>
<ul>
<li>在当前类中应该如何使用继承方式和访问权限？<ol>
<li>当前类中不允许在派生类中使用、更不允许向外暴露的成员，应声明为<code>private</code></li>
<li>当前类中允许派生类中使用、但不向外暴露(不能通过对象访问)，声明为<code>protected</code></li>
<li>当前类中即允许派生类使用、也允许向外暴露的，声明为<code>public</code></li>
</ol>
</li>
</ul>

        <h3 id="4-1-3-类型兼容"   >
          <a href="#4-1-3-类型兼容" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-3-类型兼容" class="headerlink" title="4.1.3 类型兼容"></a>4.1.3 类型兼容</h3>
      <p>不同类型的数据在一定条件下可以进行转换，称为类型转换，也称为类型兼容。</p>
<p>在C++中，基类与派生类之间也存在类型兼容。</p>
<ul>
<li>类型兼容的形式<ol>
<li>使用公有派生类对象为基类对象赋值</li>
</ol>
<ul>
<li>子类变量可以赋值给父类变量</li>
<li>父类变量不能赋值给子类变量</li>
</ul>
<ol start="2">
<li>使用公有派生类对象为基类对象的引用赋值</li>
<li>使用公有派生类对象的指针为基类指针赋值</li>
<li>如果函数的参数是基类对象、基类对象的引用、基类指针，则函数在调用时，可以使用公有派生类对象、公有派生类对象的地址作为实参。</li>
</ol>
</li>
</ul>

        <h3 id="4-1-4-父类指针指向子类对象"   >
          <a href="#4-1-4-父类指针指向子类对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-4-父类指针指向子类对象" class="headerlink" title="4.1.4 父类指针指向子类对象"></a>4.1.4 父类指针指向子类对象</h3>
      <p>父类指针数组指向所有子类对象</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素类型 数组名[数组大小];</span></span><br><span class="line">Animal* allAnis[<span class="number">4</span>]; <span class="comment">//父类指针数组</span></span><br><span class="line">allAnis[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Fish</span>(<span class="string">&quot;大鱼&quot;</span>);<span class="comment">//父类指针指向子类对象</span></span><br><span class="line">allAnis[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Bird</span>(<span class="string">&quot;大鸟&quot;</span>);</span><br><span class="line">allAnis[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Fish</span>(<span class="string">&quot;小鱼&quot;</span>);</span><br><span class="line">allAnis[<span class="number">3</span>] = <span class="keyword">new</span> <span class="built_in">Bird</span>(<span class="string">&quot;小鸟&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">  allAnis[i]-&gt;<span class="built_in">Eat</span>();  <span class="comment">//通过父类指针数组的元素调用公有成员</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>RTTI(运行时类型识别)，它使程序能够获取由基类指针(引用)所指向的成员的实际派生类型。</li>
<li>在C++中，为了支持RTTI提供了两个操作符<ul>
<li>dynamic_cast</li>
<li>typeid</li>
</ul>
</li>
</ul>

        <h2 id="4-2-派生类"   >
          <a href="#4-2-派生类" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-派生类" class="headerlink" title="4.2 派生类"></a>4.2 派生类</h2>
      
        <h3 id="4-2-1-派生类的构造函数与析构函数"   >
          <a href="#4-2-1-派生类的构造函数与析构函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-1-派生类的构造函数与析构函数" class="headerlink" title="4.2.1 派生类的构造函数与析构函数"></a>4.2.1 派生类的构造函数与析构函数</h3>
      <p>派生类的成员变量包括从基类继承的成员变量和新增的成员变量，因此，派生类的构造函数除了要初始化派生类中新增的成员变量，还要初始化基类的成员变量，即派生类的构造函数要负责调用基类的构造函数。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数(参数列表):基类构造函数(基类构造函数参数列表)</span><br><span class="line">&#123;</span><br><span class="line">  派生类新增成员的初始化语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在定义派生类构造参数时，通过<code>:</code>运算符在后面完成基类构造函数的调用。基类构造函数的参数从派生类构造函数的参数列表中获取。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> <span class="comment">//基类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> aa,<span class="keyword">int</span> bb):<span class="built_in">ma</span>(aa),<span class="built_in">mb</span>(bb)&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma,mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span><span class="keyword">public</span> Base&#123; <span class="comment">//派生类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb,<span class="keyword">int</span> xx,<span class="keyword">int</span> yy,<span class="keyword">int</span> zz):<span class="built_in">Base</span>(aa,bb),<span class="built_in">mx</span>(xx),<span class="built_in">my</span>(yy),<span class="built_in">mz</span>(zz)&#123;&#125;<span class="comment">//初始化各变量</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> max,my,mz;  <span class="comment">//除此之外还有基类的两个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>如果基类有无参构造函数(包括默认构造函数)，则在定义派生类构造函数时可以<strong>省略</strong>对基类构造函数的调用</p>
</li>
<li><p>尽管没有调用基类无参构造函数，但依然会执行基类无参构造函数</p>
</li>
<li><p>如果基类定义了有参构造函数，派生类必须定义构造函数，提供基类构造函数的参数，完成基类成员变量的初始化。</p>
</li>
<li><p>构造函数的调用顺序：基类=&gt;成员对象=&gt;派生类</p>
</li>
<li><p>析构函数的调用顺序反过来</p>
</li>
</ul>

        <h3 id="4-2-2-在派生类中隐藏基类成员函数"   >
          <a href="#4-2-2-在派生类中隐藏基类成员函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-2-在派生类中隐藏基类成员函数" class="headerlink" title="4.2.2 在派生类中隐藏基类成员函数"></a>4.2.2 在派生类中隐藏基类成员函数</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>&#123;</span>  <span class="comment">//定义交通工具类Vehicle</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; <span class="comment">//交通工具普通成员函数run()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Vehicle::run</span><span class="params">()</span></span>&#123;  <span class="comment">//类外实现run()函数</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;基类run()函数:行驶&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span>:<span class="keyword">public</span> Vehicle&#123;  <span class="comment">//定义小汽车类，继承Vehicle</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Car::run</span><span class="params">()</span></span>&#123;  <span class="comment">//小汽车类普通成员函数run()实现</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;小汽车需要燃烧汽油，行驶速度快&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Car car;</span><br><span class="line">  car.<span class="built_in">run</span>();  <span class="comment">//派生类run</span></span><br><span class="line">  car.Vehicle::<span class="built_in">run</span>(); <span class="comment">//通过基类名与作用域限定符调用run()函数</span></span><br><span class="line">  Vehicle* pv=&amp;car; </span><br><span class="line">  pv-&gt;<span class="built_in">run</span>();  <span class="comment">//基类指针调用基类run()函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-3-多继承"   >
          <a href="#4-3-多继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-3-多继承" class="headerlink" title="4.3 多继承"></a>4.3 多继承</h2>
      <p>派生类有多个基类</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>&#123;</span>&#125;</span><br><span class="line">calss Derive:<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2 &#123;&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-4-虚继承"   >
          <a href="#4-4-虚继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-4-虚继承" class="headerlink" title="4.4 虚继承"></a>4.4 虚继承</h2>
      <p>间接基类的成员变量在底层派生类中只有一份拷贝，从而避免成员访问的二义性。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> <span class="keyword">virtual</span> 权限控制符 基类名&#123;</span><br><span class="line">  派生类成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="第5章-多态与虚函数"   >
          <a href="#第5章-多态与虚函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#第5章-多态与虚函数" class="headerlink" title="第5章 多态与虚函数"></a>第5章 多态与虚函数</h1>
      
        <h2 id="5-1-概述"   >
          <a href="#5-1-概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2>
      <ul>
<li><p>封装</p>
</li>
<li><p>继承</p>
</li>
<li><p>多态</p>
</li>
<li><p>向不同的对象发送同一个消息(即成员函数的调用)，会产生不同的行为。</p>
</li>
<li><p>多态是一种：调用同名函数却因上下文不同会有不同实现的一种机制。</p>
</li>
<li><p>多态带来的好处</p>
<ul>
<li>不用记大量的函数名</li>
<li>会一句调用时的上下文来自动确定实现</li>
<li>带来了面向对象的编程</li>
</ul>
</li>
<li><p>静态多态(静态联编)</p>
<ul>
<li>编译时实现，不影响运行速度</li>
<li>重载  Overload</li>
</ul>
</li>
<li><p>动态多态(动态联编)</p>
<ul>
<li>运行时实现，需要查找虚函数表，影响运行速度</li>
<li>继承和虚函数</li>
</ul>
</li>
</ul>

        <h2 id="5-2-虚函数实现多态"   >
          <a href="#5-2-虚函数实现多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-虚函数实现多态" class="headerlink" title="5.2 虚函数实现多态"></a>5.2 虚函数实现多态</h2>
      <p>虚函数是运行时多态，若某个基类函数声明为虚函数，则其公有派生类将定义与其基类虚函数原型相同的函数，这时，当使用基类指针或基类引用操作派生类对象时，系统会自动用派生类中的同名函数代替基类虚函数。</p>
<ul>
<li>虚函数的声明及类外实现格式</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">访问权限:</span><br><span class="line">  <span class="keyword">virtual</span> 函数类型 函数名(参数列表);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>小例子</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span>&#123;</span>  <span class="comment">//基类 </span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>;  <span class="comment">//基类的虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Enemy&#123; <span class="comment">//共有派生类</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>;  <span class="comment">//因为基类是虚函数，所以这里只能是虚函数，一虚到底</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog dog;</span><br><span class="line">  Enemy* pe = &amp;dog;</span><br><span class="line">  pe-&gt;<span class="built_in">Attack</span>(); <span class="comment">//基类指针</span></span><br><span class="line">  Enemy&amp; re = dog;</span><br><span class="line">  re.<span class="built_in">Attack</span>();  <span class="comment">//基类引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//都会输出&quot;狗咬了你一口&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Enemy::Attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;敌人发起攻击&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::Attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>类比常成员函数、静态成员函数</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">  访问权限:</span><br><span class="line">    函数类型 函数名(参数列表)<span class="keyword">const</span>  <span class="comment">//常成员函数</span></span><br><span class="line">    <span class="keyword">static</span> 函数类型 函数名(参数列表)  <span class="comment">//静态成员函数</span></span><br><span class="line">    <span class="keyword">static</span> 变量类型 变量名; <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="keyword">virtual</span> 函数类型 函数名(参数列表) <span class="comment">//虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">函数类型 类名::函数名(参数列表)<span class="keyword">const</span>&#123;函数体&#125;  <span class="comment">//常成员函数的类外实现</span></span><br><span class="line">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;  <span class="comment">//静态成员函数的类外实现</span></span><br><span class="line">变量类型 类名::变量名 = 初始值;   <span class="comment">//静态成员变量的类外初始化</span></span><br><span class="line">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;  <span class="comment">//虚函数的在外实现</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>重载、隐藏和覆盖的区别</p>
<ul>
<li>重载 <ul>
<li>都是以函数名相同为条件</li>
<li>重载的规则最简单，因为没有跨类，不涉及类型兼容问题</li>
</ul>
</li>
<li>隐藏<ul>
<li>规则相对复杂</li>
<li>参数不同，无论是否是虚函数，基类的函数都将被隐藏；</li>
<li>参数相同，基类不是虚函数，构成隐藏(是虚函数，构成覆盖)</li>
</ul>
</li>
<li>覆盖<ul>
<li>基类与派生类有同名函数，参数相同，并且是虚函数</li>
<li>虚函数的特点是“虚到底”。</li>
<li>在覆盖的情况下，函数的调用取决于对象的类型</li>
</ul>
</li>
</ul>
</li>
<li><p>小总结</p>
<ul>
<li>重载就是重载</li>
<li>隐藏与虚函数无关，出现同名函数的时候，基类的函数会被隐藏，除非使用基类类型指针或引用指向派生类，才有可能调用到被隐藏的函数。</li>
<li>覆盖就是虚函数的隐藏，看最终指向的对象类型是啥就调用啥。</li>
</ul>
</li>
</ul>

        <h3 id="5-2-1-所有敌人发起攻击！"   >
          <a href="#5-2-1-所有敌人发起攻击！" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-1-所有敌人发起攻击！" class="headerlink" title="5.2.1 所有敌人发起攻击！"></a>5.2.1 所有敌人发起攻击！</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;敌人发起了攻击&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Enemy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()&#123;cout&lt;&lt;<span class="string">&quot;来了一只猫&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;猫挠了你一把&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Enemy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()&#123;cout&lt;&lt;<span class="string">&quot;来了一只狗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">//初始化随机数种子</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">4</span>;</span><br><span class="line">  Enemy* allEnemies[size];  <span class="comment">//元素类型 数组名[数组大小]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rand</span>()%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      allEnemies[i]=<span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allEnemies[i]=<span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) <span class="comment">//所有敌人发起攻击</span></span><br><span class="line">      allEnemies[i]-&gt;<span class="built_in">Attack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="5-2-2-数函数实现的机制"   >
          <a href="#5-2-2-数函数实现的机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-2-数函数实现的机制" class="headerlink" title="5.2.2 数函数实现的机制"></a>5.2.2 数函数实现的机制</h3>
      <ul>
<li><p>在编写程序时，我们需要根据函数名、返回值类型、参数列表等信息正确调用函数，这个匹配过程称之为绑定。</p>
</li>
<li><p>C++提供了两种函数绑定机制：静态绑定和动态绑定。</p>
</li>
<li><p>静态多态(重载)实现的机制是静态绑定(静态联编)，它是指在编译时期就能确定调用的函数。</p>
</li>
<li><p>动态多态(覆盖)实现的机制是动态绑定(动态联编)，它是指在运行时才能确定要调用的函数。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Enemy* pe:allEnemies)</span><br><span class="line">  pe-&gt;<span class="built_in">Attack</span>();</span><br></pre></td></tr></table></div></figure></li>
<li><p>虚函数是通过虚函数表vtable实现动态绑定的。</p>
</li>
<li><p>虚函数对应一个指向vtable虚函数表的指针，而这个指向vtable的指针是存储在对象的内存空间的。换言之，必须在对象穿件之后才能访问虚函数，而构造函数就是用来创建对象的，所以构造函数不能是虚函数。</p>
</li>
</ul>

        <h3 id="5-2-3-虚析构函数"   >
          <a href="#5-2-3-虚析构函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-3-虚析构函数" class="headerlink" title="5.2.3 虚析构函数"></a>5.2.3 虚析构函数</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;敌人发起了攻击&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Enemy</span>()&#123;cout&lt;&lt;<span class="string">&quot;释放敌人&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Enemy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()&#123;cout&lt;&lt;<span class="string">&quot;来了一只猫&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;猫挠了你一把&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Enemy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()&#123;cout&lt;&lt;<span class="string">&quot;来了一只狗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">//初始化随机数种子</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">4</span>;</span><br><span class="line">  Enemy* allEnemies[size];  <span class="comment">//元素类型 数组名[数组大小]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rand</span>()%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      allEnemies[i]=<span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allEnemies[i]=<span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) <span class="comment">//所有敌人发起攻击</span></span><br><span class="line">      allEnemies[i]-&gt;<span class="built_in">Attack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">      <span class="keyword">delete</span> allEnemies[i]; <span class="comment">//释放第i个敌人</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样对象会没有被完全释放，这个结果是错误的。正常情况下，首先要调用派生类的析构函数，再调用基类的析构函数。</span></span><br></pre></td></tr></table></div></figure>

<ol>
<li>通过delete释放对象时，会调用析构函数</li>
<li>目前析构函数不是虚函数，所以函数的调用取决于变量的类型</li>
<li>是通过基类指针释放的，所以会调用基类的析构函数，并且不会调用派生类的析构函数。</li>
</ol>
<ul>
<li>为了确保整个对象被完全释放，所以应该声明析构函数为虚析构函数</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~类名();  <span class="comment">//基类声明虚析构函数后，所有派生类的析构函数也自动称为虚析构函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>声明虚析构函数后，在通过基类指针释放派生类对象时，才会按照正常的释放流程，首先调用派生类的析构函数、在调用基类的析构函数，确保对象被正常释放。</li>
<li>建议：即使默认析构函数已经满足功能需求，但是仍然建议习惯性的给基类设置虚析构函数！</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;敌人发起了攻击&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Enemy</span>()&#123;cout&lt;&lt;<span class="string">&quot;释放敌人&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Enemy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()&#123;cout&lt;&lt;<span class="string">&quot;来了一只猫&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;猫挠了你一把&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Cat</span>()&#123;cout&lt;&lt;<span class="string">&quot;释放猫&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//猫虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Enemy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()&#123;cout&lt;&lt;<span class="string">&quot;来了一只狗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Dog</span>()&#123;cout&lt;&lt;<span class="string">&quot;释放狗&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//狗虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">//初始化随机数种子</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">4</span>;</span><br><span class="line">  Enemy* allEnemies[size];  <span class="comment">//元素类型 数组名[数组大小]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rand</span>()%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      allEnemies[i]=<span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allEnemies[i]=<span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) <span class="comment">//所有敌人发起攻击</span></span><br><span class="line">      allEnemies[i]-&gt;<span class="built_in">Attack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">      <span class="keyword">delete</span> allEnemies[i]; <span class="comment">//释放第i个敌人</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="5-3-纯虚函数与抽象类"   >
          <a href="#5-3-纯虚函数与抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-3-纯虚函数与抽象类" class="headerlink" title="5.3 纯虚函数与抽象类"></a>5.3 纯虚函数与抽象类</h2>
      <ul>
<li>基类的虚函数没有什么意义，只需要声明好就行。</li>
<li><code>virtual void Attack() = 0;</code></li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>纯虚函数的作用是在基类中为派生类保留一个结构，方便派生类根据需要实现接口，进而实现多态。</p>
</li>
<li><p>如果一个类中包含纯虚函数，则该类称为抽象类。</p>
<ul>
<li>保留接口</li>
<li>方便派生类实现接口</li>
<li>实现多态</li>
</ul>
</li>
<li><p>抽象类只能用来派生新类，而不能实例化对象</p>
<ul>
<li>可以定义抽象类指针或引用，并且抽象类指针指向派生类对象，这是面向对象编程常用的做法</li>
</ul>
</li>
<li><p>如果派生类没有实现基类的全部接口，则派生类仍然是抽象类</p>
</li>
<li><p>针对接口进行编程</p>
</li>
<li><p>派生类必须实现基类的所有接口才行</p>
</li>
</ul>

        <h2 id="5-4-强制类型转换"   >
          <a href="#5-4-强制类型转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-4-强制类型转换" class="headerlink" title="5.4 强制类型转换"></a>5.4 强制类型转换</h2>
      <ul>
<li>转换构造函数</li>
<li>类型转换函数</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> B&amp;);  <span class="comment">//转换构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span></span>; <span class="comment">//类型转换函数</span></span><br><span class="line">&#125;;<span class="comment">//强调的是如何实现转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="function">A <span class="title">a</span><span class="params">(b)</span></span>;   <span class="comment">//调用转换构造函数</span></span><br><span class="line">  b = (B)a; <span class="comment">//电泳类型转换函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>C语言的强制类型转换简单粗暴，没有任何安全机制</p>
</li>
<li><p>C++提供了四个类型转换运算符，对应不同类型数据之间的转换</p>
<ul>
<li><code>static_cast&lt;type&gt;(expression)</code><ul>
<li>用于代替C语言中通常的转换操作</li>
</ul>
</li>
<li><code>dynamic_cast&lt;type&gt;(expression)</code><ul>
<li>用于类层次间的向上转换和向下转换</li>
</ul>
</li>
<li><code>const_cast&lt;type&gt;(expression)</code><ul>
<li>用于用于去除常引用和常指针的const属性</li>
</ul>
</li>
<li><code>reinterpret_cast&lt;type&gt;(expression)</code><ul>
<li>为操作数的位模式提供底层的重新解释</li>
</ul>
</li>
</ul>
</li>
<li><p><code>static_cast&lt;type&gt;(expression)</code></p>
<ul>
<li>基本数据类型之间的转换<ul>
<li>例：<code>int i = 1;double j = static_cast&lt;double&gt;(i);</code></li>
</ul>
</li>
<li>把任何类型转换成void类型</li>
<li>把空指针转换成目标类型的空指针</li>
<li>向上类型转换是安全的；向下类型转换则不安全。</li>
</ul>
</li>
</ul>
<p>基类指针指向派生类对象</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* pb = <span class="keyword">new</span> Derive;  <span class="comment">//偷懒写法</span></span><br><span class="line">Base* pb = <span class="keyword">static_cast</span>&lt;Base*&gt;(<span class="keyword">new</span> Derive);</span><br></pre></td></tr></table></div></figure>

<ul>
<li><code>dynamic_cast&lt;type&gt;(expression)</code><ul>
<li>主要应用于类层次间的向上转换Upcasting和向下转换Downcasting</li>
<li>只适用于含有虚函数的类型之间的转换</li>
</ul>
</li>
<li>RTTI,Run-time Type Identification, 运行时类型识别<ul>
<li>通过<code>typeid</code>和<code>dynamic_cast</code>两个运算符实现RTTI</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bird</span>(string str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">4</span>;</span><br><span class="line">  Animal* allAnis[size];  <span class="comment">//基类指针数组，父类指针数组指向所有派生类对象</span></span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;-------------初始化-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">  allAnis[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">&quot;黑狗&quot;</span>);</span><br><span class="line">  allAnis[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Bird</span>(<span class="string">&quot;翠鸟&quot;</span>);</span><br><span class="line">  allAnis[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">&quot;白狗&quot;</span>);</span><br><span class="line">  allAnis[<span class="number">3</span>] = <span class="keyword">new</span> <span class="built_in">Bird</span>(<span class="string">&quot;黄鸟&quot;</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;-------------运行中-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">for</span>(Animal* pa:allAnis)&#123;  <span class="comment">//基于范围的循环</span></span><br><span class="line">    pa-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">    pa-&gt;<span class="built_in">Eat</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in"><span class="keyword">typeid</span></span>(*pa)==<span class="built_in"><span class="keyword">typeid</span></span>(Dog))&#123;</span><br><span class="line">      Dog* pd = <span class="keyword">dynamic_cast</span>&lt;Dog*&gt;(pa);</span><br><span class="line">      pd-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in"><span class="keyword">typeid</span></span>(*pa) == <span class="built_in"><span class="keyword">typeid</span></span>(Bird))&#123;</span><br><span class="line">      Bird* pb = <span class="keyword">dynamic_cast</span>&lt;Bird*&gt;(pa);</span><br><span class="line">      pb-&gt;<span class="built_in">Fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="第6单元-异常"   >
          <a href="#第6单元-异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#第6单元-异常" class="headerlink" title="第6单元 异常"></a>第6单元 异常</h1>
      
        <h2 id="6-1-异常处理方式"   >
          <a href="#6-1-异常处理方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1-异常处理方式" class="headerlink" title="6.1 异常处理方式"></a>6.1 异常处理方式</h2>
      <ul>
<li><p>语法错误</p>
<ul>
<li>在编译和连接阶段就能发现、只有100%符合语法规则的代码才能编译通过，属于最容易发现、定位、排除、最不用担心的错误。</li>
</ul>
</li>
<li><p>逻辑错误</p>
<ul>
<li>编写代码的思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决</li>
</ul>
</li>
<li><p>运行时错误</p>
<ul>
<li>在运行期间发生的错误</li>
<li>除数为0、内存分配失败、数组越界、文件不存在等</li>
<li>放任不管的话会发生程序崩溃</li>
</ul>
</li>
<li><p>C++通过<code>try</code>、<code>throw</code>、<code>catch</code>结构实现了异常的检测、抛出和捕获</p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  可能产生异常的语句或函数;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(异常类型<span class="number">1</span>)&#123;处理异常的语句;&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(异常类型<span class="number">2</span>)&#123;处理异常的语句;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...)&#123;处理异常的语句&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>通常情况下，<code>try</code>语句中不包含抛出异常的语句，而是调用的函数如果发生异常，就通过<code>throw</code>关键字抛出异常。函数的上层调用者通过<code>try...catch</code>语句检测、捕获异常，并对异常进行处理。</li>
<li>如果函数调用者也不能处理异常，则异常会即系向上一层调用者传递，直到异常被处理为止。如果最终异常没有被处理，则C++运行系统就会捕捉异常，终止程序运行。</li>
<li>C++的异常处理机制使得异常的引发和处理不必在同一函数中完成，函数的调用者可以在适当的位置对函数排除的异常进行处理。这样，底层的函数可以着重解决具体的业务问题而不必考虑对异常的处理，而整个程序中相同类型的异常可以进行集中处理。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;&quot;</span>)&#123;_s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s)+<span class="number">1</span>];<span class="built_in">strcpy</span>(_s,s);&#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>()&#123;<span class="keyword">delete</span>[] _s;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> MyString&amp; s);</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">      <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index &gt;= <span class="built_in">strlen</span>(_s)) <span class="keyword">throw</span> (<span class="string">&quot;下标越界&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> _s[index];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">str</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt;str &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    str[<span class="number">3</span>]=<span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* s)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;异常:&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>使用<code>try...catch</code>的注意事项<ul>
<li>一个语句中只能有一个try块，但可以有多个catch语句块，以便与不同的异常类型匹配。<code>catch</code>语句必须有参数，如果<code>try</code>语句块中的代码抛出了异常，无论抛出的异常的值是什么，只要异常的类型与<code>catch</code>的参数类型匹配，异常就会被<code>catch</code>语句捕获。最后一个<code>catch</code>语句参数为<code>...</code>符号，表示可以捕获任意类型的异常。</li>
<li>一旦某个<code>catch</code>语句捕获到了异常，后面的<code>catch</code>语句将不再被执行，其用法类似<code>switch...case</code>语句。</li>
<li><code>try</code>和<code>catch</code>语句块中的代码必须使用大括号<code>&#123;&#125;</code>括起来，即使语句块中只有一行代码。</li>
<li><code>try</code>语句和<code>catch</code>语句不能单独使用，必须连起来一起使用。</li>
</ul>
</li>
</ul>

        <h2 id="6-2-栈解旋"   >
          <a href="#6-2-栈解旋" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-栈解旋" class="headerlink" title="6.2 栈解旋"></a>6.2 栈解旋</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="keyword">int</span> nn):<span class="built_in">no</span>(nn)&#123;</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;创建对象&quot;</span>&lt;&lt;no&lt;&lt;<span class="string">&quot;...&quot;</span>&lt;&lt;endl;</span><br><span class="line">      ++cout;</span><br><span class="line">      <span class="keyword">if</span>(cout&gt;<span class="number">2</span>) <span class="keyword">throw</span>(<span class="string">&quot;对象数量达到上限&quot;</span>);</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;创建成功！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Demo</span>()&#123;</span><br><span class="line">      --cout;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;释放对象&quot;</span>&lt;&lt;no&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Demo::cout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Demo <span class="title">x</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="function">Demo <span class="title">y</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Demo <span class="title">z</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* s)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;异常：&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>C++在异常处理前释放所有局部对象。释放的顺序与创建的顺序相反。</li>
<li>但是，栈解旋只能释放栈对象，不能释放堆对象。要在<code>catch</code>中<code>delete</code></li>
</ul>

        <h2 id="6-3-标准异常"   >
          <a href="#6-3-标准异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-3-标准异常" class="headerlink" title="6.3 标准异常"></a>6.3 标准异常</h2>
      <ul>
<li><p>在大多数关于异常的初级文章中，往往会以各种简单类型作为异常类型。</p>
</li>
<li><p>C++<exception>提供了一系列标准异常，它们时以父子类层次结构组织起来的。</p>
</li>
<li><p>C++<exception>提供了一系列标准异常，它们是以父子类层次结构组织的。我们可以：</p>
<ol>
<li>在程序中使用这些标准异常</li>
<li>通过继承和重载<code>exception</code>类来定义新的异常。</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;&quot;</span>)&#123;_s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s)+<span class="number">1</span>];<span class="built_in">strcpy</span>(_s,s);&#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>()&#123;<span class="keyword">delete</span>[] _s;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> MyString&amp; s);</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">      <span class="keyword">if</span>(index&lt;<span class="number">0</span> || idnex &gt;= <span class="built_in">strlen</span>(_s)) <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;下标越界&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> _s[index];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">str</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt;str &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    str[<span class="number">3</span>]=<span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (exception&amp; e)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;异常:&quot;</span>&lt;&lt;e.<span class="built_in">what</span>()&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>异常规范说明的语法：<ul>
<li><code>函数返回值类型函数名(形参表) throw(异常类型1,异常类型2,...);</code></li>
<li><code>函数返回值类型函数名(形参表) throw();</code></li>
</ul>
</li>
<li>C++11有了<code>noexcept</code>，用来不抛出异常</li>
</ul>

        <h2 id="6-4-断言"   >
          <a href="#6-4-断言" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-断言" class="headerlink" title="6.4 断言"></a>6.4 断言</h2>
      <ul>
<li>C++从C语言继承了<code>assert</code>、<code>#error</code>两个方法，用来检查错误的。</li>
<li><code>assert</code>是运行时的断言，它用来发现运行期间的错误，不能提前到编译期发生错误，也不具有强制性，也谈不上改善编译信息的可读性。既然是运行期检查，对性能肯定是有影响的，所以在发型版本中，<code>assert</code>都会被关掉。</li>
<li><code>#error</code>仅仅能在预编译时显示一个错误信息，可以配合<code>#ifdef/ifndef</code>参与预编译的条件检查。由于它无法获得编译信息，当然，也就做不了进一步分析了。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">assert</span>(age &gt; <span class="number">0</span>);</span><br><span class="line">  cout&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>C++11中引入了<code>static_assert</code>这个关键字，用来做编译期间的断言，因此叫做静态断言。语法：</li>
<li>static_assert(常量表达式,”提示字符串”)</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)==<span class="number">8</span>,<span class="string">&quot;64-bit code generation is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>断言还是异常？<ul>
<li>断言表示程序写错了，只要发生断言(准确的说，应该是断言失败)，意味着至少有一个人得修改代码。它的性质如同编译错误。</li>
<li>如果代码书写完全正确，但因外界环境或用户操作仍然可能发生的事件，都不适合用断言，可以使用异常，或者条件判断处理。</li>
</ul>
</li>
</ul>

        <h1 id="第7章-IO流"   >
          <a href="#第7章-IO流" class="heading-link"><i class="fas fa-link"></i></a><a href="#第7章-IO流" class="headerlink" title="第7章 IO流"></a>第7章 IO流</h1>
      
        <h2 id="7-1-IO流类库"   >
          <a href="#7-1-IO流类库" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-IO流类库" class="headerlink" title="7.1 IO流类库"></a>7.1 IO流类库</h2>
      <ul>
<li><p>输入/输出 用于完成数据传输。C++支持两种I/O操作：</p>
<ol>
<li>C语言的I/O函数</li>
<li>另一种是面向对象的I/O流类库。流是对数据从一个对象到另一个对象的传送过程的抽象。</li>
</ol>
</li>
<li><p>在针对文本类型的数据，还可以和插入运算符&lt;&lt;和提取运算符&gt;&gt;配合使用。</p>
</li>
<li><p>C语言的IO解决方案</p>
<ul>
<li>使用<code>scanf()</code>、<code>gets()</code>等函数从键盘读取数据。</li>
<li>使用<code>printf()</code>、<code>puts()</code>等函数向屏幕上输出数据。</li>
<li>使用<code>fscanf()</code>、<code>fgets()</code>等函数读取文件中的数据。</li>
<li>使用<code>fprintf()</code>、<code>fputs()</code>等函数向文件中写入数据。</li>
</ul>
</li>
<li><p>C++的IO解决方案</p>
<ul>
<li>标准IO：cin接收从键盘输入的数据，用cout向屏幕上输出数据</li>
<li>文件IO：通过定义<code>ifstream</code>和<code>ofstream</code>的对象，进行数据的读写操作</li>
<li>字符串流(stringstream)</li>
</ul>
</li>
<li><p>IO流类库的层次结构</p>
<ul>
<li>流类库具有两个独立的基类：streambuf和ios类，所有流类均是其中一个的子类</li>
<li>最常用的三个类：<ul>
<li>iostream，<iostream>控制台的输入、输出</li>
<li>fstream，<fstream>文件的读写</li>
<li>stringstream，<sstream>字符串流的处理</li>
</ul>
</li>
</ul>
</li>
<li><p>streambuf类库</p>
<ul>
<li>streambuf提供了缓冲区操作的接口，它的子类隐藏了大量操作的细节。</li>
<li>stringstream包含了一个它的子类stringstreambuf，以提供字符串的格式化读取和输出操作。</li>
<li>fstream也包含了它的一个子类filebuf，以避免大量的IO操作。</li>
</ul>
</li>
</ul>

        <h2 id="7-2-标准IO流"   >
          <a href="#7-2-标准IO流" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-标准IO流" class="headerlink" title="7.2 标准IO流"></a>7.2 标准IO流</h2>
      <ul>
<li>预定义流对象</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>对象名</th>
<th>所属类</th>
<th>对应设备</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>cin</td>
<td>istream</td>
<td>键盘</td>
<td>标准输入，有缓冲</td>
</tr>
<tr>
<td>cout</td>
<td>ostream</td>
<td>屏幕</td>
<td>标准输出，无缓冲</td>
</tr>
<tr>
<td>cerr</td>
<td>ostream</td>
<td>屏幕</td>
<td>标准错误输出，无缓冲</td>
</tr>
<tr>
<td>clog</td>
<td>ostream</td>
<td>屏幕</td>
<td>标准日志输出，有缓冲</td>
</tr>
</tbody></table></div>
<ul>
<li><p>ostream有19个重载！真他妈的强！</p>
</li>
<li><p>同printf类似，也可以进行格式化输出，例如选择进制、对齐方式、精度等等</p>
</li>
<li><p>除&lt;&lt;之外，还提供了很多成员函数，包括：</p>
<ul>
<li>put，输出字符，例如cout.put(‘A’).put(‘\n’);</li>
<li>write，输出字符串</li>
</ul>
</li>
<li><p>输入流对象cin和提取运算符&gt;&gt;结合使用，可以用于各种类型数据的输入。</p>
</li>
<li><p>以空白(包括空格、Enter、Tab)为分隔符。</p>
</li>
<li><p>流输入运算符的重载</p>
<ul>
<li>除&gt;&gt;之外，还提供了很多成员函数，包括：<ul>
<li>get()函数，用于读取指定长度的字符或者遇到结束标志(可以指定)为止。</li>
<li>getline()函数，用于读取指定长度的字符或者遇到结束标志(可以指定)为止。</li>
<li>read()读取指定字符个数的字符串。</li>
<li>ignore()跳过n个字符。</li>
<li>gcount()统计上次读取的字符个数。</li>
<li>peek()检测输入流中读取的字符。</li>
<li>putback()将上一次读取的字符放回输入流中。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何判断输入结束？</p>
<ul>
<li>在输入数据的多少不确定，且没有结束标志的情况下，该如何判断输入数据已经读完了呢？<ol>
<li>读取文件时，到达文件末尾就读取结束。</li>
<li>在控制台输入特殊的控制字符就表示输入结束。<ul>
<li>在Windows系统中，按<code>Ctrl+Z</code>组合键后再按回车键，代表输入结束。</li>
<li>在UNIX/Linux/Mac OS系统中，<code>Ctrl+D</code>代表输入结束。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>

        <h2 id="7-3-文件流"   >
          <a href="#7-3-文件流" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-文件流" class="headerlink" title="7.3 文件流"></a>7.3 文件流</h2>
      <ul>
<li><p>常见的C++文件操作，包括(但不限于)打开文件、读取和追加数据、插入和删除数据、关闭文件、删除文件等。</p>
</li>
<li><p>为了方便用户实现文件操作，C++提供了3个文件流类</p>
<ul>
<li>ofstream(实现写文件)</li>
<li>ifstream(实现读文件)</li>
<li>fstream(实现读写文件)</li>
<li>均包含在<fstream></li>
</ul>
</li>
<li><p>关于文件操作，虽然在C++程序中可以继续沿用C语言的那套文件操作方式，但更推荐使用适当的文件流类来读写文件。</p>
</li>
<li><p>调用无参构造函数创建文件流对象</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs; <span class="comment">//定义一个文件输入流对象</span></span><br><span class="line">ofstream ofs; <span class="comment">//定义一个文件输出流对象</span></span><br><span class="line">fstream fs;   <span class="comment">//定义一个文件输入、输出流对象</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>调用有参构造函数创建文件流对象</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;filename&quot;</span>,ios::in)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;filename&quot;</span>,ios::out)</span></span>;</span><br><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;filename&quot;</span>,ios::in|ios::out)</span></span>;</span><br><span class="line"><span class="comment">//ifstream类默认文件打开模式为ios::in，ofstream类默认文件打开模式为ios::out，fstream类默认文件打开模式为ios::in|ios::out</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>打开文件</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">int</span> mode)</span></span>;  <span class="comment">//封装的声明</span></span><br><span class="line"></span><br><span class="line">ofstream ofs; <span class="comment">//创建文件流对象</span></span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;Hellp.txt&quot;</span>,ios::in|ios::out|ios::binary);<span class="comment">//多种打开模式组合使用</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>文件打开模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>以只读模式打开文件，若文件不存在，则发生错误</td>
</tr>
<tr>
<td>ios::out</td>
<td>以只写模式打开文件，写入时覆盖写入；若文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td>ios::app</td>
<td>以追加模式打开文件，若文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>打开一个已存在文件，并将文件位置指针移动到文件末尾</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>打开一个文件，将文件内容删除。若文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td>ios::binary</td>
<td>以二进制方式打开文件</td>
</tr>
</tbody></table></div>
<ul>
<li><p>关闭文件</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;Hello.txt&quot;</span>,ios::in);</span><br><span class="line">ifs.<span class="built_in">close</span>();  <span class="comment">//关闭文件</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>文件读写</p>
<ul>
<li>文本文件<ul>
<li><blockquote>
<blockquote>
<p>和&lt;&lt;</p>
</blockquote>
</blockquote>
</li>
<li>文件流类的成员函数</li>
</ul>
</li>
<li>二进制文件<ul>
<li>文件流类的成员函数</li>
</ul>
</li>
</ul>
</li>
<li><p>二进制文件</p>
<ul>
<li>节省空间</li>
<li>方便检索</li>
<li>还可以进行随机读写</li>
</ul>
</li>
<li><p>小例子</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt; intList;  <span class="comment">//整数线性表</span></span><br><span class="line">  ifstream ifs;</span><br><span class="line">  ifs.<span class="built_in">open</span>(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!ifs) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  ofstream ofs;</span><br><span class="line">  ofs.<span class="built_in">open</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!ofs) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//从in.txt中读取数字，编码需要时ANSI编码，是默认的C++编码</span></span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  <span class="keyword">while</span>(ifs&gt;&gt;temp)<span class="comment">//Ctrl+Z</span></span><br><span class="line">  <span class="comment">//while(cin&gt;&gt;temp)</span></span><br><span class="line">    intList.push.<span class="built_in">back</span>(temp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//排序</span></span><br><span class="line">  intList.<span class="built_in">sort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出结果到屏幕</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x:intList)</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//基于范围的for循环</span></span><br><span class="line"></span><br><span class="line">  ifs.<span class="built_in">close</span>();</span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="7-4-字符串流"   >
          <a href="#7-4-字符串流" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-字符串流" class="headerlink" title="7.4 字符串流"></a>7.4 字符串流</h2>
      <ul>
<li>字符串流是以string对象为输入/输出对象的数据流，这些数据流的传输再内存中完成，因此也被称为内存流。<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line">istringstream<span class="comment">//把一个数字字符串转换成对应的数值</span></span><br><span class="line">ostringstream<span class="comment">//构造字符串</span></span><br><span class="line">stringstream</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">stringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;3.1415926&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">  ss &gt;&gt; f;  <span class="comment">//把一个数字字符串转换成对应的数值</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;f=&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  ss.<span class="built_in">clear</span>();</span><br><span class="line">  ss &lt;&lt; <span class="string">&quot;π=&quot;</span> &lt;&lt; f &lt;&lt; endl;  <span class="comment">//构造字符串</span></span><br><span class="line">  string str = ss.<span class="built_in">str</span>();</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h1 id="第8章-模板"   >
          <a href="#第8章-模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#第8章-模板" class="headerlink" title="第8章 模板"></a>第8章 模板</h1>
      
        <h2 id="8-1-模板的概念"   >
          <a href="#8-1-模板的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-1-模板的概念" class="headerlink" title="8.1 模板的概念"></a>8.1 模板的概念</h2>
      <ul>
<li><p>模板是C++支持参数化多态的工具，是<strong>泛型编程</strong>的基础。</p>
</li>
<li><p>模板可以实现<strong>类型参数化</strong>，即把类型定义为参数，真正实现了代码的<strong>可重用性</strong>，减小了编程级维护的工作量，降低了编程难度。</p>
</li>
<li><p>模板分为<strong>函数模板</strong>和<strong>类模板</strong>。</p>
</li>
<li><p>下面三个重载函数</p>
<ul>
<li><code>int max(int a,int b)&#123;return a&gt;b?a:b;&#125;</code></li>
<li><code>float max(float a,float b)&#123;return a&gt;b?a:b;&#125;</code></li>
<li><code>std::string max(std::string a,std::string b)&#123;return a&gt;b?a:b;&#125;</code></li>
</ul>
</li>
<li><p>这三个函数，除了类型不一致，其他都是一模一样的。</p>
</li>
<li><p>C++属于<strong>强类型</strong>的编程语言</p>
<ul>
<li>编译器在程序运行前就要进行类型检查并分配内存。</li>
</ul>
</li>
<li><p>导致程序员为逻辑结构相同而具体数据类型不同的对象编写基本一样的代码。</p>
</li>
<li><p>C++提供了模板机制，可以把类型参数化。带类型参数的函数称为函数模板，带类型参数的类称为类模板。</p>
</li>
<li><p>实例化</p>
<ul>
<li>在运行时，编译器会根据实际的数据类型参数生成一段相应的可执行代码，这个过程称为模板实例化。</li>
</ul>
</li>
</ul>

        <h2 id="8-2-函数模板"   >
          <a href="#8-2-函数模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-函数模板" class="headerlink" title="8.2 函数模板"></a>8.2 函数模板</h2>
      <ul>
<li><p>语法格式</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 [,TYPENAME T2,……]&gt; <span class="comment">//后面没有;</span></span><br><span class="line">返回值类型 函数名(参数列表)&#123;<span class="comment">/**函数体/&#125;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>template(模板)和typename(类型名)都是关键字；</p>
<ul>
<li>早期的C++使用class表示模板参数，但是不能使用struct</li>
</ul>
</li>
<li><p>T1,T2……表示模板参数(类型形参)</p>
<ul>
<li>使用&lt;&gt;括起来，将来在调用函数模板时也需要&lt;&gt;把类型实参括起来</li>
<li>常用的标识符如T、T1、T2、U、V等。</li>
</ul>
</li>
<li><p>在返回值类型、参数列表、函数体中，均可使用模板参数。</p>
</li>
</ul>

        <h3 id="8-2-2-模板的实例化"   >
          <a href="#8-2-2-模板的实例化" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-2-模板的实例化" class="headerlink" title="8.2.2 模板的实例化"></a>8.2.2 模板的实例化</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时将 函数模板 转换为 模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a,T b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;Add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;Add&lt;<span class="keyword">double</span>&gt;(<span class="number">1.2</span>,<span class="number">3.4</span>)&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">1.2f</span>,<span class="number">3.4f</span>)&lt;&lt;endl; <span class="comment">//隐式实例化</span></span><br><span class="line">  cout&lt;&lt;<span class="built_in">Add</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">32</span>)&lt;&lt;endl;  <span class="comment">//这个会报错</span></span><br><span class="line">  cout&lt;&lt;Add&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;A&#x27;</span>,<span class="number">32</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>编译器会根据具体的调用情况，在目标文件中，把函数模板实例化成若干个函数。</li>
<li>通过函数模板，可以定义一系列的函数，这些函数都基于同一份代码，但是可以作用在不同类型的数据上。</li>
</ul>

        <h3 id="8-2-3-函数模板重载"   >
          <a href="#8-2-3-函数模板重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-3-函数模板重载" class="headerlink" title="8.2.3 函数模板重载"></a>8.2.3 函数模板重载</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a,T b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a,T b,T c)</span></span>&#123;<span class="keyword">return</span> a + b + c;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;这是一个非模板函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">1.2</span>,<span class="number">3.4</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>函数模板也可以重载</li>
<li>非模板函数优先于模板函数</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> Complex&amp; c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Complex</span>(<span class="keyword">float</span> xx,<span class="keyword">float</span> yy);</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Comlpex&amp; other)<span class="keyword">const</span>;<span class="comment">//这里得是常函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//T对应的类型实参，必须要支持函数模板中所有的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span>&#123; <span class="comment">//这里是常对象</span></span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;<span class="comment">//常对象只能调用常函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt;<span class="built_in">Max</span>(c1,c2)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="8-3-类模板"   >
          <a href="#8-3-类模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-类模板" class="headerlink" title="8.3 类模板"></a>8.3 类模板</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1[,<span class="keyword">typename</span> T2,……]&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span>……&#125;;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>关键字的含义和函数模板相同。</li>
<li>类模板实例化的过程与函数模板实例化的过程类似，但是模板函数允许隐式实例化，而类模板的实例化不能省略模板的参数。<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span></span>&#123;……;&#125;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//等价于int a = max&lt;int&gt;(1,2);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;Array&#123;……&#125;;</span><br><span class="line">Array&lt;<span class="keyword">int</span>&gt;intArray; <span class="comment">//不能省略模板参数</span></span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="类模板的成员函数的类外实现"   >
          <a href="#类模板的成员函数的类外实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#类模板的成员函数的类外实现" class="headerlink" title="类模板的成员函数的类外实现"></a>类模板的成员函数的类外实现</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  函数类型 函数名(参数列表);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;</span><br><span class="line"><span class="comment">//模板的声明和实现都必须写在.cpp文件中</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>小例子</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Array&lt;T&gt;&amp; a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Array</span>(T a[],<span class="keyword">int</span> size);</span><br><span class="line">  ~<span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* _ptr;  <span class="comment">//用指针指向动态数组</span></span><br><span class="line">  <span class="keyword">int</span> _size;  <span class="comment">//数组的大小</span></span><br><span class="line">&#125;;  <span class="comment">//动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Array&lt;T&gt;&amp; a)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a._size;++i)</span><br><span class="line">    o&lt;&lt;a._ptr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(T a[],<span class="keyword">int</span> size):_size(size)&#123;</span><br><span class="line">  _ptr = <span class="keyword">new</span> T[_size];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;_size;++i)</span><br><span class="line">    _ptr[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::~<span class="built_in">Array</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Array.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">intArr</span><span class="params">(a,<span class="number">6</span>)</span></span>; <span class="comment">//用普通数组初始化Array对象</span></span><br><span class="line">  cout &lt;&lt; intArr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> charA[]=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  <span class="function">Array&lt;<span class="keyword">char</span>&gt; <span class="title">charArr</span><span class="params">(charA,<span class="number">5</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; charArr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Array</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Array&lt;T&gt;&amp; a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;&gt;(ostream&amp; o,<span class="keyword">const</span> Array&lt;T&gt;&amp; a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Array</span>(T a[],<span class="keyword">int</span> size);</span><br><span class="line">  ~<span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* _ptr;  <span class="comment">//用指针指向动态数组</span></span><br><span class="line">  <span class="keyword">int</span> _size;  <span class="comment">//数组的大小</span></span><br><span class="line">&#125;;  <span class="comment">//动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Array&lt;T&gt;&amp; a)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a._size;++i)</span><br><span class="line">    o&lt;&lt;a._ptr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(T a[],<span class="keyword">int</span> size):_size(size)&#123;</span><br><span class="line">  _ptr = <span class="keyword">new</span> T[_size];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;_size;++i)</span><br><span class="line">    _ptr[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::~<span class="built_in">Array</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Array.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">intArr</span><span class="params">(a,<span class="number">6</span>)</span></span>; <span class="comment">//用普通数组初始化Array对象</span></span><br><span class="line">  cout &lt;&lt; intArr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> charA[]=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  <span class="function">Array&lt;<span class="keyword">char</span>&gt; <span class="title">charArr</span><span class="params">(charA,<span class="number">5</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; charArr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="类模板与友元函数"   >
          <a href="#类模板与友元函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#类模板与友元函数" class="headerlink" title="类模板与友元函数"></a>类模板与友元函数</h3>
      <ol>
<li>将普通函数声明为友元函数<ul>
<li>多个全局函数只需要声明一次友元</li>
</ul>
</li>
<li>约束模板友元函数<ul>
<li>在类模板内部声明模板函数为友元</li>
</ul>
</li>
<li>非约束模板友元函数<ul>
<li>在类模板内部声明函数模板为友元</li>
</ul>
</li>
</ol>

        <h3 id="区别"   >
          <a href="#区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#区别" class="headerlink" title="区别"></a>区别</h3>
      <ul>
<li>类模板</li>
<li>模板类</li>
<li>函数模板</li>
<li>模板函数</li>
</ul>
<p>指定了<T>的类型就会具体化成某一个类或函数，也就成为了模板类或模板函数，否则就是一个通用的模板，就称为类模板或函数模板</p>

        <h1 id="第9章-STL"   >
          <a href="#第9章-STL" class="heading-link"><i class="fas fa-link"></i></a><a href="#第9章-STL" class="headerlink" title="第9章 STL"></a>第9章 STL</h1>
      
        <h2 id="9-1-STL组成"   >
          <a href="#9-1-STL组成" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-1-STL组成" class="headerlink" title="9.1 STL组成"></a>9.1 STL组成</h2>
      <ul>
<li>六大组件<ul>
<li>容器Container</li>
<li>迭代器Iterator</li>
<li>算法Algorithm</li>
<li>仿函数Functor</li>
<li>适配器Adapter</li>
<li>分配器Allocator</li>
</ul>
</li>
</ul>

        <h3 id="容器"   >
          <a href="#容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器" class="headerlink" title="容器"></a>容器</h3>
      <p>容器是存储其他类型对象(类类型、简单类型均可)。这些被存储的对象必须是<strong>同一数据类型</strong>，称为容器的<strong>元素</strong>。容器是通过<strong>类模板</strong>实现的，包含了处理这些数据的常见方式。而且，不同的容器的同一个功能，其函数名也是相同的。这大大降低了使用者的学习成本。</p>

        <h3 id="迭代器"   >
          <a href="#迭代器" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3>
      <ul>
<li>重复repeat</li>
<li>迭代iterate</li>
<li>针对容器进行循环遍历时候的一种工具，扮演着容器和算法之间的胶合剂：对容器中数据的读和写，是通过迭代器完成的。</li>
<li>迭代器模式(Iterator)，提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。</li>
<li>数组：下标，链表：指针。迭代器是二者的合体，更像指针。</li>
<li>STL提供了输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器五种类型的迭代器。</li>
</ul>

        <h3 id="算法"   >
          <a href="#算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法" class="headerlink" title="算法"></a>算法</h3>
      <ul>
<li>算法是STL定义的一系列函数模板</li>
<li>STL算法不依赖于容器的实现细节，只要容器的迭代器符合算法要求，算法就可以通过迭代器处理容器中的元素。</li>
</ul>

        <h3 id="仿函数"   >
          <a href="#仿函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3>
      <ul>
<li>仿函数也称为<strong>函数对象</strong>，通过重载()运算符实现，使类具有函数一样的行为。</li>
<li>大多数STL算法可以使用一个仿函数作为参数，以达到某种数据操作的目的，使STL的应用更加灵活方便，增强了算法的通用性。</li>
<li>例如，在排序算法中，可以使用仿函数less或greater作为参数，以实现数据从大到小或从小到大的排序。</li>
</ul>

        <h3 id="适配器"   >
          <a href="#适配器" class="heading-link"><i class="fas fa-link"></i></a><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3>
      <ul>
<li><p>仿函数适配</p>
</li>
<li><p>迭代器适配</p>
</li>
<li><p>容器适配：采用特定的数据管理策略，能够使容器在操作数据时表现出另一种行为。</p>
</li>
<li><p>STL的三个容器适配器</p>
<ul>
<li>stack(栈)</li>
<li>queue(队列)</li>
<li>priority_queue(优先队列)</li>
</ul>
</li>
</ul>

        <h3 id="空间配置器"   >
          <a href="#空间配置器" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h3>
      <ul>
<li>Allocate，分配，C语言中的malloc就是memory allocate的缩写</li>
<li>C++标准库采用了<strong>分配器</strong>实现对象内存空间的分配和释放，封装了容器在内存管理上的低层细节。默认情况下，程序员也可自行定值分配器以替代之</li>
</ul>

        <h2 id="9-2-序列容器"   >
          <a href="#9-2-序列容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-2-序列容器" class="headerlink" title="9.2 序列容器"></a>9.2 序列容器</h2>
      <p>也叫作顺序容器，序列容器各元素之间有顺序关系，每个元素都有固定位置，除非使用插入或删除操作改变这个元素的位置。序列容器是一种<strong>线性结构</strong>的有序群集。序列容器有<strong>连续存储</strong>和<strong>链式存储</strong>两种存储方式。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>容器</th>
<th>基本功能</th>
<th>对应头文件</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>动态数组</td>
<td>#include&lt;vector&gt;</td>
</tr>
<tr>
<td>list</td>
<td>双向链表</td>
<td>#include&lt;list&gt;</td>
</tr>
<tr>
<td>deque</td>
<td>Double-ended queue双端队列</td>
<td>#include&lt;deque&gt;</td>
</tr>
<tr>
<td>array</td>
<td>C++11，大小固定的数组</td>
<td>#include&lt;array&gt;</td>
</tr>
<tr>
<td>forward_list</td>
<td>C++11，单向(向后)链表</td>
<td>#include&lt;forward_list&gt;</td>
</tr>
</tbody></table></div>

        <h3 id="vector向量"   >
          <a href="#vector向量" class="heading-link"><i class="fas fa-link"></i></a><a href="#vector向量" class="headerlink" title="vector向量"></a>vector向量</h3>
      <ul>
<li>动态数组，在插入或删除元素时能够<strong>自动调整自身大小</strong>。元素放置在<strong>连续内存空间</strong>中，可以使用迭代器对其进行访问和遍历。</li>
<li>在<strong>插入/删除</strong>元素时，之后的元素都要被顺序地<strong>向后/向前</strong>移动，因此，vector容器<strong>插入/删除</strong>操作效率并不高。<strong>插入/删除</strong>位置越靠前，执行所需时间就越多，但在vector容器尾部<strong>插入/删除</strong>元素的效率比较高。</li>
</ul>
<p>容器的使用，首先要记住它是一个<strong>类模板</strong>，也就是说在STL的源代码中，应该有以下类似的代码<code>template&lt;typename T&gt;class vector&#123;&#125;;</code></p>
<ol>
<li>创建vector容器<ul>
<li>要指定元素类型，还要匹配构造函数<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//定义一个整数的动态数组，大小未定。</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>)</span></span>;<span class="comment">//定义一个大小为5的字符串数组。</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ol>
<ul>
<li>vector对象在定义后所有元素都会被初始化，如果是基本数据类型的容器，则都会被初始化为0；如果是其他类型容器，则由类的默认构造函数初始化。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;<span class="comment">//定一个整数动态数组，包含10个1.</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//列表初始化。</span></span><br><span class="line">vector&lt;string&gt; v5 = &#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;efg&quot;</span>,<span class="string">&quot;xyz&quot;</span>&#125;;<span class="comment">//有没有=均可。</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v6</span><span class="params">(v4)</span></span>; <span class="comment">//等价于vector&lt;int&gt; v6 = v4；拷贝构造函数</span></span><br><span class="line">vector&lt;Enemy*&gt;allEnemies; <span class="comment">//父类指针数组，所有敌人。</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>容量和个数</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">  cout&lt;&lt;vi.<span class="built_in">capacity</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;vi.<span class="built_in">size</span>()&lt;&lt;endl;  <span class="comment">//0,0</span></span><br><span class="line">  vi.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  cout&lt;&lt;vi.<span class="built_in">capacity</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;vi.<span class="built_in">size</span>()&lt;&lt;endl;  <span class="comment">//1,1</span></span><br><span class="line">  vi.<span class="built_in">pop_back</span>();</span><br><span class="line">  cout&lt;&lt;vi.<span class="built_in">capacity</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;vi.<span class="built_in">size</span>()&lt;&lt;endl;  <span class="comment">//1,0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>访问容器中的元素</p>
<ul>
<li>vector重载了下标运算符[]，用来对元素进行读/写。<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;++i) cout&lt;&lt;vi[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure></li>
<li>同样会有下标越界的问题。</li>
<li>vector还提供了at函数<code>vi.at(1)</code>等价于<code>vi[1];</code></li>
</ul>
</li>
<li><p>获取头部和尾部</p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">cout&lt;&lt;vi.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;vi.<span class="built_in">back</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>从尾部插入和删除元素</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)vi.<span class="built_in">push_back</span>(i+<span class="number">1</span>);  <span class="comment">//尾部插入1……5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:vi)cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//输出：1 2 3 4 5</span></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">vi.<span class="built_in">pop_back</span>();  <span class="comment">//删除尾部的5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:vi)cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//输出：1 2 3 4</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="迭代器的基本概念"   >
          <a href="#迭代器的基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器的基本概念" class="headerlink" title="迭代器的基本概念"></a>迭代器的基本概念</h3>
      <ul>
<li>迭代器：迭代的工具</li>
<li>数据结构<ul>
<li>连续<ul>
<li><code>for(int i=0;i!=size;++i)a[i]……</code></li>
<li><code>for(int *p=a;p!=a+size;++p)*p……</code></li>
</ul>
</li>
<li>不连续<ul>
<li><code>for(Node* p=head;p!=nullptr;p=p-&gt;next)p-&gt;data……</code></li>
</ul>
</li>
</ul>
</li>
<li>STL使用迭代器统一了循环变量和指针，来表示容器中元素的位置，并提供了对外访问的接口。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ::iterator itr; <span class="comment">//不同的容器，迭代器实现的方式不一样。</span></span><br><span class="line"><span class="keyword">for</span>(itr = vi.<span class="built_in">begin</span>();itr!=itr.<span class="built_in">end</span>();++itr)*itr……;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>循环变量或指针<ul>
<li>定义</li>
<li>初始值</li>
<li>结束条件</li>
<li>指向下一个元素</li>
<li>操作元素</li>
</ul>
</li>
</ul>

        <h3 id="迭代器的基本运算"   >
          <a href="#迭代器的基本运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器的基本运算" class="headerlink" title="迭代器的基本运算"></a>迭代器的基本运算</h3>
      <ul>
<li><p>通常，我们把迭代器对象就称之为迭代器。</p>
</li>
<li><p>迭代器可以执行++、–、与整数相加减的操作</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator itr = vi.<span class="built_in">begin</span>();</span><br><span class="line">cout&lt;&lt;*itr++&lt;&lt;endl; <span class="comment">//1</span></span><br><span class="line">cout&lt;&lt;*--itr&lt;&lt;endl; <span class="comment">//1</span></span><br><span class="line">cout&lt;&lt;*(itr+<span class="number">3</span>)&lt;&lt;endl; <span class="comment">//4</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>原因</p>
<ul>
<li>指向数组元素的指针、下标，都能够++、–、与整数相加减。</li>
<li>指向双向链表的指针，可以++、–，但是不能一次性跳过几个结点。</li>
</ul>
</li>
<li><p>vector获取迭代器的函数</p>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>首元素的位置</td>
</tr>
<tr>
<td>end()</td>
<td>最后一个元素的下一个位置</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回容器结束位置作为起始位置的反向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回反向迭代的最后一个元素之后的位置的反向迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>返回容器中起始位置的常量迭代器，不能修改迭代器指向的内容</td>
</tr>
<tr>
<td>cend()</td>
<td>返回迭代器的结束位置的常量迭代器</td>
</tr>
<tr>
<td>crbegin()</td>
<td>返回容器结束位置作为起始位置的迭代器</td>
</tr>
<tr>
<td>crend()</td>
<td>返回第一个元素之前位置的常量迭代器</td>
</tr>
</tbody></table></div>
<ul>
<li>使用迭代器遍历容器<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器类型&lt;元素类型&gt;container;  <span class="comment">//  定义容器container</span></span><br><span class="line">……; <span class="comment">//各种操作，比较常见的是container.push_back(……);</span></span><br><span class="line">容器类型&lt;元素类型&gt;::iterator itr; <span class="comment">//定义**某容器**的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(itr=container.<span class="built_in">begin</span>();itr!=container.<span class="built_in">end</span>();++itr)</span><br><span class="line">  *itr……; <span class="comment">//迭代器重载了取值运算符*，使用*itr表示元素</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)li.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itr = li.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;itr!=li.<span class="built_in">end</span>();++itr)cout&lt;&lt;*itr&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi&#123;<span class="number">21</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">54</span>,<span class="number">25</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator itr = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;itr!=vi.<span class="built_in">end</span>();++itr)cout&lt;&lt;*itr&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=vi.<span class="built_in">size</span>();++i)cout&lt;&lt;vi[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//取出首元素和尾元素</span></span><br><span class="line">cout&lt;&lt;*vi.<span class="built_in">begin</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;*vi.<span class="built_in">end</span>();  <span class="comment">//错误</span></span><br><span class="line">cout&lt;&lt;*vi.<span class="built_in">begin</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;*<span class="built_in">prev</span>(vi.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>());  <span class="comment">//排序</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>vector的赋值函数</p>
<ul>
<li>vector重载了assign()，用于完成赋值操作<ul>
<li>将n个elem赋值给vi，原有数据会被覆盖<ul>
<li><code>vector&lt;int&gt;vi; vi.assign(n,elem);</code></li>
</ul>
</li>
<li>将[begin,end)的元素赋值给容器<ul>
<li><code>vector&lt;int&gt;vi; vi.assign(begin,end);</code></li>
<li><code>int arr[]=&#123;1,2,3,4,5&#125;; vi.assign(arr,arr+3);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在STL的函数语法中，往往用begin和end表示一个区间</p>
</li>
<li><p>[begin,end)指左闭右开区间</p>
</li>
<li><p>指向数组的指针，也可以当做迭代器。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STL中算法的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>]=&#123;……&#125;;</span><br><span class="line">sort&#123;arr,arr+<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></div></figure></li>
<li><p>迭代器的主要功能</p>
<ul>
<li>指定容器中元素的范围<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi&#123;<span class="number">32</span>,<span class="number">23</span>,<span class="number">44</span>,<span class="number">9</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;li;</span><br><span class="line">li.<span class="built_in">assign</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>());  <span class="comment">//li.sort();正确，sort(li.begin(),li.end());错误</span></span><br></pre></td></tr></table></div></figure></li>
<li>遍历容器</li>
<li>对元素进行读写<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt;::letrator itr = li.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;itr!=li.<span class="built_in">end</span>();++itr)*itr*=<span class="number">2</span>;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="list"   >
          <a href="#list" class="heading-link"><i class="fas fa-link"></i></a><a href="#list" class="headerlink" title="list"></a>list</h3>
      <ul>
<li>list容器以双向链表形式实现，list容器通过指针将前面的元素和后边的元素链接到一起</li>
<li>同vector相比，list容器只能通过迭代器访问元素，不能通过索引方式访问元素。</li>
<li>同为序列容器，list容器的接口大部分与vector都相同，所以读者学习起来也比较容易。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建list容器对象</span></span><br><span class="line">list&lt;T&gt;lt;      <span class="comment">//创建空list容器，元素类型为T</span></span><br><span class="line">list&lt;T&gt;<span class="built_in">lt</span>(n);   <span class="comment">//创建list容器，大小为n</span></span><br><span class="line">list&lt;T&gt;<span class="built_in">lt</span>(n,elem);<span class="comment">//包含n个elem</span></span><br><span class="line">list&lt;T&gt;<span class="built_in">lt</span>(begin,end);<span class="comment">//用[begin,end)区间的元素初始化</span></span><br><span class="line">list&lt;T&gt;<span class="built_in">lt</span>(lt1); <span class="comment">//使用lt1进行初始化</span></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">lt.<span class="built_in">assign</span>(n.elem);  <span class="comment">//将n和elem赋值给lt</span></span><br><span class="line">lt.<span class="built_in">assign</span>(begin,end);<span class="comment">//将[begin,end)区间的元素赋值给lt</span></span><br><span class="line"><span class="comment">//元素访问</span></span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;li&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">cout&lt;&lt;li.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;li.<span class="built_in">back</span>()&lt;&lt;endl; <span class="comment">//1,5</span></span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itr = li.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;itr!=li.<span class="built_in">end</span>();++itr)*itr *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(itr=li.<span class="built_in">begin</span>();itr!=li.<span class="built_in">end</span>();++itr) <span class="comment">//2 4 6 8 10</span></span><br><span class="line">  cout&lt;&lt;*itr&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>list容器提供了以下四种迭代器，以及获取这些迭代器的成员函数。<ul>
<li><code>iterator</code>、<code>const_iterator</code>、<code>reverse_iterator</code>、<code>const_reverse_iterator</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">lt.<span class="built_in">push_back</span>(); <span class="comment">//在尾部插入元素</span></span><br><span class="line">lt.<span class="built_in">push_front</span>();  <span class="comment">//在头部插入元素</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos,elem);  <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos,n,elem);  <span class="comment">//在pos位置插入n个元素elem</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos,begin,end); <span class="comment">//在pos位置插入[begin,end)区间的值作为元素</span></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">lt.<span class="built_in">pop_back</span>();  <span class="comment">//从尾部删除元素</span></span><br><span class="line">lt.<span class="built_in">pop_front</span>(); <span class="comment">//从头部删除元素</span></span><br><span class="line">lt.<span class="built_in">erase</span>(pos);  <span class="comment">//从中间删除元素</span></span><br><span class="line">lt.<span class="built_in">erase</span>(begin,end);  <span class="comment">//删除[begin,end)区间的元素</span></span><br><span class="line">lt.<span class="built_in">remove</span>(elem);  <span class="comment">//从容器中删除所有与elem匹配的元素</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>小例子</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; l)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x:l) out &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;lt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) lt.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; lt &lt;&lt; endl; <span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">  lt.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">  cout &lt;&lt; lt &lt;&lt; endl; <span class="comment">//5 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">  lt.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line">  cout &lt;&lt; lt &lt;&lt; endl; <span class="comment">//1 2 3 4 6 7 8 9 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码会生成无效迭代器，类似野指针，会导致程序崩溃</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;lt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)lt.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; lt &lt;&lt; endl; <span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;::iterator itr;</span><br><span class="line">  <span class="keyword">for</span>(itr = lt.<span class="built_in">begin</span>();itr!=lt.<span class="built_in">end</span>();++itr)</span><br><span class="line">    <span class="keyword">if</span>((*itr)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">      lt.<span class="built_in">erase</span>(itr);  <span class="comment">//无效迭代器,会导致崩溃</span></span><br><span class="line">  cout&lt;&lt;lt&lt;&lt;endl; <span class="comment">//1 3 5 7 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决上一个问题的稍微复杂的形式，用了中间变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;lt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) lt.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">  cout&lt;&lt;lt&lt;&lt;endl; <span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;::iterator itr,temp;</span><br><span class="line">  <span class="keyword">for</span>(itr = lt.<span class="built_in">begin</span>();itr!=lt.<span class="built_in">end</span>();<span class="comment">/*++itr*/</span>)</span><br><span class="line">    <span class="keyword">if</span>((*itr)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//temp指向要删除的元素，itr指向下一个</span></span><br><span class="line">      temp = itr++;</span><br><span class="line">      lt.<span class="built_in">erase</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++itr;</span><br><span class="line">    cout&lt;&lt;lt&lt;&lt;endl; <span class="comment">//1 3 5 7 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决上一个问题的标准形式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;lt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) lt.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">  cout&lt;&lt;lt&lt;&lt;endl; <span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;::iterator itr;</span><br><span class="line">  <span class="keyword">for</span>(itr = lt.<span class="built_in">begin</span>();itr!=lt.<span class="built_in">end</span>();<span class="comment">/*++itr*/</span>)</span><br><span class="line">    <span class="keyword">if</span>((*itr)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//temp指向要删除的元素，让itr指向下一个，erase会返回下一个位置</span></span><br><span class="line">      itr = lt.<span class="built_in">erase</span>(itr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++itr;</span><br><span class="line">    cout&lt;&lt;lt&lt;&lt;endl; <span class="comment">//1 3 5 7 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="综合项目（多态、文件、容器）"   >
          <a href="#综合项目（多态、文件、容器）" class="heading-link"><i class="fas fa-link"></i></a><a href="#综合项目（多态、文件、容器）" class="headerlink" title="综合项目（多态、文件、容器）"></a>综合项目（多态、文件、容器）</h3>
      
        <h4 id="文件流和容器"   >
          <a href="#文件流和容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件流和容器" class="headerlink" title="文件流和容器"></a>文件流和容器</h4>
      <ul>
<li>从文件中读入数据放进容器的一般步骤<ol>
<li>打开文件；</li>
<li>while(文件不为空)<ol>
<li>文件对象&gt;&gt;容器;</li>
</ol>
</li>
<li>关闭文件</li>
</ol>
</li>
<li>定义list<int>li;把in.txt中的数据导入li中并遍历输出。</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&gt;&gt;(ifstream&amp; file, list&lt;<span class="keyword">int</span>&gt;&amp; l)&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  file&gt;&gt;temp;</span><br><span class="line">  l.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ifstream ifs;</span><br><span class="line">  ifs.<span class="built_in">open</span>(<span class="string">&quot;in.txt&quot;</span>,ios::in); <span class="comment">//打开文件</span></span><br><span class="line">  <span class="keyword">if</span>(!ifs)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;li;</span><br><span class="line">  <span class="keyword">while</span>(!ifs.<span class="built_in">eof</span>()) <span class="comment">//文件不为空</span></span><br><span class="line">    ifs&gt;&gt;li;  <span class="comment">//文件对象中的数据&gt;&gt;容器</span></span><br><span class="line">  ifs.<span class="built_in">close</span>();  <span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x : li)cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="项目：所有学生"   >
          <a href="#项目：所有学生" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目：所有学生" class="headerlink" title="项目：所有学生"></a>项目：所有学生</h4>
      <ul>
<li>功能需求：<ol>
<li>所有学生Student都有名字name，都要学习Study；</li>
<li>所有同学都要上体育课PE，但是男生打篮球play basketball，女生打排球play volleyball</li>
<li>放学以后，男生打游戏PlayGame，女生去购物Shopping</li>
</ol>
</li>
<li>基本数据来自于student.txt</li>
<li>容器采用list或vector</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&gt;&gt;(istream&amp; in,list&lt;student*&gt;&amp; allStus)&#123;</span><br><span class="line">  string type,name;</span><br><span class="line">  in&gt;&gt;type&gt;&gt;name;</span><br><span class="line">  <span class="keyword">if</span>(type==<span class="string">&quot;男生&quot;</span>)</span><br><span class="line">    allStus.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Boy</span>(name));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    allStus.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Girl</span>(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;Student*&gt; allStudents;</span><br><span class="line">  ifstream ifs;</span><br><span class="line">  ifs.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,ios::in);</span><br><span class="line">  <span class="keyword">if</span>(!ifs) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!ifs.<span class="built_in">eof</span>())</span><br><span class="line">    ifs&gt;&gt;allStudents;</span><br><span class="line">  ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Student* ps:allStudents)&#123;</span><br><span class="line">    ps-&gt;<span class="built_in">Study</span>();</span><br><span class="line">    ps-&gt;<span class="built_in">PE</span>();</span><br><span class="line">    <span class="comment">//RTTI,运行时类型识别</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in"><span class="keyword">typeid</span></span>(*ps)==<span class="built_in"><span class="keyword">typeid</span></span>(Boy))&#123;</span><br><span class="line">      Boy* pb = <span class="keyword">dynamic_cast</span>&lt;Boy*&gt;(ps);<span class="comment">//向下类型转换</span></span><br><span class="line">      pb-&gt;<span class="built_in">PlayGame</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      Girl* pg=<span class="keyword">dynamic_cast</span>&lt;Girl*&gt;(ps);</span><br><span class="line">      pg-&gt;<span class="built_in">Shopping</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Study</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PE</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>:</span><span class="keyword">public</span> Student&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Boy</span>(string str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PE</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlayGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>:</span><span class="keyword">public</span> Student&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>(string name);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PE</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Shopping</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student.cpp</span></span><br><span class="line">Student::<span class="built_in">Student</span>(string str):<span class="built_in">name</span>(str)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::Study</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;name&lt;&lt;<span class="string">&quot;在学习...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Boy::<span class="built_in">Boy</span>(string str):<span class="built_in">Student</span>(str)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Boy::PE</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;name&lt;&lt;<span class="string">&quot;在打篮球...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;name&lt;&lt;<span class="string">&quot;在打游戏...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Girl::<span class="built_in">Girl</span>(string str):<span class="built_in">Student</span>(str)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Girl::PE</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;name&lt;&lt;<span class="string">&quot;在打排球...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Girl::Shopping</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;name&lt;&lt;<span class="string">&quot;在购物...&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="第10章-设计模式"   >
          <a href="#第10章-设计模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#第10章-设计模式" class="headerlink" title="第10章 设计模式"></a>第10章 设计模式</h1>
      
        <h2 id="策略模式"   >
          <a href="#策略模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Strategy.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Strategy</span>(string str);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetMoney</span><span class="params">(<span class="keyword">float</span> price, <span class="keyword">float</span> count)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    string describe;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discount</span> :</span> <span class="keyword">public</span> Strategy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Discount</span>(string str,<span class="keyword">float</span> d);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetMoney</span><span class="params">(<span class="keyword">float</span> price, <span class="keyword">float</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> discount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GiveGoods</span> :</span> <span class="keyword">public</span> Strategy&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GiveGoods</span>(string str,<span class="keyword">float</span> m,<span class="keyword">float</span> give);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetMoney</span><span class="params">(<span class="keyword">float</span> price, <span class="keyword">float</span> count)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> total;</span><br><span class="line">    <span class="keyword">float</span> give;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GiveMoney</span> :</span> <span class="keyword">public</span> Strategy&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Strategy.cpp</span></span><br><span class="line">Strategy::<span class="built_in">Strategy</span>(string str): <span class="built_in">describe</span>(str)&#123;&#125;</span><br><span class="line"><span class="function">Strategy::<span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> describe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Discount::<span class="built_in">Discount</span>(string str,flaot d):<span class="built_in">Strategy</span>(str),<span class="built_in">discount</span>(d)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Discount::GetMoney</span><span class="params">(<span class="keyword">float</span> price, <span class="keyword">float</span> count)</span></span>&#123;<span class="keyword">return</span> discount* price*count;&#125;</span><br><span class="line"></span><br><span class="line">GiveGoods::(string str,<span class="keyword">float</span> m,<span class="keyword">float</span> give): <span class="built_in">Strategy</span>(str),<span class="built_in">total</span>(m+give),<span class="built_in">give</span>(g)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GiveGoods::GetMoney</span><span class="params">(<span class="keyword">float</span> price, <span class="keyword">float</span> count)</span></span>&#123;<span class="keyword">return</span> price * (count - give * (<span class="keyword">int</span>) (count/total));&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Strategy.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="keyword">const</span> Goods&amp; g);</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Goods</span>(string s,<span class="keyword">float</span> p,<span class="keyword">float</span> c,Strategy* ss = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetMoney</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">float</span> count;</span><br><span class="line">    Strategy* s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Strategy* s1 = <span class="keyword">new</span> <span class="built_in">Discount</span>(<span class="string">&quot;打八折&quot;</span>,<span class="number">0.8</span>);</span><br><span class="line">  Strategy* s2 = <span class="keyword">new</span> <span class="built_in">GiveGoods</span>(<span class="string">&quot;买二送一&quot;</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">  list&lt;Goods*&gt; cart;</span><br><span class="line">  cart.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Goods</span>(<span class="string">&quot;铅笔&quot;</span>,<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">  cart.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Goods</span>(<span class="string">&quot;橡皮&quot;</span>,<span class="number">2</span>,<span class="number">5</span>,s1));</span><br><span class="line">  cart.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Goods</span>(<span class="string">&quot;本子&quot;</span>,<span class="number">5</span>,<span class="number">4</span>,s2));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> money = <span class="number">0.0f</span>;</span><br><span class="line">  <span class="keyword">for</span>(Goods* pg:cart)&#123;</span><br><span class="line">    money +=pg-&gt;<span class="built_in">GetMoney</span>();</span><br><span class="line">    cout&lt;&lt;*pg&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;总金额:&quot;</span>&lt;&lt;money&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Goods::<span class="built_in">Goods</span>(string s, <span class="keyword">float</span> p, <span class="keyword">float</span> c,<span class="keyword">float</span> d,Strategy* ss): <span class="built_in">name</span>(s),<span class="built_in">price</span>(p),<span class="built_in">count</span>(c),<span class="built_in">discount</span>(d)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Goods::GetMoney</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s)</span><br><span class="line">    <span class="keyword">return</span> s-&gt;<span class="built_in">GetMoney</span>(price,count);</span><br><span class="line">  <span class="keyword">return</span> price*count;&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="keyword">const</span> Goods&amp; g)&#123;</span><br><span class="line">  out&lt;&lt;g.name&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;g.price&lt;&lt;<span class="string">&quot;*&quot;</span>&lt;&lt;g.count;</span><br><span class="line">  <span class="keyword">if</span>(g.s)</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;(string)(*(g.s))&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;g.<span class="built_in">GetMoney</span>();</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="第11章-复习"   >
          <a href="#第11章-复习" class="heading-link"><i class="fas fa-link"></i></a><a href="#第11章-复习" class="headerlink" title="第11章 复习"></a>第11章 复习</h1>
      
        <h2 id="初识C"   >
          <a href="#初识C" class="heading-link"><i class="fas fa-link"></i></a><a href="#初识C" class="headerlink" title="初识C++"></a>初识C++</h2>
      
        <h3 id="一些基本知识"   >
          <a href="#一些基本知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些基本知识" class="headerlink" title="一些基本知识"></a>一些基本知识</h3>
      <ul>
<li>集成开发环境<ul>
<li>编辑器</li>
<li>编译器</li>
<li>连接器</li>
<li>调试器</li>
</ul>
</li>
<li>程序的运行从main函数开始而开始，结束而结束</li>
<li>编译器是从上到下逐行编译</li>
<li>在语法描述中，[]表示可选的</li>
<li>C++语言集<strong>结构化编程</strong>、<strong>面向对象编程</strong>、<strong>泛型编程</strong>和<strong>函数式编程</strong>于一身，特别适合<strong>大型应用程序</strong>开发。</li>
<li>C++的头文件是不带.h扩展名的</li>
<li>C++的所有关键字都是小写的</li>
<li>C++11，空指针nullstr</li>
</ul>

        <h3 id="new-delete内存管理"   >
          <a href="#new-delete内存管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#new-delete内存管理" class="headerlink" title="new/delete内存管理"></a>new/delete内存管理</h3>
      <ul>
<li>栈：局部变量位于栈中，每个函数每一次运行，都会自动的分配/释放栈；形参(引用类型除外)也是局部变量</li>
<li>堆：每个进程只有一个堆。只能手动分配和释放。只能通过指针指向堆，不能通过变量名使用堆。</li>
<li>new/delete和malloc/free不能混用</li>
<li><code>new[]</code>和<code>new</code>、<code>delete[]</code>和<code>delete</code>是不同的运算符</li>
<li><code>new[]</code>只要用于创建动态数组</li>
</ul>
<p>例如</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[变量];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span>……&#125;;</span><br><span class="line">Demo* pd = <span class="keyword">new</span> Demo[变量];  <span class="comment">//此时调用Demo类的无参构造函数</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//  静态数组的定义和初始化</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="参数默认值"   >
          <a href="#参数默认值" class="heading-link"><i class="fas fa-link"></i></a><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3>
      <ul>
<li>只能按照<strong>从右往左</strong>的顺序给出默认值。</li>
<li>如果既有声明、又有实现，则只需要声明中给出默认值。</li>
<li>特别地，成员函数的类外实现不应该有参数默认值。</li>
</ul>

        <h3 id="重载"   >
          <a href="#重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#重载" class="headerlink" title="重载"></a>重载</h3>
      <ul>
<li>所谓重载函数就是指在<strong>同一作用域内</strong>、<strong>函数名相同</strong>但<strong>参数列表不同</strong>的函数。</li>
<li>目的：使得<strong>代码简洁</strong>。</li>
<li>参数列表不同的含义<ul>
<li>类型不同</li>
<li>个数不同</li>
<li>类型个数都不同</li>
<li>不包括变量名不同</li>
</ul>
</li>
<li>不以函数类型作为重载的依据</li>
<li>当使用具有默认参数的函数重载时，需注意防止调用的<strong>二义性</strong>。</li>
</ul>

        <h3 id="内联函数"   >
          <a href="#内联函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3>
      <p>之前是为了提高效率，后来被编译器替代了，这里老师没讲，就说知道关键字就行了。</p>
<ul>
<li>inline</li>
</ul>

        <h3 id="引用"   >
          <a href="#引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用" class="headerlink" title="引用"></a>引用</h3>
      <ul>
<li>概念：别名。</li>
<li>本质：指针</li>
<li>用途：函数参数、函数返回值（可以让函数作为左值）、成员变量、父类引用指向子类对象。</li>
<li>一个函数内部不会给变量定义相同类型的引用。</li>
</ul>

        <h2 id="类与对象（封装）"   >
          <a href="#类与对象（封装）" class="heading-link"><i class="fas fa-link"></i></a><a href="#类与对象（封装）" class="headerlink" title="类与对象（封装）"></a>类与对象（封装）</h2>
      
        <h3 id="面向对象的三大特征-1"   >
          <a href="#面向对象的三大特征-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象的三大特征-1" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3>
      <ul>
<li>封装，隐藏内部实现</li>
<li>继承，复用现有代码</li>
<li>多态，改写对象行为</li>
</ul>

        <h3 id="成员"   >
          <a href="#成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员" class="headerlink" title="成员"></a>成员</h3>
      <ul>
<li>成员可以是自身类型的指针、自身类型的引用、其他类型的对象（不能循环定义），但不能是自身类型的对象（造成错误的递归）。</li>
<li>三类成员函数<ul>
<li>构造/析构函数</li>
<li>Get/Set函数</li>
<li>其他功性能函数</li>
</ul>
</li>
<li>针对某一个成员变量，往往有一对Set/Get函数。</li>
<li><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> Set <span class="title">XXX</span><span class="params">(类型 形参)</span></span>&#123;</span><br><span class="line">      参数有效性检查；</span><br><span class="line">      XXX = 形参;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    类型 XXX;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure></li>
<li>成员访问运算符<ul>
<li><code>对象.成员变量</code></li>
<li><code>对象.成员函数(参数);</code></li>
<li><code>指针-&gt;成员变量</code></li>
<li><code>指针-&gt;成员函数(参数);  //前提是指针指向对象</code></li>
<li></li>
</ul>
</li>
</ul>

        <h3 id="访问权限"   >
          <a href="#访问权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3>
      <ul>
<li>private<ul>
<li>默认访问权限</li>
<li>个人财产。类内访问，子类、类外均不能访问。</li>
<li>如果没有派生类，则成员变量一般设置为private，然后设置公有的set/get函数。</li>
</ul>
</li>
<li>protected<ul>
<li>家族财产。类内访问，子类可以访问，类外不能访问。</li>
<li>一般基类的成员变量设为protected，方便派生类访问</li>
</ul>
</li>
<li>public<ul>
<li>公共财产。类内、派生类、类外均可访问</li>
</ul>
</li>
<li>C++中的struct<ul>
<li>其默认访问权限是public。</li>
</ul>
</li>
</ul>

        <h3 id="构造函数与析构函数"   >
          <a href="#构造函数与析构函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3>
      <ul>
<li><p>每创建一个对象，就必然要调用一次构造函数。</p>
</li>
<li><p>注意：<code>Demo* pd[4];//指针数组只是定义了四个指针，还没有创建对象</code></p>
</li>
<li><p>作用</p>
<ul>
<li>构造函数用来创建和初始化对象，析构函数用于释放对象</li>
</ul>
</li>
<li><p>四个特点</p>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>构造函数</th>
<th>析构函数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>与类同名</td>
<td>与类同名，前面加~</td>
</tr>
<tr>
<td>2</td>
<td>不能有类型，void、return都不要</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>可以带参数，能够重载</td>
<td>没有参数，不能重载</td>
</tr>
<tr>
<td>4</td>
<td>一般为公有函数</td>
<td>基类一般采用虚析构函数</td>
</tr>
</tbody></table></div>

        <h3 id="无参构造函数"   >
          <a href="#无参构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h3>
      <ul>
<li>默认构造函数，是无参构造函数</li>
<li>这四行代码都调用无参构造函数</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A x;</span><br><span class="line">A* pa = <span class="keyword">new</span> A;</span><br><span class="line">A* pArr = <span class="keyword">new</span> A[size];</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>通过<code>new[]</code>创建对象的动态数组时，只能调用该类的无参构造函数。</p>
</li>
<li><p>通过参数的默认值，也能达到无参构造函数的作用。</p>
</li>
<li><p>默认函数</p>
<ul>
<li>一个空类class Demo{};</li>
<li>如果程序员没有提供构造函数，则编译器会自动提供默认构造函数。</li>
<li>类似的还有：默认析构函数、默认构造函数、默认赋值运算符</li>
<li>默认拷贝构造函数、默认赋值运算符按照“<strong>按位复制</strong>”，如果类中又封装了指针类型的成员变量，则会造成<strong>指针悬挂</strong>。也就是新的对象的指针变量和上一个对象的指针变量指向的可能是同一段内存，这样其中一个指针释放了内存，另一个对象也就用不了了。是一种浅拷贝</li>
</ul>
</li>
</ul>

        <h3 id="常成员函数，不修改对象的数据成员"   >
          <a href="#常成员函数，不修改对象的数据成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#常成员函数，不修改对象的数据成员" class="headerlink" title="常成员函数，不修改对象的数据成员"></a>常成员函数，不修改对象的数据成员</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//常成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Demo::fun</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;……;&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>常对象只能调用常函数</li>
</ul>

        <h3 id="静态成员函数"   >
          <a href="#静态成员函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3>
      <ul>
<li>关键字：static</li>
<li>普通成员函数，编译器会为其加上默认的this指针，但是静态成员函数除外。参数列表中没有默认的this指针</li>
<li>属于类，不属于对象。也就是说，该类的所有对象拥有同一个静态成员。静态成员类似于一个类范围内的全局变量。</li>
<li>既可以通过对象调用，也可以通过类调用<code>类名::静态成员</code></li>
<li>静态成员变量必须类外初始化</li>
<li>典型应用：单例模式</li>
</ul>

        <h3 id="友元friend"   >
          <a href="#友元friend" class="heading-link"><i class="fas fa-link"></i></a><a href="#友元friend" class="headerlink" title="友元friend"></a>友元friend</h3>
      <ul>
<li>友元函数<ul>
<li>声明全局函数为友元，则该函数可以访问<strong>所有</strong>成员变量。</li>
<li>开后门，破坏了封装。</li>
<li>友元函数不是成员函数，和访问权限没有关系。</li>
</ul>
</li>
<li>友元类<ul>
<li>没讲</li>
</ul>
</li>
</ul>

        <h2 id="运算符重载"   >
          <a href="#运算符重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2>
      <ul>
<li>运算符的本质是函数重载<ul>
<li>主要目的是代码简洁，而不是代码复用；</li>
<li>但是不能说运算符就是函数(算数运算是铜鼓CPU的指令直接实现的)。</li>
</ul>
</li>
</ul>

        <h3 id="两种重载形式"   >
          <a href="#两种重载形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#两种重载形式" class="headerlink" title="两种重载形式"></a>两种重载形式</h3>
      <ul>
<li>成员函数</li>
<li>全局函数，**往往(不是必须)**声明为友元。</li>
</ul>

        <h3 id="重载为成员函数"   >
          <a href="#重载为成员函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#重载为成员函数" class="headerlink" title="重载为成员函数"></a>重载为成员函数</h3>
      <ul>
<li>左操作数必须是自身类型</li>
<li>=、)、[]、-&gt;，这四个符号只能重载为成员函数</li>
</ul>

        <h3 id="重载为全局函数"   >
          <a href="#重载为全局函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#重载为全局函数" class="headerlink" title="重载为全局函数"></a>重载为全局函数</h3>
      <ul>
<li>流输出运算符只能重载为全局函数</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; &lt;&lt;(ostream&amp; out, <span class="keyword">const</span> Demo&amp; d);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Demo&amp; d)&#123;</span><br><span class="line">  ……;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>三处引用的作用</p>
<ul>
<li>两处<code>ostream&amp;</code>是为了确保设备的<strong>唯一性</strong>和<strong>连续使用</strong>。</li>
<li>右操作数采用常引用，是为了避免形参到实参拷贝，避免修改实参。</li>
</ul>
</li>
<li><p>流入运算符只能重载为全局函数</p>
</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, 引用类型)<span class="comment">//需要写数据，不能是常引用</span></span><br></pre></td></tr></table></div></figure>


        <h2 id="继承与派生"   >
          <a href="#继承与派生" class="heading-link"><i class="fas fa-link"></i></a><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2>
      <ul>
<li>基类和派生类，父类和子类</li>
<li>C++支持单继承（只有一个基类）和多继承（多个基类）</li>
<li>UML类图中，由派生类指向基类（由下而上）</li>
</ul>

        <h3 id="继承方式"   >
          <a href="#继承方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3>
      <ul>
<li>针对基类的公有和保护成员，继承方式决定其最高访问权限</li>
<li>针对基类的私有和不可访问成员(继承自基类的基类)，都是不可访问成员</li>
<li>默认的继承方式是私有继承，是最常见的继承方式是公有继承。</li>
</ul>

        <h3 id="派生类对象"   >
          <a href="#派生类对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#派生类对象" class="headerlink" title="派生类对象"></a>派生类对象</h3>
      <ul>
<li>派生类对象拥有基类的所有成员(但是不一定能够使用)</li>
<li>构造函数的调用顺序：基类-&gt;成员对象-&gt;派生类</li>
<li>析构函数的调用顺序：派生类-&gt;成员对象-&gt;基类</li>
</ul>

        <h2 id="多态与虚函数"   >
          <a href="#多态与虚函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#多态与虚函数" class="headerlink" title="多态与虚函数"></a>多态与虚函数</h2>
      
        <h3 id="虚函数"   >
          <a href="#虚函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3>
      <ul>
<li>关键字：virtual</li>
<li>实现虚函数的核心数据结构是<strong>虚函数表</strong>。</li>
</ul>

        <h4 id="成员函数，区分三个概念：重载、隐藏、覆盖"   >
          <a href="#成员函数，区分三个概念：重载、隐藏、覆盖" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员函数，区分三个概念：重载、隐藏、覆盖" class="headerlink" title="成员函数，区分三个概念：重载、隐藏、覆盖"></a>成员函数，区分三个概念：重载、隐藏、覆盖</h4>
      <ul>
<li>同一类中：重载</li>
<li>分别在基类、派生类中<ul>
<li>同时满足<ol>
<li>原型相同</li>
<li>virtual，即为覆盖</li>
</ol>
</li>
<li>否则（两个条件有一个不满足），即为隐藏</li>
</ul>
</li>
</ul>

        <h4 id="同名函数的调用原则"   >
          <a href="#同名函数的调用原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#同名函数的调用原则" class="headerlink" title="同名函数的调用原则"></a>同名函数的调用原则</h4>
      <ul>
<li>在<strong>隐藏</strong>的情况下，通过指针调用函数，取决于左侧变量的类型</li>
<li>在<strong>覆盖</strong>的情况下，通过指针调用函数，取决于对象的类型</li>
</ul>

        <h3 id="多态的概念"   >
          <a href="#多态的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3>
      <p>多态是一种：调用<strong>同名函数</strong>却因<strong>上下文不同</strong>会有<strong>不同实现</strong>的一种机制。</p>
<p>多态是指：<strong>不同的对象</strong>调用<strong>同名函数</strong>，会有<strong>不同的实现</strong>。</p>
<ul>
<li><strong>静态多态</strong>，通过<strong>重载</strong>在<strong>编译阶段</strong>完成</li>
<li><strong>动态多态</strong>，通过<strong>继承和虚函数</strong>在<strong>运行阶段</strong>完成。</li>
</ul>

        <h3 id="纯虚函数与抽象类"   >
          <a href="#纯虚函数与抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3>
      <ul>
<li>虚函数没有函数体(=0)称之为纯虚函数</li>
<li>拥有纯虚函数的类，称之为抽象类</li>
<li>抽象类不能实例化对象</li>
</ul>

        <h3 id="RTTI，运行时类型识别"   >
          <a href="#RTTI，运行时类型识别" class="heading-link"><i class="fas fa-link"></i></a><a href="#RTTI，运行时类型识别" class="headerlink" title="RTTI，运行时类型识别"></a>RTTI，运行时类型识别</h3>
      <ul>
<li>typeid</li>
<li>dynamic_cast&lt;目标类型&gt;(表达式);</li>
</ul>

        <h2 id="异常处理"   >
          <a href="#异常处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2>
      <ul>
<li>try…catch…throw</li>
<li>throw用于(通常在子函数中)<strong>抛出</strong>异常</li>
<li>try用于<strong>检测</strong>异常，把可能出现异常的语句放在try块中(只能有一个)</li>
<li>多个catch块依次对异常按照<strong>类型</strong>进行匹配，用于<strong>捕获</strong>并<strong>处理</strong>异常。</li>
</ul>

        <h2 id="IO流"   >
          <a href="#IO流" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2>
      
        <h3 id="四个预定义流对象"   >
          <a href="#四个预定义流对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#四个预定义流对象" class="headerlink" title="四个预定义流对象"></a>四个预定义流对象</h3>
      <ul>
<li>包括cin、cout、cerr和clog</li>
<li><code>&gt;&gt;</code>提取运算符、<code>&lt;&lt;</code>插入运算符</li>
</ul>

        <h3 id="文件读写"   >
          <a href="#文件读写" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3>
      <ul>
<li>文本文件，既可以通过&gt;&gt;、&lt;&lt;进行读写，也可以通过成员函数进行读写。</li>
<li>二进制文件，只能通过成员函数进行读写。</li>
</ul>
<p>典型应用，把文本文件中的数据读入到某一个STL的容器中。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, 容器引用)&#123;...;<span class="keyword">return</span> in&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">  ifstream ifs;</span><br><span class="line">  ifs.<span class="built_in">open</span>(<span class="string">&quot;文件名&quot;</span>,ios::in);</span><br><span class="line">  <span class="keyword">if</span>(!ifs)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span>(!ifs.<span class="built_in">eof</span>()) ifs&gt;&gt;容器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="模板编程"   >
          <a href="#模板编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h2>
      <ul>
<li>模板编程也称为泛型编程。</li>
<li>模板编程的主要目的是代码复用</li>
</ul>

        <h3 id="函数模板实例化为函数"   >
          <a href="#函数模板实例化为函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数模板实例化为函数" class="headerlink" title="函数模板实例化为函数"></a>函数模板实例化为函数</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temple&lt;<span class="keyword">typename</span>&gt;T</span><br></pre></td></tr></table></div></figure>


        <h3 id="类模板实例化为类"   >
          <a href="#类模板实例化为类" class="heading-link"><i class="fas fa-link"></i></a><a href="#类模板实例化为类" class="headerlink" title="类模板实例化为类"></a>类模板实例化为类</h3>
      <p>必须显式实例化</p>

        <h2 id="STL"   >
          <a href="#STL" class="heading-link"><i class="fas fa-link"></i></a><a href="#STL" class="headerlink" title="STL"></a>STL</h2>
      
        <h3 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>
      <ul>
<li>Standard Template Library，标准模板库</li>
<li>三大核心组件：容器、迭代器、算法</li>
<li>六大组件，再加上：适配器、仿函数（函数对象）、分配器</li>
<li>内部实现</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">模板</th>
<th align="center">结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vector</td>
<td align="center">动态数组</td>
</tr>
<tr>
<td align="center">list</td>
<td align="center">双向链表</td>
</tr>
<tr>
<td align="center">map</td>
<td align="center">红黑树</td>
</tr>
</tbody></table></div>

        <h3 id="vector"   >
          <a href="#vector" class="heading-link"><i class="fas fa-link"></i></a><a href="#vector" class="headerlink" title="vector"></a>vector</h3>
      <ul>
<li>遍历vector的方法：迭代器、下标、基于范围的for循环、for each函数</li>
<li>连续的动态数组，可以在尾部快速插入和删除</li>
</ul>

        <h3 id="list-1"   >
          <a href="#list-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#list-1" class="headerlink" title="list"></a>list</h3>
      <ul>
<li>遍历list的方法：迭代器、基于范围的for循环、for each函数</li>
<li>双向链表，可以在任意位置插入和删除</li>
</ul>

        <h3 id="迭代器-1"   >
          <a href="#迭代器-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3>
      <ul>
<li>定义迭代器时，必须要指定容器类型和元素类型</li>
<li>在调用一些特殊的迭代器时，需要包含<iterator>。比如说，插入迭代器、IO流迭代器</li>
</ul>

        <h3 id="算法-1"   >
          <a href="#算法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3>
      <ul>
<li>需要包含<algorithm></li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;li;  <span class="comment">//整数链表</span></span><br><span class="line">  <span class="comment">//不使用循环。而是通过STL::algorithm实现插入10个随机数，遍历输出</span></span><br><span class="line">  <span class="built_in">generate_n</span>(<span class="built_in">back_inserter</span>(li),</span><br><span class="line">  <span class="number">10</span>,</span><br><span class="line">  []()&#123;<span class="keyword">return</span> <span class="built_in">rand</span>()%<span class="number">100</span>;&#125;<span class="comment">//0~99的随机数</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">copy</span>(li.<span class="built_in">begin</span>(),li.<span class="built_in">end</span>(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(cout,<span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="设计模式"   >
          <a href="#设计模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2>
      
        <h3 id="面对对象程序设计的思想"   >
          <a href="#面对对象程序设计的思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#面对对象程序设计的思想" class="headerlink" title="面对对象程序设计的思想"></a>面对对象程序设计的思想</h3>
      <p>应用程序是对现实“花花世界”的仿真，主要特征是：种类很多、数量很多。</p>
<ul>
<li><p>在软件开发过程中唯一不变的是<strong>变化</strong></p>
</li>
<li><p>在基类指针指向派生类对象时，基类指针代表<strong>抽象</strong>和<strong>稳定</strong>的，派生类对象代表<strong>具体</strong>和<strong>变化</strong>的。只有针对稳定的抽象进行编程，才能达到“以不变应万变”的效果。</p>
</li>
<li><p>三大设计原则：</p>
<ol>
<li>封装变化点</li>
<li>针对抽象进行编程</li>
<li>优先使用组合</li>
</ol>
<ul>
<li>继承被称为“is-a”关系，组合被称为“has-a”关系</li>
<li>继承和组合均能实现代码复用，优先使用组合。</li>
<li>针对抽象（稳定）的接口进行编程，才能做到以不变应万变。</li>
</ul>
</li>
<li><p>开闭原则：对扩展开放，对修改关闭。（五大设计原则之一）</p>
</li>
</ul>

        <h3 id="基本概念-1"   >
          <a href="#基本概念-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3>
      <ul>
<li>最早提出这个概念的人是，建筑设计领域的亚历山大·克里斯托弗</li>
<li>三种设计模式：创造型模式（如：单例模式）、行为型模式（如：策略模式）、结构型模式。</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://blog.gddfeng.com">gddFeng</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://blog.gddfeng.com/notebooks-c/">http://blog.gddfeng.com/notebooks-c/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blog.gddfeng.com/tags/c/">C++</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blog.gddfeng.com/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">课堂笔记</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/notebooks-%E5%88%9B%E4%B8%9A%E8%80%85%E7%9A%84%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E7%AC%94%E8%AE%B0/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">创业者的成长之路笔记</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/notebooks-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"><span class="paginator-prev__text">数据库原理与应用随堂笔记</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E5%8D%95%E5%85%83-%E5%88%9D%E8%AF%86C"><span class="toc-number">1.</span> <span class="toc-text">
          第1单元 初识C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-C-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">
          1.1 C++简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-C-%E7%9A%84%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          1.1.1 C++的发展简史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-1-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">
          1.1.1.1 课程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A6%E7%B1%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">
          书籍介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-2-%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">
          1.1.1.2 编程环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-3-C-%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">
          1.1.1.3 C++发展史</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84C-%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">
          重要的C++版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">
          C++的主要用途</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-C-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          1.1.2 C++的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-1%E6%94%AF%E6%8C%81%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">
          1.1.2.1支持四种编程范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-2-%E9%80%82%E5%90%88%E7%BC%96%E5%86%99%E5%A4%A7%E5%9E%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">
          1.1.2.2 适合编写大型应用程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-3-%E5%8F%AF%E5%A4%8D%E7%94%A8%E3%80%81%E5%8F%AF%E6%89%A9%E5%85%85%E3%80%81%E5%8F%AF%E7%BB%B4%E6%8A%A4%E5%92%8C%E7%81%B5%E6%B4%BB%E6%80%A7%E5%A5%BD"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">
          1.1.2.3 可复用、可扩充、可维护和灵活性好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-4-C-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">
          1.1.2.4 C++的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%AC%AC%E4%B8%80%E4%B8%AAC-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">
          1.2 第一个C++程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-Hello-World"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          1.2.1 Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-1-C-%E4%B8%8EC%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">
          1.2.1.1 C++与C的不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-C-%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%A9%E5%85%85"><span class="toc-number">1.3.</span> <span class="toc-text">
          1.3 C++对C语言的扩充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          1.3.1 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">
          1.3.1.1 命名空间简写方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          1.3.2  控制台输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84I-O%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">
          C++的I&#x2F;O解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E2%80%9C%E6%B5%81%E7%B1%BB%E2%80%9D"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">
          C++标准库中包含了“流类”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">
          输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">
          输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">
          小例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%A2%9E%E5%BC%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          1.3.3 增强类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-1-const%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">
          1.3.3.1 const的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-2-const%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">
          1.3.3.2 const与指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          1.3.3 布尔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.3.5.</span> <span class="toc-text">
          1.3.4 参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-5-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.3.6.</span> <span class="toc-text">
          1.3.5 函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-6-%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">
          1.3.6 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-1-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">
          1.3.6.1 引用的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">
          1.3.6.2 函数参数的三种形式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BC%A0%E5%80%BC"><span class="toc-number">1.3.7.2.1.</span> <span class="toc-text">
          1. 传值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BC%A0%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.7.2.2.</span> <span class="toc-text">
          2. 传地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.7.2.3.</span> <span class="toc-text">
          3. 传引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-3-%E5%BC%95%E7%94%A8%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">
          1.3.6.3 引用——函数的返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-4-%E5%BC%95%E7%94%A8%E2%80%94%E2%80%94%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">
          1.3.6.4 引用——常引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E6%A0%88"><span class="toc-number">1.3.8.</span> <span class="toc-text">
          1.3.7 内存管理——堆、栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-8-new-delete"><span class="toc-number">1.3.9.</span> <span class="toc-text">
          1.3.8 new&#x2F;delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-8-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.10.</span> <span class="toc-text">
          1.3.8 静态数组、动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-9-%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.11.</span> <span class="toc-text">
          1.3.9 各种指针和指针数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88"><span class="toc-number">1.3.11.1.</span> <span class="toc-text">
          各种指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-C-%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">
          1.4 C++中的两个新语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-nullptr%E2%80%94%E2%80%94%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          1.4.1 nullptr——野指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          1.4.2 基于范围的for循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E5%8D%95%E5%85%83-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">
          第2单元 类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.</span> <span class="toc-text">
          2.1 面向对象程序设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.1.</span> <span class="toc-text">
          2.1.1 面向对象的编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">
          面向过程程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">
          面向对象程序设计思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">
          概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">
          2.1.2 面向对象的三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">
          面向对象的三大特征</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%88%9D%E5%A7%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">
          2.2 初始类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          2.2.1 类的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">
          类的语法格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">
          2.2.2 类外定义成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E6%AC%A1%E4%B8%8A%E8%AF%BE"><span class="toc-number">3.</span> <span class="toc-text">
          第2次上课</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E8%AF%BE"><span class="toc-number">4.</span> <span class="toc-text">
          网课</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">
          2.2.3 对象的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBstring%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">
          字符串类string的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B0%81%E8%A3%85"><span class="toc-number">4.1.</span> <span class="toc-text">
          2.3 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-this%E6%8C%87%E9%92%88"><span class="toc-number">4.2.</span> <span class="toc-text">
          2.4 this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">
          2.5 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">
          2.5.1 自定义构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">
          自定义有参构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E9%87%8D%E8%BD%BD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">
          2.5.2 重载构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E5%90%AB%E6%9C%89%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.3.</span> <span class="toc-text">
          2.5.3 含有成员对象的类的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.4.</span> <span class="toc-text">
          2.5.4 三角形项目的分析与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">
          分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">
          设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.5.</span> <span class="toc-text">
          2.5.5 三角形项目的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">4.3.6.</span> <span class="toc-text">
          2.5.6 三角形项目的调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">
          2.6 析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text">
          2.6.1 指针类型的成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">
          2.6.2 正确处理指针类型的成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">
          2.7 拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">
          2.7.1 拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">
          函数调用中的拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.5.2.</span> <span class="toc-text">
          2.7.2 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.5.3.</span> <span class="toc-text">
          2.7.3 深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E5%89%A7%E9%80%8F%EF%BC%9A%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">
          提前剧透：赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E7%A9%BA%E2%80%9D%E7%B1%BB%E7%9A%84%E4%BA%94%E4%B8%AA%E9%BB%98%E8%AE%A4"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">
          “空”类的五个默认</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">4.6.</span> <span class="toc-text">
          2.8 关键字修饰类的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-%E5%B8%B8%E6%88%90%E5%91%98"><span class="toc-number">4.6.1.</span> <span class="toc-text">
          2.8.1 常成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">
          常成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">
          常成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-2-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.6.2.</span> <span class="toc-text">
          2.8.2 静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.3.</span> <span class="toc-text">
          2.8.3 单例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E5%8F%8B%E5%85%83"><span class="toc-number">4.7.</span> <span class="toc-text">
          2.9 友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%86%85%E8%81%9A%E3%80%81%E4%BD%8E%E8%80%A6%E5%90%88"><span class="toc-number">4.7.1.</span> <span class="toc-text">
          高内聚、低耦合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.</span> <span class="toc-text">
          2.10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E5%8D%95%E5%85%83-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">
          第3单元 运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">
          3.1 运算符重载概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">
          3.1.1 运算符重载的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">
          运算符重载的规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">
          3.1.3 运算符重载的形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">
          重载为类的成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">
          3.1.4 重载为全局函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.</span> <span class="toc-text">
          3.2 常用运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.1.</span> <span class="toc-text">
          3.2.1 输入输出运算符的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.2.</span> <span class="toc-text">
          3.2.2 关系运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.3.</span> <span class="toc-text">
          3.2.3 重载赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.4.</span> <span class="toc-text">
          3.2.4 下标运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-MyString"><span class="toc-number">5.2.5.</span> <span class="toc-text">
          3.2.6 MyString</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">
          3.3 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">
          3.3.1 转换构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-1-%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.2.</span> <span class="toc-text">
          3.3.2.1 转换构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-2-%E8%BF%94%E5%9B%9E%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.3.3.</span> <span class="toc-text">
          3.3.2.2 返回匿名对象、返回引用、转换构造函数、运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.4.</span> <span class="toc-text">
          3.3.3 类型转换函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BB%BF%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">
          3.4 仿函数——重载()运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E5%8D%95%E5%85%83-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F"><span class="toc-number">6.</span> <span class="toc-text">
          第4单元 继承与派生</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.</span> <span class="toc-text">
          4.1 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">
          4.1.1 继承的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animal-Project%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.1.2.</span> <span class="toc-text">
          Animal Project实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">
          4.1.2 继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9"><span class="toc-number">6.1.4.</span> <span class="toc-text">
          4.1.3 类型兼容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.5.</span> <span class="toc-text">
          4.1.4 父类指针指向子类对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">
          4.2 派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.1.</span> <span class="toc-text">
          4.2.1 派生类的构造函数与析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E9%9A%90%E8%97%8F%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">
          4.2.2 在派生类中隐藏基类成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.</span> <span class="toc-text">
          4.3 多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">6.4.</span> <span class="toc-text">
          4.4 虚继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">
          第5章 多态与虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.</span> <span class="toc-text">
          5.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="toc-number">7.2.</span> <span class="toc-text">
          5.2 虚函数实现多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E6%89%80%E6%9C%89%E6%95%8C%E4%BA%BA%E5%8F%91%E8%B5%B7%E6%94%BB%E5%87%BB%EF%BC%81"><span class="toc-number">7.2.1.</span> <span class="toc-text">
          5.2.1 所有敌人发起攻击！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E6%95%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.2.</span> <span class="toc-text">
          5.2.2 数函数实现的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.3.</span> <span class="toc-text">
          5.2.3 虚析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">
          5.3 纯虚函数与抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.4.</span> <span class="toc-text">
          5.4 强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E5%8D%95%E5%85%83-%E5%BC%82%E5%B8%B8"><span class="toc-number">8.</span> <span class="toc-text">
          第6单元 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">
          6.1 异常处理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%A0%88%E8%A7%A3%E6%97%8B"><span class="toc-number">8.2.</span> <span class="toc-text">
          6.2 栈解旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">8.3.</span> <span class="toc-text">
          6.3 标准异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E6%96%AD%E8%A8%80"><span class="toc-number">8.4.</span> <span class="toc-text">
          6.4 断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-IO%E6%B5%81"><span class="toc-number">9.</span> <span class="toc-text">
          第7章 IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-IO%E6%B5%81%E7%B1%BB%E5%BA%93"><span class="toc-number">9.1.</span> <span class="toc-text">
          7.1 IO流类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%A0%87%E5%87%86IO%E6%B5%81"><span class="toc-number">9.2.</span> <span class="toc-text">
          7.2 标准IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">9.3.</span> <span class="toc-text">
          7.3 文件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81"><span class="toc-number">9.4.</span> <span class="toc-text">
          7.4 字符串流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.</span> <span class="toc-text">
          第8章 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">
          8.1 模板的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.2.</span> <span class="toc-text">
          8.2 函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">10.2.1.</span> <span class="toc-text">
          8.2.2 模板的实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%87%8D%E8%BD%BD"><span class="toc-number">10.2.2.</span> <span class="toc-text">
          8.2.3 函数模板重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.3.</span> <span class="toc-text">
          8.3 类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">
          类模板的成员函数的类外实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.2.</span> <span class="toc-text">
          类模板与友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">10.3.3.</span> <span class="toc-text">
          区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-STL"><span class="toc-number">11.</span> <span class="toc-text">
          第9章 STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-STL%E7%BB%84%E6%88%90"><span class="toc-number">11.1.</span> <span class="toc-text">
          9.1 STL组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">11.1.1.</span> <span class="toc-text">
          容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.1.2.</span> <span class="toc-text">
          迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">11.1.3.</span> <span class="toc-text">
          算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.4.</span> <span class="toc-text">
          仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">11.1.5.</span> <span class="toc-text">
          适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-number">11.1.6.</span> <span class="toc-text">
          空间配置器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8"><span class="toc-number">11.2.</span> <span class="toc-text">
          9.2 序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%90%91%E9%87%8F"><span class="toc-number">11.2.1.</span> <span class="toc-text">
          vector向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.2.2.</span> <span class="toc-text">
          迭代器的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-number">11.2.3.</span> <span class="toc-text">
          迭代器的基本运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">11.2.4.</span> <span class="toc-text">
          list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%A4%9A%E6%80%81%E3%80%81%E6%96%87%E4%BB%B6%E3%80%81%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-number">11.2.5.</span> <span class="toc-text">
          综合项目（多态、文件、容器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">11.2.5.1.</span> <span class="toc-text">
          文件流和容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%89%80%E6%9C%89%E5%AD%A6%E7%94%9F"><span class="toc-number">11.2.5.2.</span> <span class="toc-text">
          项目：所有学生</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">
          第10章 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.1.</span> <span class="toc-text">
          策略模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%A4%8D%E4%B9%A0"><span class="toc-number">13.</span> <span class="toc-text">
          第11章 复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86C"><span class="toc-number">13.1.</span> <span class="toc-text">
          初识C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">13.1.1.</span> <span class="toc-text">
          一些基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-delete%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">13.1.2.</span> <span class="toc-text">
          new&#x2F;delete内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">13.1.3.</span> <span class="toc-text">
          参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">13.1.4.</span> <span class="toc-text">
          重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.5.</span> <span class="toc-text">
          内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">13.1.6.</span> <span class="toc-text">
          引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%B0%81%E8%A3%85%EF%BC%89"><span class="toc-number">13.2.</span> <span class="toc-text">
          类与对象（封装）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81-1"><span class="toc-number">13.2.1.</span> <span class="toc-text">
          面向对象的三大特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">13.2.2.</span> <span class="toc-text">
          成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">13.2.3.</span> <span class="toc-text">
          访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.4.</span> <span class="toc-text">
          构造函数与析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.5.</span> <span class="toc-text">
          无参构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8D%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">13.2.6.</span> <span class="toc-text">
          常成员函数，不修改对象的数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.7.</span> <span class="toc-text">
          静态成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83friend"><span class="toc-number">13.2.8.</span> <span class="toc-text">
          友元friend</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">13.3.</span> <span class="toc-text">
          运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%87%8D%E8%BD%BD%E5%BD%A2%E5%BC%8F"><span class="toc-number">13.3.1.</span> <span class="toc-text">
          两种重载形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.2.</span> <span class="toc-text">
          重载为成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.3.</span> <span class="toc-text">
          重载为全局函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F"><span class="toc-number">13.4.</span> <span class="toc-text">
          继承与派生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">13.4.1.</span> <span class="toc-text">
          继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.4.2.</span> <span class="toc-text">
          派生类对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">13.5.</span> <span class="toc-text">
          多态与虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">13.5.1.</span> <span class="toc-text">
          虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8C%BA%E5%88%86%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%9A%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E3%80%81%E8%A6%86%E7%9B%96"><span class="toc-number">13.5.1.1.</span> <span class="toc-text">
          成员函数，区分三个概念：重载、隐藏、覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">13.5.1.2.</span> <span class="toc-text">
          同名函数的调用原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">13.5.2.</span> <span class="toc-text">
          多态的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">13.5.3.</span> <span class="toc-text">
          纯虚函数与抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTTI%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">13.5.4.</span> <span class="toc-text">
          RTTI，运行时类型识别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">13.6.</span> <span class="toc-text">
          异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">13.7.</span> <span class="toc-text">
          IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E9%A2%84%E5%AE%9A%E4%B9%89%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.7.1.</span> <span class="toc-text">
          四个预定义流对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">13.7.2.</span> <span class="toc-text">
          文件读写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B"><span class="toc-number">13.8.</span> <span class="toc-text">
          模板编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%BA%E5%87%BD%E6%95%B0"><span class="toc-number">13.8.1.</span> <span class="toc-text">
          函数模板实例化为函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%BA%E7%B1%BB"><span class="toc-number">13.8.2.</span> <span class="toc-text">
          类模板实例化为类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">13.9.</span> <span class="toc-text">
          STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">13.9.1.</span> <span class="toc-text">
          基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">13.9.2.</span> <span class="toc-text">
          vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-1"><span class="toc-number">13.9.3.</span> <span class="toc-text">
          list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-number">13.9.4.</span> <span class="toc-text">
          迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-1"><span class="toc-number">13.9.5.</span> <span class="toc-text">
          算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.10.</span> <span class="toc-text">
          设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">13.10.1.</span> <span class="toc-text">
          面对对象程序设计的思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">13.10.2.</span> <span class="toc-text">
          基本概念</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">gddFeng</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2418180738&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>gddFeng All Rights Reserved</span><span class="footer__devider">|</span><span>冀2021001072号</span></div><div>有英勇也有温柔。</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>