[{"title":"Tracert出现了timeout为什么还能正常通信？","url":"/Computer-Networks-tracert%E5%87%BA%E7%8E%B0%E4%BA%86timeout%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%83%BD%E6%AD%A3%E5%B8%B8%E9%80%9A%E4%BF%A1%EF%BC%9F/","content":"\n        <h1 id=\"前言\"   >\n          <a href=\"#前言\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1>\n      <p>学计算机网络的时候，有一个tracert命令，进行跟踪路由的时候出现了大量timeout！这个时候就有个问题，如果通路不可达的话，那么正常通信按道理来说会无响应的啊？可事实确实相反的，因此引发了我的思考。</p>\n\n        <h1 id=\"测试过程\"   >\n          <a href=\"#测试过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#测试过程\" class=\"headerlink\" title=\"测试过程\"></a>测试过程</h1>\n      <p>我<code>tracert www.baidu.com</code>后，经历了17跳，但是却出现了8个timeout。如果中间的timeout是断掉的，那应该不会有下一跳了啊？可是通信却能照常进行……</p>\n<figure class=\"highlight cmd\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Users</span>\\<span class=\"title\">Feng</span>&gt;<span class=\"title\">tracert</span> <span class=\"title\">www.baidu.com</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">通过最多 30 个跃点跟踪</span></span><br><span class=\"line\"><span class=\"function\">到 <span class=\"title\">www.a.shifen.com</span> [39.156.66.14] 的路由:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  1     3 <span class=\"title\">ms</span>     2 <span class=\"title\">ms</span>     2 <span class=\"title\">ms</span>  192.168.43.1</span></span><br><span class=\"line\"><span class=\"function\">  2     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\">  3    45 <span class=\"title\">ms</span>    19 <span class=\"title\">ms</span>    37 <span class=\"title\">ms</span>  172.21.0.97</span></span><br><span class=\"line\"><span class=\"function\">  4     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\">  5     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\">  6    76 <span class=\"title\">ms</span>    40 <span class=\"title\">ms</span>    37 <span class=\"title\">ms</span>  223.87.28.5</span></span><br><span class=\"line\"><span class=\"function\">  7     *        *       93 <span class=\"title\">ms</span>  221.183.47.105</span></span><br><span class=\"line\"><span class=\"function\">  8    95 <span class=\"title\">ms</span>    72 <span class=\"title\">ms</span>    48 <span class=\"title\">ms</span>  221.183.37.153</span></span><br><span class=\"line\"><span class=\"function\">  9     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\"> 10    84 <span class=\"title\">ms</span>    83 <span class=\"title\">ms</span>    55 <span class=\"title\">ms</span>  111.13.0.174</span></span><br><span class=\"line\"><span class=\"function\"> 11    53 <span class=\"title\">ms</span>    73 <span class=\"title\">ms</span>    60 <span class=\"title\">ms</span>  39.156.27.5</span></span><br><span class=\"line\"><span class=\"function\"> 12    52 <span class=\"title\">ms</span>    58 <span class=\"title\">ms</span>    86 <span class=\"title\">ms</span>  39.156.67.49</span></span><br><span class=\"line\"><span class=\"function\"> 13     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\"> 14     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\"> 15     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\"> 16     *        *        *     请求超时。</span></span><br><span class=\"line\"><span class=\"function\"> 17    74 <span class=\"title\">ms</span>    59 <span class=\"title\">ms</span>    68 <span class=\"title\">ms</span>  39.156.66.14</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">跟踪完成。</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"tracert原理\"   >\n          <a href=\"#tracert原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#tracert原理\" class=\"headerlink\" title=\"tracert原理\"></a>tracert原理</h1>\n      <p>Tracert从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP用户数据报。第一个数据报<code>P1</code>的生存时间TTL设置为1.当<code>P1</code>到达路径上的第一个路由器<code>R1</code>，路由器<code>R1</code>先收下它，接着把TTL值减1.由于TTL等于零了，<code>R1</code>就把<code>P1</code>丢弃了，并向源主机发送一个<code>ICMP时间超过</code>差错报告。</p>\n<p>源主机接着发送第二个数据报<code>P2</code>，并把 TTL 设置为2。<code>P2</code>先到达路由器<code>R1</code>，<code>R1</code>收下后把TTL减1再转发给路由器<code>R2</code>。<code>R2</code>收到<code>P2</code>时TTL为1，但减1后TTL变为零了。<code>R2</code>就丢弃<code>P2</code>，并向源主机发送一个<code>ICMP 时间超过</code>差错报告报文。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的TTL是1。主机不转发数据报，也不把 TTL值减1。但因IP数据报中封装的是无法交付的运输层的UDP用户数据报，因此目的主机要向源主机发送<code>ICMP终点不可达</code>差错报告报文。</p>\n<p>这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的<code>ICMP报文</code>正好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。</p>\n<p>这也解释了为什么tracert要比正常访问时间还要长，因为要反复发送请求和等待超时后<code>ICMP时间超过</code>的差错报文报告，卡的是最长时间。</p>\n\n        <h1 id=\"Time-Out原因\"   >\n          <a href=\"#Time-Out原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Time-Out原因\" class=\"headerlink\" title=\"Time Out原因\"></a>Time Out原因</h1>\n      <p>部分交换机等机器不支持发送ICMP差错报告，不具备回复能力，所以会造成链路不通的假象。</p>\n<p>网络核心部分架设的路由器有的设置了不允许回复，因此不会发送<code>ICMP时间超过差错报告</code>，这样就会显示<code>Time Out</code>，但实际上链路是通的，只是人家根本不理你而已。</p>\n","categories":["考研学习","计算机网络"],"tags":["计算机网络"]},{"title":"【思科模拟器实验】VLAN与TRUNK","url":"/Computer-Networks-%E3%80%90%E6%80%9D%E7%A7%91%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%9E%E9%AA%8C%E3%80%91vlan%E4%B8%8Etrunk/","content":"\n        <h1 id=\"项目目标\"   >\n          <a href=\"#项目目标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#项目目标\" class=\"headerlink\" title=\"项目目标\"></a>项目目标</h1>\n      <p><img src=\"./1.png\" alt=\"任务.png\"></p>\n<ol>\n<li>PC0与PC2在同一VLAN</li>\n<li>PC1与PC3在同一VLAN</li>\n<li>VLAN之间不互通</li>\n</ol>\n\n        <h1 id=\"配置信息\"   >\n          <a href=\"#配置信息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h1>\n      <p>根据项目要求，划一下网络和配置</p>\n\n        <h2 id=\"终端配置\"   >\n          <a href=\"#终端配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#终端配置\" class=\"headerlink\" title=\"终端配置\"></a>终端配置</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">配置</th>\n<th align=\"center\">PC0</th>\n<th align=\"center\">PC1</th>\n<th align=\"center\">PC2</th>\n<th align=\"center\">PC3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">IP地址</td>\n<td align=\"center\">192.168.1.1</td>\n<td align=\"center\">192.168.1.2</td>\n<td align=\"center\">192.168.1.3</td>\n<td align=\"center\">192.168.1.4</td>\n</tr>\n<tr>\n<td align=\"center\">VLAN</td>\n<td align=\"center\">V1</td>\n<td align=\"center\">V2</td>\n<td align=\"center\">V1</td>\n<td align=\"center\">V2</td>\n</tr>\n<tr>\n<td align=\"center\">交换机接口</td>\n<td align=\"center\">s0-f0/1</td>\n<td align=\"center\">s0-f0/2</td>\n<td align=\"center\">s1-f0/1</td>\n<td align=\"center\">s1-f0/2</td>\n</tr>\n</tbody></table></div>\n\n        <h2 id=\"交换机配置\"   >\n          <a href=\"#交换机配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#交换机配置\" class=\"headerlink\" title=\"交换机配置\"></a>交换机配置</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">VLAN</th>\n<th align=\"center\">switch0</th>\n<th align=\"center\">switch1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">V1</td>\n<td align=\"center\">f0/1</td>\n<td align=\"center\">f0/1</td>\n</tr>\n<tr>\n<td align=\"center\">V2</td>\n<td align=\"center\">f0/2</td>\n<td align=\"center\">f0/2</td>\n</tr>\n<tr>\n<td align=\"center\">trunk</td>\n<td align=\"center\">f0/24</td>\n<td align=\"center\">f0/24</td>\n</tr>\n</tbody></table></div>\n<ul>\n<li><p>1号交换机配置</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">//CLI</span><br><span class=\"line\"></span><br><span class=\"line\">Switch&gt;en   //进入特权模式</span><br><span class=\"line\">Switch#vlan da  //进入vlan database</span><br><span class=\"line\">% Warning: It is recommended to configure VLAN from config mode,</span><br><span class=\"line\">  as VLAN database mode is being deprecated. Please consult user</span><br><span class=\"line\">  documentation for configuring VTP/VLAN in config mode.</span><br><span class=\"line\"></span><br><span class=\"line\">Switch(vlan)#vl 2   //添加V2</span><br><span class=\"line\">VLAN 2 added:</span><br><span class=\"line\">    Name: VLAN0002</span><br><span class=\"line\"></span><br><span class=\"line\">Switch(vlan)#exit   //退出到特权模式</span><br><span class=\"line\">APPLY completed.</span><br><span class=\"line\">Exiting....</span><br><span class=\"line\"></span><br><span class=\"line\">Switch#conf t   //进入全局模式</span><br><span class=\"line\">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class=\"line\"></span><br><span class=\"line\">Switch(config)#in f0/2  //进入f0/2号接口配置</span><br><span class=\"line\">Switch(config-if)#sw mo ac  //更改模式至access</span><br><span class=\"line\">Switch(config-if)#sw ac vl 2    //将这个接口调至V2</span><br><span class=\"line\">Switch(config-if)#exit  //退出至全局模式</span><br><span class=\"line\">Switch(config)#in f0/24 //进入f0/24号接口配置</span><br><span class=\"line\">Switch(config-if)#sw mo tr  //更改模式至trunk</span><br><span class=\"line\">Switch(config-if)#exit  //退出至全局模式</span><br><span class=\"line\">Switch(config)#exit //退出至特权模式</span><br><span class=\"line\">Switch#</span><br></pre></td></tr></table></div></figure></li>\n<li><p>2号交换机同理</p>\n</li>\n</ul>\n<p>配置后可以查看配置信息</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Switch#sh vl br //show vlan brief</span><br><span class=\"line\"></span><br><span class=\"line\">VLAN Name                             Status    Ports</span><br><span class=\"line\">---- -------------------------------- --------- -------------------------------</span><br><span class=\"line\">1    default                          active    Fa0/1, Fa0/3, Fa0/4, Fa0/5</span><br><span class=\"line\">                                                Fa0/6, Fa0/7, Fa0/8, Fa0/9</span><br><span class=\"line\">                                                Fa0/10, Fa0/11, Fa0/12, Fa0/13</span><br><span class=\"line\">                                                Fa0/14, Fa0/15, Fa0/16, Fa0/17</span><br><span class=\"line\">                                                Fa0/18, Fa0/19, Fa0/20, Fa0/21</span><br><span class=\"line\">                                                Fa0/22, Fa0/23, Fa0/24</span><br><span class=\"line\">2    VLAN0002                         active    Fa0/2</span><br><span class=\"line\">1002 fddi-default                     active    </span><br><span class=\"line\">1003 token-ring-default               active    </span><br><span class=\"line\">1004 fddinet-default                  active    </span><br><span class=\"line\">1005 trnet-default                    active    </span><br></pre></td></tr></table></div></figure>\n\n<p>可能会发现我们只添加和配置了与2有关的东西，比如新建V2和配置各交换机的2号接口。就是没有配置1。</p>\n<p>那是因为交换机初始化就有V1子网，默认所有的接口都划分在V1中，因此不用分配。</p>\n<p>trunk模式是因为这个接口要充当出口，将服从配置的VLAN范围，接收多个VLAN的信息传输</p>\n\n        <h1 id=\"结束\"   >\n          <a href=\"#结束\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1>\n      <p>这个时候就划分了子网，V1只能和V1进行通信，V2同理。</p>\n<figure class=\"highlight cmd\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> &quot;使用PC0进行<span class=\"built_in\">ping</span>&quot;</span><br><span class=\"line\"><span class=\"built_in\">ping</span> <span class=\"number\">192</span>.<span class=\"number\">168</span>.<span class=\"number\">1</span>.<span class=\"number\">2</span>    //不通</span><br><span class=\"line\"><span class=\"built_in\">ping</span> <span class=\"number\">192</span>.<span class=\"number\">168</span>.<span class=\"number\">1</span>.<span class=\"number\">3</span>    //通</span><br><span class=\"line\"><span class=\"built_in\">ping</span> <span class=\"number\">192</span>.<span class=\"number\">168</span>.<span class=\"number\">1</span>.<span class=\"number\">4</span>    //不通</span><br></pre></td></tr></table></div></figure>","categories":["考研学习","计算机网络"],"tags":["计算机网络"]},{"title":"LeetCode刷题记录","url":"/Program-LeetCode%E7%AC%94%E8%AE%B0/","content":"\n        <h1 id=\"算法入门\"   >\n          <a href=\"#算法入门\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#算法入门\" class=\"headerlink\" title=\"算法入门\"></a>算法入门</h1>\n      \n        <h2 id=\"第一天-二分法查找\"   >\n          <a href=\"#第一天-二分法查找\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第一天-二分法查找\" class=\"headerlink\" title=\"第一天 二分法查找\"></a>第一天 二分法查找</h2>\n      \n        <h3 id=\"二分查找\"   >\n          <a href=\"#二分查找\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3>\n      <p>给定一个<code>n</code>个元素有序的（升序）整型数组<code>nums</code>和一个目标值 <code>target</code> ，写一个函数搜索<code>nums</code>中的<code>target</code>，如果目标值存在返回下标，否则返回<code>-1</code>。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">12</span>], target = <span class=\"number\">9</span></span><br><span class=\"line\">输出: <span class=\"number\">4</span></span><br><span class=\"line\">解释: <span class=\"number\">9</span> 出现在 nums 中并且下标为 <span class=\"number\">4</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>解答：</strong></p>\n<ul>\n<li>我的垃圾解答</li>\n</ul>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">        mid =left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这个控制至关重要，只有这样才能确保在左右都变化的情况下mid不会超出范围</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid] == target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid] &lt; target)</span><br><span class=\"line\">        left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid] &gt; target)</span><br><span class=\"line\">        right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"第一个错误版本\"   >\n          <a href=\"#第一个错误版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第一个错误版本\" class=\"headerlink\" title=\"第一个错误版本\"></a>第一个错误版本</h3>\n      <p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n<p>假设你有 n 个版本<code>[1, 2, ..., n]</code>,你想找出导致之后所有版本出错的第一个错误的版本。</p>\n<p>你可以通过调用<code>bool isBadVersion(version)</code>接口来判断版本号<code>version</code>是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = <span class=\"number\">5</span>, bad = <span class=\"number\">4</span></span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br><span class=\"line\">解释：</span><br><span class=\"line\">调用 isBadVersion(<span class=\"number\">3</span>) -&gt; <span class=\"literal\">false</span> </span><br><span class=\"line\">调用 isBadVersion(<span class=\"number\">5</span>) -&gt; <span class=\"literal\">true</span> </span><br><span class=\"line\">调用 isBadVersion(<span class=\"number\">4</span>) -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\">所以，<span class=\"number\">4</span> 是第一个错误的版本。</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= bad &lt;= n &lt;= 231 - 1</code></li>\n</ul>\n<p><strong>解答：</strong></p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left=<span class=\"number\">1</span>,right=n,mid;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">        mid=left+(right-left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 防止计算溢出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isBadVersion(mid))</span><br><span class=\"line\">            right=mid;</span><br><span class=\"line\">            <span class=\"comment\">//暂定是第一个，查找继续</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            left=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//这个是写死了必有错误的，如果没有错误就会出问题。</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"搜索插入位置\"   >\n          <a href=\"#搜索插入位置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#搜索插入位置\" class=\"headerlink\" title=\"搜索插入位置\"></a>搜索插入位置</h3>\n      <p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>请必须使用时间复杂度为<code>O(log n)</code>的算法。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], target = <span class=\"number\">5</span></span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code>为无重复元素的升序排列数组</li>\n<li><code>-104 &lt;= target &lt;= 104</code></li>\n</ul>\n<p><strong>解答：</strong></p>\n<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = numsSize - <span class=\"number\">1</span>, ans = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ((right - left) / <span class=\"number\">2</span>) + left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class=\"line\">            ans = mid;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>","categories":["编程语言"],"tags":["LeetCode","编程语言"]},{"title":"【思科模拟器实验】静态路由和默认路由","url":"/Computer-Networks-%E3%80%90%E6%80%9D%E7%A7%91%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%9E%E9%AA%8C%E3%80%91%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1/","content":"\n        <h1 id=\"任务\"   >\n          <a href=\"#任务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h1>\n      <p>配置一个这样的链路，让他们能ping通</p>\n<p><img src=\"./1.png\" alt=\"任务.png\"></p>\n\n        <h1 id=\"配置\"   >\n          <a href=\"#配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1>\n      \n        <h2 id=\"终端配置\"   >\n          <a href=\"#终端配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#终端配置\" class=\"headerlink\" title=\"终端配置\"></a>终端配置</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">配置</th>\n<th align=\"center\">PC0</th>\n<th align=\"center\">PC1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">IP</td>\n<td align=\"center\">192.168.1.2</td>\n<td align=\"center\">192.168.4.2</td>\n</tr>\n<tr>\n<td align=\"center\">GateWay</td>\n<td align=\"center\">192.168.1.1</td>\n<td align=\"center\">192.168.4.1</td>\n</tr>\n</tbody></table></div>\n\n        <h2 id=\"路由器配置\"   >\n          <a href=\"#路由器配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#路由器配置\" class=\"headerlink\" title=\"路由器配置\"></a>路由器配置</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">配置</th>\n<th align=\"center\">route0</th>\n<th align=\"center\">route1</th>\n<th align=\"center\">route2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">f0/0</td>\n<td align=\"center\">192.168.1.1</td>\n<td align=\"center\">192.168.2.2</td>\n<td align=\"center\">192.168.4.1</td>\n</tr>\n<tr>\n<td align=\"center\">f0/1</td>\n<td align=\"center\">192.168.2.1</td>\n<td align=\"center\">192.168.3.2</td>\n<td align=\"center\">192.168.3.1</td>\n</tr>\n</tbody></table></div>\n<ul>\n<li>设置线路</li>\n</ul>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Router&gt;en</span><br><span class=\"line\">Router#conf t</span><br><span class=\"line\">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class=\"line\">Router(config)#in f0/0</span><br><span class=\"line\">Router(config-if)#ip ad 192.168.1.1 255.255.255.0</span><br><span class=\"line\">Router(config-if)#no sh</span><br><span class=\"line\"></span><br><span class=\"line\">Router(config-if)#</span><br><span class=\"line\">%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/0, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">Router(config-if)#exit</span><br><span class=\"line\">Router(config)#in f0/1</span><br><span class=\"line\">Router(config-if)#ip ad 192.168.2.1 255.255.255.0</span><br><span class=\"line\">Router(config-if)#no sh</span><br><span class=\"line\"></span><br><span class=\"line\">Router(config-if)#</span><br><span class=\"line\">%LINK-5-CHANGED: Interface FastEthernet0/1, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">Router(config-if)#end</span><br><span class=\"line\">Router#</span><br><span class=\"line\">%SYS-5-CONFIG_I: Configured from console by console</span><br><span class=\"line\"></span><br><span class=\"line\">Router#</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>设置静态路由器表</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">配置</th>\n<th align=\"center\">route0</th>\n<th align=\"center\">route1</th>\n<th align=\"center\">route2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Network</td>\n<td align=\"center\">192.168.4.0/24</td>\n<td align=\"center\">192.168.4.0/24</td>\n<td align=\"center\">192.168.3.0/24</td>\n</tr>\n<tr>\n<td align=\"center\">via</td>\n<td align=\"center\">192.168.2.2</td>\n<td align=\"center\">192.168.3.1</td>\n<td align=\"center\">192.168.3.2</td>\n</tr>\n<tr>\n<td align=\"center\">Network</td>\n<td align=\"center\">-</td>\n<td align=\"center\">192.168.1.0/24</td>\n<td align=\"center\">-</td>\n</tr>\n<tr>\n<td align=\"center\">via</td>\n<td align=\"center\">-</td>\n<td align=\"center\">192.168.2.1</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table></div>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">//Route0的配置</span><br><span class=\"line\">Router&gt;enable</span><br><span class=\"line\">Router#configure terminal</span><br><span class=\"line\">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class=\"line\">Router(config)#</span><br><span class=\"line\">Router(config)#ip route 192.168.4.0 255.255.255.0 192.168.2.2</span><br><span class=\"line\">Router(config)#</span><br></pre></td></tr></table></div></figure>\n\n<p>其他的路由器同理，但是需要注意的是需要双向通路，中间的路由器不仅要设置从1.0到4.0的方向的通路，还要设置从4.0到1.0方向的通路。</p>\n\n        <h1 id=\"结果\"   >\n          <a href=\"#结果\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1>\n      <p>果不其然就ping的通了啊，tracert还能看到每个路由器</p>\n","categories":["考研学习","计算机网络"],"tags":["计算机网络"]},{"title":"Samba服务器搭建","url":"/Server-samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","content":"\n        <h1 id=\"本地环境测试\"   >\n          <a href=\"#本地环境测试\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#本地环境测试\" class=\"headerlink\" title=\"本地环境测试\"></a>本地环境测试</h1>\n      \n        <h2 id=\"环境准备\"   >\n          <a href=\"#环境准备\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2>\n      <ul>\n<li>Centos 7</li>\n<li>VMware 16</li>\n</ul>\n\n        <h2 id=\"搭建流程\"   >\n          <a href=\"#搭建流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h2>\n      \n        <h3 id=\"安装Samba服务\"   >\n          <a href=\"#安装Samba服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#安装Samba服务\" class=\"headerlink\" title=\"安装Samba服务\"></a>安装Samba服务</h3>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install samba -y</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"直接把root账户添加到SMB账户中\"   >\n          <a href=\"#直接把root账户添加到SMB账户中\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#直接把root账户添加到SMB账户中\" class=\"headerlink\" title=\"直接把root账户添加到SMB账户中\"></a>直接把root账户添加到SMB账户中</h3>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">smbpasswd -a root</span><br></pre></td></tr></table></div></figure>\n\n<p>然后输入密码和确认密码</p>\n\n        <h3 id=\"新建共享目录\"   >\n          <a href=\"#新建共享目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#新建共享目录\" class=\"headerlink\" title=\"新建共享目录\"></a>新建共享目录</h3>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /root/share</span><br><span class=\"line\">chmod -R 777 share</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"配置Samba服务\"   >\n          <a href=\"#配置Samba服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置Samba服务\" class=\"headerlink\" title=\"配置Samba服务\"></a>配置Samba服务</h3>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/samba/smb.conf</span><br></pre></td></tr></table></div></figure>\n\n<p>在末尾添加配置信息</p>\n<figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[share]</span><br><span class=\"line\">    comment = share commit</span><br><span class=\"line\">    path = /root/share</span><br><span class=\"line\">    valid user = root</span><br><span class=\"line\">    writable = yes</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"关闭防火墙\"   >\n          <a href=\"#关闭防火墙\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#关闭防火墙\" class=\"headerlink\" title=\"关闭防火墙\"></a>关闭防火墙</h3>\n      <p>他妈的这一步至关重要！我在这里卡了好几个小时就因为没有注意到防火墙把我拦截了，尤其是SELinux这个崽种！</p>\n<figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">setenforce 0 //临时关闭，重启后还会开</span><br><span class=\"line\"></span><br><span class=\"line\">vim /etc/sysconfig/selinux</span><br><span class=\"line\">//把里面的SELINUX=enforcing改成disable后重启，就永久关闭了！</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"开启Samba服务\"   >\n          <a href=\"#开启Samba服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#开启Samba服务\" class=\"headerlink\" title=\"开启Samba服务\"></a>开启Samba服务</h3>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start smb</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart smb</span><br><span class=\"line\">//重启服务</span><br><span class=\"line\">systemctl status smb</span><br><span class=\"line\">//查看服务</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"检验\"   >\n          <a href=\"#检验\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#检验\" class=\"headerlink\" title=\"检验\"></a>检验</h3>\n      <p>这个时候就可以通过添加的root账户，使用SMB服务了。</p>\n\n        <h1 id=\"阿里云搭建Samba服务器\"   >\n          <a href=\"#阿里云搭建Samba服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#阿里云搭建Samba服务器\" class=\"headerlink\" title=\"阿里云搭建Samba服务器\"></a>阿里云搭建Samba服务器</h1>\n      <p>他妈的百度出来说阿里云把139、445端口都堵了，把Smb服务都过滤了。</p>\n<p>经过尝试，确实是不知道什么原因就连不上==、</p>\n<p>运营商层面的封锁我的技术无能为力了。</p>\n<p>转战FTP试试了</p>\n","categories":["服务器"],"tags":["Samba","服务器"]},{"title":"Vsftp搭建FTP服务器","url":"/Server-vsftp%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"\n        <h1 id=\"环境配置\"   >\n          <a href=\"#环境配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1>\n      <ul>\n<li>Centos 7</li>\n<li>VM虚拟机</li>\n<li>root</li>\n</ul>\n\n        <h1 id=\"搭建过程\"   >\n          <a href=\"#搭建过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h1>\n      \n        <h2 id=\"安装vsftp\"   >\n          <a href=\"#安装vsftp\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#安装vsftp\" class=\"headerlink\" title=\"安装vsftp\"></a>安装vsftp</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install vsftpd</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"关闭vsftp防火墙\"   >\n          <a href=\"#关闭vsftp防火墙\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#关闭vsftp防火墙\" class=\"headerlink\" title=\"关闭vsftp防火墙\"></a>关闭vsftp防火墙</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">setenforce 0</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"创建共享目录\"   >\n          <a href=\"#创建共享目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创建共享目录\" class=\"headerlink\" title=\"创建共享目录\"></a>创建共享目录</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p /var/class/test1</span><br><span class=\"line\">mkdir -p /var/class/test2</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"添加vsftp系统账号\"   >\n          <a href=\"#添加vsftp系统账号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#添加vsftp系统账号\" class=\"headerlink\" title=\"添加vsftp系统账号\"></a>添加vsftp系统账号</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">useradd -s /sbin/nologin vftp</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>用的是虚拟账号，这里是vsftp实际的实体账号</p>\n\n        <h2 id=\"设置目录权限\"   >\n          <a href=\"#设置目录权限\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#设置目录权限\" class=\"headerlink\" title=\"设置目录权限\"></a>设置目录权限</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 每次添加新用户或者添加文件夹，执行一遍，改变属主和属组</span></span><br><span class=\"line\">chown -R vftp:vftp /var/class</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"配置虚拟账号密码\"   >\n          <a href=\"#配置虚拟账号密码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置虚拟账号密码\" class=\"headerlink\" title=\"配置虚拟账号密码\"></a>配置虚拟账号密码</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/vsftpd/logins.txt </span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 单行账户，双行密码</span></span><br><span class=\"line\">test1</span><br><span class=\"line\">123456 </span><br><span class=\"line\">test2</span><br><span class=\"line\">123456</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"针对配置的虚拟账号密码生成数据库文件\"   >\n          <a href=\"#针对配置的虚拟账号密码生成数据库文件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#针对配置的虚拟账号密码生成数据库文件\" class=\"headerlink\" title=\"针对配置的虚拟账号密码生成数据库文件\"></a>针对配置的虚拟账号密码生成数据库文件</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 生成对应的数据库，修改了logins.txt就得重新生成</span></span><br><span class=\"line\">db_load -T -t hash -f /etc/vsftpd/logins.txt /etc/vsftpd/login.db </span><br><span class=\"line\">chmod 600 /etc/vsftpd/login.db</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"配置PAM模块\"   >\n          <a href=\"#配置PAM模块\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置PAM模块\" class=\"headerlink\" title=\"配置PAM模块\"></a>配置PAM模块</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 配置PAM模块</span></span><br><span class=\"line\">vim /etc/pam.d/ftp</span><br><span class=\"line\">auth  required  /lib64/security/pam_userdb.so  db=/etc/vsftpd/login </span><br><span class=\"line\">account  required  /lib64/security/pam_userdb.so  db=/etc/vsftpd/login</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"配置vsftpd的默认配置\"   >\n          <a href=\"#配置vsftpd的默认配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置vsftpd的默认配置\" class=\"headerlink\" title=\"配置vsftpd的默认配置\"></a>配置vsftpd的默认配置</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">anonymous_enable=NO</span><br><span class=\"line\">local_enable=YES</span><br><span class=\"line\">write_enable=NO</span><br><span class=\"line\">anon_upload_enable=NO</span><br><span class=\"line\">anon_mkdir_write_enable=NO</span><br><span class=\"line\">anon_other_write_enable=NO</span><br><span class=\"line\">chroot_local_user=NO</span><br><span class=\"line\">chown_uploads=NO</span><br><span class=\"line\">async_abor_enable=YES</span><br><span class=\"line\">ascii_upload_enable=YES</span><br><span class=\"line\">ascii_download_enable=YES</span><br><span class=\"line\">ls_recurse_enable=NO</span><br><span class=\"line\">tcp_wrappers=YES</span><br><span class=\"line\">virtual_use_local_privs=YES</span><br><span class=\"line\">guest_enable=YES</span><br><span class=\"line\">guest_username=vftp</span><br><span class=\"line\">listen=YES</span><br><span class=\"line\">listen_port=21</span><br><span class=\"line\">pasv_enable=YES</span><br><span class=\"line\">pasv_min_port=40000</span><br><span class=\"line\">pasv_max_port=40010</span><br><span class=\"line\">anon_world_readable_only=NO</span><br><span class=\"line\">user_config_dir=/etc/vsftpd/user_conf</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"配置各用户的权限配置信息\"   >\n          <a href=\"#配置各用户的权限配置信息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置各用户的权限配置信息\" class=\"headerlink\" title=\"配置各用户的权限配置信息\"></a>配置各用户的权限配置信息</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /etc/vsftpd/user_conf</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建虚拟用户配置文件，文件名对应虚拟账户，其他虚拟用户copy这份改改就行</span></span><br><span class=\"line\">vim /etc/vsftpd/user_conf/test1</span><br><span class=\"line\">anonymous_enable=YES</span><br><span class=\"line\">write_enable=YES</span><br><span class=\"line\">local_umask=022</span><br><span class=\"line\">anon_upload_enable=YES</span><br><span class=\"line\">anon_mkdir_write_enable=YES</span><br><span class=\"line\">idle_session_timeout=600</span><br><span class=\"line\">data_connection_timeout=120</span><br><span class=\"line\">max_clients=200</span><br><span class=\"line\">max_per_ip=100</span><br><span class=\"line\">local_max_rate=50000</span><br><span class=\"line\">cmds_denied=DELE,RMD,RNFR,RNTO # 禁止删除，删除目录，重命名</span><br><span class=\"line\">local_root=/var/class/test1 # 虚拟用户路径</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"重启VSFTPD服务\"   >\n          <a href=\"#重启VSFTPD服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重启VSFTPD服务\" class=\"headerlink\" title=\"重启VSFTPD服务\"></a>重启VSFTPD服务</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart vsftpd</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"问题\"   >\n          <a href=\"#问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1>\n      <ol>\n<li>文件名为单数汉字是会乱码，怀疑是GBK流转UTF8流出现的问题，暂时想不到解决办法</li>\n</ol>\n","categories":["服务器"],"tags":["服务器","VSFTP"]},{"title":"Git使用笔记","url":"/notebooks-Git/","content":"\n        <h1 id=\"初次使用\"   >\n          <a href=\"#初次使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#初次使用\" class=\"headerlink\" title=\"初次使用\"></a>初次使用</h1>\n      \n        <h2 id=\"配置用户及邮箱\"   >\n          <a href=\"#配置用户及邮箱\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置用户及邮箱\" class=\"headerlink\" title=\"配置用户及邮箱\"></a>配置用户及邮箱</h2>\n      <ul>\n<li>git config –global user.name “gddFeng”<ul>\n<li>设置用户名为gddFeng</li>\n</ul>\n</li>\n<li>git config –global user.email “<span class=\"exturl\"><a class=\"exturl__link\"   href=\"mailto:&#103;&#100;&#100;&#70;&#x65;&#x6e;&#103;&#x40;&#103;&#100;&#x64;&#70;&#101;&#x6e;&#x67;&#46;&#x63;&#111;&#x6d;\" >&#103;&#100;&#100;&#70;&#x65;&#x6e;&#103;&#x40;&#103;&#100;&#x64;&#70;&#101;&#x6e;&#x67;&#46;&#x63;&#111;&#x6d;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>“<ul>\n<li>设置email为<span class=\"exturl\"><a class=\"exturl__link\"   href=\"mailto:&#103;&#100;&#100;&#70;&#x65;&#x6e;&#x67;&#x40;&#103;&#100;&#100;&#70;&#x65;&#110;&#103;&#46;&#x63;&#111;&#x6d;\" >&#103;&#100;&#100;&#70;&#x65;&#x6e;&#x67;&#x40;&#103;&#100;&#100;&#70;&#x65;&#110;&#103;&#46;&#x63;&#111;&#x6d;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"配置ssh以连通\"   >\n          <a href=\"#配置ssh以连通\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置ssh以连通\" class=\"headerlink\" title=\"配置ssh以连通\"></a>配置ssh以连通</h2>\n      <p>检查目录下的<code>.ssh</code>文件，如果没有要新建</p>\n<ul>\n<li>ssh-keygen -t rsa -C “<span class=\"exturl\"><a class=\"exturl__link\"   href=\"mailto:&#x67;&#x64;&#100;&#70;&#101;&#x6e;&#x67;&#64;&#103;&#100;&#x64;&#x46;&#101;&#110;&#x67;&#46;&#x63;&#111;&#109;\" >&#x67;&#x64;&#100;&#70;&#101;&#x6e;&#x67;&#64;&#103;&#100;&#x64;&#x46;&#101;&#110;&#x67;&#46;&#x63;&#111;&#109;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>“</li>\n</ul>\n<p>新建后将公钥 <code>id_rsa.pub</code>提交到GitHub上的<code>ssh</code>中</p>\n<p>测试连通性</p>\n<ul>\n<li>ssh -T <span class=\"exturl\"><a class=\"exturl__link\"   href=\"mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;\" >&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h2 id=\"配置远程仓库\"   >\n          <a href=\"#配置远程仓库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配置远程仓库\" class=\"headerlink\" title=\"配置远程仓库\"></a>配置远程仓库</h2>\n      <p>将当前分支命名为master</p>\n<ul>\n<li>git branch -M master</li>\n</ul>\n<p>设置远程仓库地址</p>\n<ul>\n<li>git remote add origin github.com:gddFeng/NoteBooks.git</li>\n</ul>\n\n        <h2 id=\"提交更改\"   >\n          <a href=\"#提交更改\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#提交更改\" class=\"headerlink\" title=\"提交更改\"></a>提交更改</h2>\n      <p>将项目中所有文件更改提交至缓冲区</p>\n<ul>\n<li>git add .</li>\n</ul>\n<p>提交至<code>HEAD区域</code>中</p>\n<ul>\n<li>git commit -m “注释”</li>\n</ul>\n<p>上传至远程仓库中</p>\n<ul>\n<li>git push -u origin master</li>\n</ul>\n","categories":["课堂笔记"],"tags":["Git","课堂笔记"]},{"title":"Python大数据与量化交易笔记","url":"/notebooks-Python%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%AC%94%E8%AE%B0/","content":"\n        <h1 id=\"第一课\"   >\n          <a href=\"#第一课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第一课\" class=\"headerlink\" title=\"第一课\"></a>第一课</h1>\n      \n        <h2 id=\"金融基础知识培训\"   >\n          <a href=\"#金融基础知识培训\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#金融基础知识培训\" class=\"headerlink\" title=\"金融基础知识培训\"></a>金融基础知识培训</h2>\n      <p>金融，是指货币资金的融通</p>\n<p>金融机构：</p>\n<ul>\n<li>中央银行</li>\n<li>银行</li>\n<li>非营利机构</li>\n<li>在境外开办的外资、侨资、中外合资的金融机构</li>\n</ul>\n<p>金融市场：</p>\n<ul>\n<li><p>货币市场 </p>\n<ul>\n<li>国债</li>\n</ul>\n</li>\n<li><p>资本市场</p>\n<ul>\n<li>期限在一年以上的金融资产交易的市场<ul>\n<li>银行中长期存贷款市场</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>外汇市场</p>\n<ul>\n<li>经营外币和以外币计价的票据等有价证券买卖的市场</li>\n</ul>\n</li>\n<li><p>黄金市场</p>\n<ul>\n<li>黄金买卖的交易中心或场所</li>\n</ul>\n</li>\n<li><p>金融衍生工具市场</p>\n<ul>\n<li>远期市场</li>\n<li>期货市场</li>\n<li>期权市场</li>\n<li>互换市场</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"货币基础知识\"   >\n          <a href=\"#货币基础知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#货币基础知识\" class=\"headerlink\" title=\"货币基础知识\"></a>货币基础知识</h3>\n      <ul>\n<li><p>货币的功能</p>\n<ol>\n<li>流通手段</li>\n<li>价值尺度</li>\n<li>贮藏手段</li>\n<li>延期支付的标准</li>\n</ol>\n</li>\n<li><p>货币的层次</p>\n<ul>\n<li>M0 = 流通中的现金</li>\n<li>M1 = M0 + 活期存款</li>\n<li>M2 = M1 + 定期存款</li>\n<li>M3 = M2 + 其他 </li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"信用\"   >\n          <a href=\"#信用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#信用\" class=\"headerlink\" title=\"信用\"></a>信用</h3>\n      <p>经济活动中的债权债务关系。</p>\n<ul>\n<li>信用分为五种形式：<ul>\n<li>商业信用</li>\n<li>银行信用</li>\n<li>国家信用</li>\n<li>消费信用</li>\n<li>国际信用</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"金融市场\"   >\n          <a href=\"#金融市场\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#金融市场\" class=\"headerlink\" title=\"金融市场\"></a>金融市场</h3>\n      <ul>\n<li>金融市场的功能<ul>\n<li>便利筹资和投资</li>\n<li>方便资金灵活转换</li>\n<li>引导资金流动和集中</li>\n<li>有利于中央银行进行调控</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第二课-量化投资的发展和理工生跨界做量化的开启姿势\"   >\n          <a href=\"#第二课-量化投资的发展和理工生跨界做量化的开启姿势\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第二课-量化投资的发展和理工生跨界做量化的开启姿势\" class=\"headerlink\" title=\"第二课 量化投资的发展和理工生跨界做量化的开启姿势\"></a>第二课 量化投资的发展和理工生跨界做量化的开启姿势</h1>\n      \n        <h2 id=\"课程介绍\"   >\n          <a href=\"#课程介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h2>\n      \n        <h3 id=\"系统地做量化从系统地学习开始\"   >\n          <a href=\"#系统地做量化从系统地学习开始\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#系统地做量化从系统地学习开始\" class=\"headerlink\" title=\"系统地做量化从系统地学习开始\"></a>系统地做量化从系统地学习开始</h3>\n      <ul>\n<li>标准程序员<ul>\n<li>去金融机构写代码<ul>\n<li>重点学习量化系统架构和模块的搭建方法</li>\n<li>理解业务本质</li>\n</ul>\n</li>\n<li>自己做宽客<ul>\n<li>恶补实战课</li>\n<li>认真学逻辑</li>\n<li>忘掉代码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>有实盘经验<ul>\n<li>策略逻辑<ul>\n<li>用量化的手段检验逻辑靠不靠谱</li>\n</ul>\n</li>\n<li>策略实现<ul>\n<li>Coding只是为了一个趁手的工具</li>\n</ul>\n</li>\n<li>策略实战<ul>\n<li>不停诊断、优化测试</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"学什么？学会什么？\"   >\n          <a href=\"#学什么？学会什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#学什么？学会什么？\" class=\"headerlink\" title=\"学什么？学会什么？\"></a>学什么？学会什么？</h3>\n      <ul>\n<li>量化投资的发展和理工生跨界做量化的开启姿势</li>\n<li>上手搭建最简单的交易系统</li>\n<li>丰富你的信号系统</li>\n<li>仓位管理和风控管理功能实现</li>\n<li>怎么评价和诊断交易策略</li>\n<li>进入专业量化赛道的必修课</li>\n</ul>\n\n        <h2 id=\"量化投资的发展\"   >\n          <a href=\"#量化投资的发展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化投资的发展\" class=\"headerlink\" title=\"量化投资的发展\"></a>量化投资的发展</h2>\n      \n        <h3 id=\"代表人物\"   >\n          <a href=\"#代表人物\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#代表人物\" class=\"headerlink\" title=\"代表人物\"></a>代表人物</h3>\n      <ul>\n<li>起源：Jules Regnault</li>\n<li>基石：Edward O.Thorp</li>\n<li>优势：James Simons</li>\n</ul>\n\n        <h3 id=\"量化交易在中国的发展\"   >\n          <a href=\"#量化交易在中国的发展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化交易在中国的发展\" class=\"headerlink\" title=\"量化交易在中国的发展\"></a>量化交易在中国的发展</h3>\n      <p>算法交易：如何进行购买，一次买多少，买多少次？</p>\n\n        <h3 id=\"金融工程模型分类\"   >\n          <a href=\"#金融工程模型分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#金融工程模型分类\" class=\"headerlink\" title=\"金融工程模型分类\"></a>金融工程模型分类</h3>\n      <ol>\n<li>期货、债券<ol>\n<li>CTA趋势</li>\n<li>Mean Reversion</li>\n<li>统计套利</li>\n<li>事件驱动</li>\n<li>日内波动</li>\n</ol>\n</li>\n<li>股票、ETF<ol>\n<li>Alpha</li>\n<li>股票对冲</li>\n<li>期现套利</li>\n</ol>\n</li>\n<li>期权策略<ol>\n<li>市场中性 Delta neutral</li>\n<li>I.V. strategy</li>\n<li>3V maxtrix</li>\n<li>+Gramma +Theta</li>\n</ol>\n</li>\n</ol>\n\n        <h3 id=\"K线\"   >\n          <a href=\"#K线\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#K线\" class=\"headerlink\" title=\"K线\"></a>K线</h3>\n      <p>高开低收</p>\n\n        <h2 id=\"量化投资与主观投资的关系\"   >\n          <a href=\"#量化投资与主观投资的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化投资与主观投资的关系\" class=\"headerlink\" title=\"量化投资与主观投资的关系\"></a>量化投资与主观投资的关系</h2>\n      \n        <h3 id=\"交易观点\"   >\n          <a href=\"#交易观点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#交易观点\" class=\"headerlink\" title=\"交易观点\"></a>交易观点</h3>\n      <ul>\n<li>理论驱动：通过分析经验、理论进行指定交易策略</li>\n<li>数据驱动：大数据统计得出算法结论</li>\n</ul>\n\n        <h3 id=\"五大门派\"   >\n          <a href=\"#五大门派\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#五大门派\" class=\"headerlink\" title=\"五大门派\"></a>五大门派</h3>\n      <ul>\n<li>价值型：评估价值</li>\n<li>成长型：评估前景</li>\n<li>技术型：技术走向</li>\n<li>组合型：收益与风向评估</li>\n<li>指数型：买指数</li>\n</ul>\n\n        <h3 id=\"EMH的三种形式\"   >\n          <a href=\"#EMH的三种形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#EMH的三种形式\" class=\"headerlink\" title=\"EMH的三种形式\"></a>EMH的三种形式</h3>\n      <ol>\n<li>弱式有效市场假说<ul>\n<li>市场价格已充分反应出所有历史的证券价格信息，这时的技术分析失去作用，基本分析还可以。</li>\n</ul>\n</li>\n<li>半强式有效市场假说<ul>\n<li>价格已充分反映出所有已公开的有关公司运营前景的信息。</li>\n<li>基本分析失去作用，只有内部消息才起作用</li>\n</ul>\n</li>\n<li>强式有效市场假说<ul>\n<li>价格已经反映了公司运营的所有情况</li>\n<li>大白于天下了，没办法获利了。</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"理查德·塞勒的理论\"   >\n          <a href=\"#理查德·塞勒的理论\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#理查德·塞勒的理论\" class=\"headerlink\" title=\"理查德·塞勒的理论\"></a>理查德·塞勒的理论</h3>\n      <ul>\n<li>禀赋效应：人们在决策过程中对利和害的权衡是不均衡的，对“避害”的考虑远大于对“趋利”的考虑</li>\n<li>跨期选择：人类恰恰是不擅长做跨期决策的，大多数时候会做出短视冲动的选择。</li>\n<li>心理账户&amp;储蓄理论：人们在思考问题时，会在心li构建出分门别类的心理账户，分别进行计算。</li>\n</ul>\n\n        <h3 id=\"赚谁的钱？赚什么钱？\"   >\n          <a href=\"#赚谁的钱？赚什么钱？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#赚谁的钱？赚什么钱？\" class=\"headerlink\" title=\"赚谁的钱？赚什么钱？\"></a>赚谁的钱？赚什么钱？</h3>\n      <ol>\n<li>市场在某一特定时间内的无效性，或者说是别人犯的错误</li>\n<li>主动承担某种特定风险，继而获得承担该风险的风险溢价</li>\n</ol>\n\n        <h2 id=\"认识一个量化交易策略\"   >\n          <a href=\"#认识一个量化交易策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#认识一个量化交易策略\" class=\"headerlink\" title=\"认识一个量化交易策略\"></a>认识一个量化交易策略</h2>\n      \n        <h3 id=\"双均线策略\"   >\n          <a href=\"#双均线策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#双均线策略\" class=\"headerlink\" title=\"双均线策略\"></a>双均线策略</h3>\n      <ul>\n<li>代码至少有两个严重问题</li>\n<li>策略逻辑上的漏洞更多</li>\n<li>直接上实盘会死得很难看</li>\n</ul>\n\n        <h3 id=\"普量云上的模型\"   >\n          <a href=\"#普量云上的模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#普量云上的模型\" class=\"headerlink\" title=\"普量云上的模型\"></a>普量云上的模型</h3>\n      \n        <h2 id=\"理工生做量化有什么优势\"   >\n          <a href=\"#理工生做量化有什么优势\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#理工生做量化有什么优势\" class=\"headerlink\" title=\"理工生做量化有什么优势\"></a>理工生做量化有什么优势</h2>\n      <p>对公式比较敏感吧</p>\n\n        <h2 id=\"量化交易系统的基本架构\"   >\n          <a href=\"#量化交易系统的基本架构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化交易系统的基本架构\" class=\"headerlink\" title=\"量化交易系统的基本架构\"></a>量化交易系统的基本架构</h2>\n      \n        <h3 id=\"一个完整的交易系统\"   >\n          <a href=\"#一个完整的交易系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一个完整的交易系统\" class=\"headerlink\" title=\"一个完整的交易系统\"></a>一个完整的交易系统</h3>\n      <ul>\n<li>市场——买卖什么</li>\n<li>逻辑——买卖思路</li>\n<li>头寸规模——买卖多少</li>\n<li>入市——何时买进</li>\n<li>止损——何时推出亏损的头寸</li>\n<li>离市——何时退出盈利的头寸</li>\n</ul>\n\n        <h2 id=\"必要的基础知识\"   >\n          <a href=\"#必要的基础知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#必要的基础知识\" class=\"headerlink\" title=\"必要的基础知识\"></a>必要的基础知识</h2>\n      \n        <h1 id=\"第三课-上手搭建最简单的量化交易系统\"   >\n          <a href=\"#第三课-上手搭建最简单的量化交易系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第三课-上手搭建最简单的量化交易系统\" class=\"headerlink\" title=\"第三课 上手搭建最简单的量化交易系统\"></a>第三课 上手搭建最简单的量化交易系统</h1>\n      \n        <h2 id=\"量化交易系统的处理流程\"   >\n          <a href=\"#量化交易系统的处理流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化交易系统的处理流程\" class=\"headerlink\" title=\"量化交易系统的处理流程\"></a>量化交易系统的处理流程</h2>\n      <ol>\n<li>数据处理<ul>\n<li>从TuShare获取行情数据</li>\n<li>从东财网页获取财报数据</li>\n<li>处理数据存在的问题</li>\n</ul>\n</li>\n<li>策略开发<ul>\n<li>计算PE</li>\n<li>实现股票池选股逻辑</li>\n<li>实现股票池的收益统计</li>\n</ul>\n</li>\n<li>离线回测<ul>\n<li>持仓的除权除股息处理</li>\n<li>卖出和买入交易实现</li>\n<li>收盘后交易信号判断</li>\n<li>收益统计</li>\n</ul>\n</li>\n<li>模拟跟踪</li>\n<li>实盘交易</li>\n<li>执行监控</li>\n</ol>\n\n        <h3 id=\"低估值的股票池择时策略\"   >\n          <a href=\"#低估值的股票池择时策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#低估值的股票池择时策略\" class=\"headerlink\" title=\"低估值的股票池择时策略\"></a>低估值的股票池择时策略</h3>\n      <ul>\n<li>股票池<ul>\n<li>0&lt; PE &lt; 30</li>\n<li>PE从小到大排序，提出停牌，取前100只</li>\n<li>调整周期：7个交易日</li>\n</ul>\n</li>\n<li>择时<ul>\n<li>买入：当日K线上穿10日均线</li>\n<li>卖出：<ul>\n<li>当天K线下穿10日均线</li>\n<li>被调出股票池</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"开发环境准备\"   >\n          <a href=\"#开发环境准备\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#开发环境准备\" class=\"headerlink\" title=\"开发环境准备\"></a>开发环境准备</h2>\n      <ul>\n<li>MongoDB</li>\n<li>Python3.7.0</li>\n<li>PyCharm CE</li>\n</ul>\n\n        <h2 id=\"获取行情和财报数据：API和爬虫\"   >\n          <a href=\"#获取行情和财报数据：API和爬虫\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#获取行情和财报数据：API和爬虫\" class=\"headerlink\" title=\"获取行情和财报数据：API和爬虫\"></a>获取行情和财报数据：API和爬虫</h2>\n      <p>用分时图做数据是有问题的</p>\n\n        <h3 id=\"量化基本功\"   >\n          <a href=\"#量化基本功\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化基本功\" class=\"headerlink\" title=\"量化基本功\"></a>量化基本功</h3>\n      <ul>\n<li>从数据源获取数据</li>\n<li>发现并处理数据中存在的问题</li>\n<li>通过基础数据计算出策略所需数据</li>\n<li>了解数据不同数据源的差异</li>\n</ul>\n<p>不同的交易软件处理后的分钟数据不完全一致</p>\n<p>明确一个行情数据接收和处理的概念，为今后搭建量化系统和进行策略开发打下基础。</p>\n\n        <h3 id=\"任务\"   >\n          <a href=\"#任务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3>\n      <ul>\n<li>从Tushare获取历史行情<ul>\n<li>后复权(daily_hfq)</li>\n<li>不复权(daily)</li>\n</ul>\n</li>\n<li>从东方财富抓取财务报表数据</li>\n</ul>\n<ul>\n<li>code：股票代码</li>\n<li>date：日期</li>\n<li>index：是否为指数</li>\n<li>open：开盘价</li>\n<li>close：收盘价</li>\n<li>high：最高价</li>\n<li>low：最低价</li>\n<li>volume：成交量</li>\n</ul>\n<figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># database.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#指定数据库的连接，quant_01是数据库名</span></span><br><span class=\"line\">DB_CONN = MongoClient(<span class=\"string\">&#x27;mongodb://127.0.0.1:27017&#x27;</span>)[<span class=\"string\">&#x27;quant_01&#x27;</span>]</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"补充停牌的日K数据\"   >\n          <a href=\"#补充停牌的日K数据\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#补充停牌的日K数据\" class=\"headerlink\" title=\"补充停牌的日K数据\"></a>补充停牌的日K数据</h3>\n      <ul>\n<li>问题<ul>\n<li>从Tushare获取的数据，停牌日没有数据</li>\n</ul>\n</li>\n<li>影响<ul>\n<li>回测时，不能直接参与账户的净值计算，导致账户的净值以及收益计算不准确</li>\n</ul>\n</li>\n<li>解决方法<ul>\n<li>增加<code>is_trading</code>字段，区分停牌日和交易日</li>\n<li>补充停牌日的日K数据，根据当前数据现状，填充的数据位：open、close、high、low为停牌前最后一个交易日的close，volume为0，is_trading为false</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"数据定时增量入库\"   >\n          <a href=\"#数据定时增量入库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据定时增量入库\" class=\"headerlink\" title=\"数据定时增量入库\"></a>数据定时增量入库</h2>\n      \n        <h2 id=\"实现一个低PE的股票池\"   >\n          <a href=\"#实现一个低PE的股票池\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#实现一个低PE的股票池\" class=\"headerlink\" title=\"实现一个低PE的股票池\"></a>实现一个低PE的股票池</h2>\n      \n        <h2 id=\"开发一组交易信号\"   >\n          <a href=\"#开发一组交易信号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#开发一组交易信号\" class=\"headerlink\" title=\"开发一组交易信号\"></a>开发一组交易信号</h2>\n      \n        <h2 id=\"实现策略回测\"   >\n          <a href=\"#实现策略回测\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#实现策略回测\" class=\"headerlink\" title=\"实现策略回测\"></a>实现策略回测</h2>\n      \n        <h1 id=\"第四课-丰富你的信号系统\"   >\n          <a href=\"#第四课-丰富你的信号系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第四课-丰富你的信号系统\" class=\"headerlink\" title=\"第四课 丰富你的信号系统\"></a>第四课 丰富你的信号系统</h1>\n      <p>实现MACD、Boll、RSI和分型等技术信号的计算，并能够在回测流程中使用这些信号完成择时。</p>\n<ul>\n<li><p>技术指标</p>\n<ul>\n<li>均线型</li>\n<li>趋势型</li>\n<li>摆动型</li>\n<li>能量型</li>\n</ul>\n</li>\n<li><p>趋势即牛熊</p>\n</li>\n<li><p>三个关系</p>\n<ul>\n<li>供需关系</li>\n<li>因果关系</li>\n<li>努力与结果</li>\n</ul>\n</li>\n<li><p>趋势线</p>\n</li>\n<li><p>支撑</p>\n<ul>\n<li>在某个价位购买力超过了销售压力，需求吸收了全部供应</li>\n<li>当价格再次回到支撑位，反弹力度表明需求质量</li>\n</ul>\n</li>\n<li><p>压力</p>\n<ul>\n<li>某个价位销售力量超过了购买力，供应超过了需求</li>\n<li>当价格再次回到压力值，价格回落力度表明供应是否扩大</li>\n</ul>\n</li>\n<li><p>MACD</p>\n<ul>\n<li>金叉和死叉</li>\n<li>价格变化的速度</li>\n<li>(DIF-DEA)[可以X2增大程度以便观察]</li>\n</ul>\n</li>\n<li><p>RSI</p>\n<ul>\n<li>超买和超卖</li>\n</ul>\n</li>\n<li><p>Boll</p>\n<ul>\n<li>突破上轨和突破下轨</li>\n</ul>\n</li>\n<li><p>分型</p>\n<ul>\n<li>顶分型和底分型</li>\n</ul>\n</li>\n<li><p>功能实现</p>\n<ul>\n<li>信号计算<ul>\n<li>实现信号算法</li>\n<li>检测历史信号</li>\n<li>保存到数据库</li>\n</ul>\n</li>\n<li>信号使用<ul>\n<li>提供查询接口</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MACD算法</p>\n</li>\n<li><p>RSI-相对强弱指数</p>\n<ul>\n<li>一定时间窗口内，上涨幅度之和占整体涨跌幅度绝对值之和的比例</li>\n<li>买入愿意相对总体成交的强弱</li>\n<li>超卖区：RSI&lt;20</li>\n<li>超买去：RSI&gt;80</li>\n<li>强弱信号<ul>\n<li>超买：RSI上穿80</li>\n<li>超卖：RSI下穿20</li>\n</ul>\n</li>\n<li>计算公式<ul>\n<li><code>change = close - prev_close</code></li>\n<li><code>up_change = max(change,0)</code></li>\n<li><code>RSI = mean(up_change,N)*100 / mean(abs(change),N)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Boll</p>\n<ul>\n<li>基于统计学的标准差原理</li>\n<li>三条轨道<ul>\n<li>上轨：压力线</li>\n<li>中轨：价格均线</li>\n<li>下轨：支撑线</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分型信号</p>\n<ul>\n<li>顶分型</li>\n<li>底分型</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第五课-仓位管理和风险控制功能实现\"   >\n          <a href=\"#第五课-仓位管理和风险控制功能实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第五课-仓位管理和风险控制功能实现\" class=\"headerlink\" title=\"第五课 仓位管理和风险控制功能实现\"></a>第五课 仓位管理和风险控制功能实现</h1>\n      \n        <h2 id=\"止盈和止损的功能实现\"   >\n          <a href=\"#止盈和止损的功能实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#止盈和止损的功能实现\" class=\"headerlink\" title=\"止盈和止损的功能实现\"></a>止盈和止损的功能实现</h2>\n      <ul>\n<li><p>风险参考指标-波动率</p>\n<ul>\n<li>标准差</li>\n<li>平均真实波幅ATR<ul>\n<li>ATR:近N天真实波幅TR的算数平均值</li>\n<li>TR:以下指标中的最大值<ul>\n<li>今日最高价减去今日最低价</li>\n<li>今日最高价减去昨日收盘价的绝对值</li>\n<li>今日最低价减去昨日收盘价的绝对值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>目标盈利法和最大亏损法</p>\n</li>\n<li><p>回撤止盈(浮动/跟踪止盈)</p>\n</li>\n<li><p>技术信号止盈/止损</p>\n</li>\n</ul>\n\n        <h2 id=\"仓位管理工程实现\"   >\n          <a href=\"#仓位管理工程实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#仓位管理工程实现\" class=\"headerlink\" title=\"仓位管理工程实现\"></a>仓位管理工程实现</h2>\n      <ul>\n<li><p>交易系统中与盈利相关的要素</p>\n<ul>\n<li>策略的胜率</li>\n<li>每次交易的盈亏比</li>\n<li>头寸规模的确定</li>\n<li>资金量的大小</li>\n<li>交易机会的多少</li>\n<li>交易成本</li>\n</ul>\n</li>\n<li><p>凯利公式</p>\n</li>\n<li><p>仓位管理</p>\n<ul>\n<li>投入资金/总资金</li>\n<li>不同阶段：建仓、加仓/减仓、清仓</li>\n<li>资金分配：头寸规模的确定和分配</li>\n</ul>\n</li>\n<li><p>确定头寸规模的四种模式</p>\n<ul>\n<li>每一固定交易金额交易一个单位</li>\n<li>等价值交易单位</li>\n<li>百分比风险模型</li>\n<li>百分比波动幅度模型</li>\n</ul>\n</li>\n<li><p>常见的加仓方法</p>\n<ul>\n<li>均匀加仓</li>\n<li>金字塔式</li>\n<li>倒金字塔式</li>\n</ul>\n</li>\n<li><p>仓位分配的其他考虑</p>\n<ul>\n<li>复利/不复利方式</li>\n<li>资金占比上限</li>\n<li>单日分配资金上限</li>\n<li>同时持仓股(数量)上限</li>\n<li>单只股票仓位上限</li>\n<li>…..</li>\n</ul>\n</li>\n<li><p>工程化实现的考虑</p>\n<ul>\n<li>可用资金不足时的处理<ul>\n<li>限制新的购买，忽略该信号</li>\n<li>在增加新股票之前，消除业绩最差的头寸</li>\n<li>为继续购买新的，将头寸规模确定得小一些</li>\n</ul>\n</li>\n<li>入选组合的优先级<ul>\n<li>根据某种指标排序</li>\n<li>根据历史表现筛选</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"编写一个完整的交易策略\"   >\n          <a href=\"#编写一个完整的交易策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#编写一个完整的交易策略\" class=\"headerlink\" title=\"编写一个完整的交易策略\"></a>编写一个完整的交易策略</h2>\n      <ol>\n<li>基准策略和测试环境<ul>\n<li>股票池候选：上证50成分股，不调仓</li>\n<li>双均线策略<ul>\n<li>日K级别，MA10 vs MA30</li>\n<li>开盘前检测信号，金叉买、死叉卖</li>\n</ul>\n</li>\n<li>头寸规模确定<ul>\n<li>均仓方案(等额资金分配)</li>\n</ul>\n</li>\n<li>测试环境<ul>\n<li>回测区间</li>\n<li>编程语言</li>\n<li>平台 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.joinquant.com/\" >www.joinquant.com</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>按盈利比例均匀加仓<ul>\n<li>记录每只持仓最后一次的买入价</li>\n<li>如以当日开盘价相对于前一次买入价的盈利比例超过某个阈值，则等额加一次仓<ul>\n<li>前提是当日没有任何止损或其它买入信号发生。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>按波动率分配资金<ul>\n<li>计算一段时间内的ATR作为波动率值</li>\n<li>每只股票允许承担一定百分比的风险，折算到具体的风险金额</li>\n<li>以该风险金额和波动率的值来确定建仓个股的资金头寸<ul>\n<li>波动率越大，分配的头寸越小</li>\n<li>波动率越小，分配的头寸越大</li>\n</ul>\n</li>\n<li>基于基准策略进行改进实验</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>风险控制方法</li>\n<li>仓位管理方法</li>\n<li>编写一个完整的交易策略<ul>\n<li>完整交易系统的要素</li>\n<li>仓位管理和止盈/止损的编写示例</li>\n<li>渐进式的改进过程</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第六课-怎么评价和诊断交易策略\"   >\n          <a href=\"#第六课-怎么评价和诊断交易策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第六课-怎么评价和诊断交易策略\" class=\"headerlink\" title=\"第六课 怎么评价和诊断交易策略\"></a>第六课 怎么评价和诊断交易策略</h1>\n      \n        <h2 id=\"几种常用评价指标的工程实现\"   >\n          <a href=\"#几种常用评价指标的工程实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#几种常用评价指标的工程实现\" class=\"headerlink\" title=\"几种常用评价指标的工程实现\"></a>几种常用评价指标的工程实现</h2>\n      <ul>\n<li><p>四个维度</p>\n<ul>\n<li>收益</li>\n<li>风险</li>\n<li>胜率</li>\n<li>稳定性</li>\n</ul>\n</li>\n<li><p>年化收益</p>\n<ul>\n<li>年化收益率是指把一段时间内的收益率换算成年收益率</li>\n<li>单利/复利年化收益</li>\n</ul>\n</li>\n<li><p>策略的评价指标-夏普比率</p>\n</li>\n<li><p>最大回撤</p>\n<ul>\n<li>在选定周期内任一历史时点往后推，策略的净值走到最低点时的收益率回撤幅度的最大值</li>\n<li>用来描述策略可能出现的最糟糕情况，衡量了最极端可能的亏损。</li>\n</ul>\n</li>\n<li><p>信息率</p>\n<ul>\n<li>信息率用来衡量承担主动风险所带来的超额收益，表示单位主动风险所带来的超额收益</li>\n<li>在承担适度风险的情况下，尽量追求高信息率</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"什么样的策略是好策略\"   >\n          <a href=\"#什么样的策略是好策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么样的策略是好策略\" class=\"headerlink\" title=\"什么样的策略是好策略\"></a>什么样的策略是好策略</h2>\n      <p>不以目标需求为依据的策略性能评估都是耍流氓</p>\n<ul>\n<li><p>如何评价</p>\n<ul>\n<li>夏普比率<ul>\n<li>风险与收益的权衡</li>\n<li>索提诺比率</li>\n</ul>\n</li>\n<li>最大回撤<ul>\n<li>最坏的情况</li>\n</ul>\n</li>\n<li>年化收益<ul>\n<li>按复利计算</li>\n</ul>\n</li>\n<li>心理因子<ul>\n<li>舒适度</li>\n</ul>\n</li>\n<li>信息率<ul>\n<li>投资经理的能力</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>翻盘念书 = 最大回撤/年化收益</p>\n</li>\n<li><p>稳健型</p>\n<ul>\n<li>正收益</li>\n<li>回撤小</li>\n</ul>\n</li>\n<li><p>进取型</p>\n<ul>\n<li>收益风险平衡</li>\n<li>风险至上</li>\n</ul>\n</li>\n<li><p>激进型</p>\n<ul>\n<li>在可承受的风险范围内追求收益最大化</li>\n<li>极端行情配套的风控和严格的压力测试</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"从哪些方面去改进策略\"   >\n          <a href=\"#从哪些方面去改进策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#从哪些方面去改进策略\" class=\"headerlink\" title=\"从哪些方面去改进策略\"></a>从哪些方面去改进策略</h2>\n      \n        <h2 id=\"总结-1\"   >\n          <a href=\"#总结-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>年化收益、夏普比率、最大回撤、信息率的实现</li>\n<li>评价策略性能要从投资目标出发</li>\n<li>策略的改进要从逻辑下手</li>\n</ul>\n\n        <h1 id=\"第七课-进入专业量化赛道的必修课\"   >\n          <a href=\"#第七课-进入专业量化赛道的必修课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第七课-进入专业量化赛道的必修课\" class=\"headerlink\" title=\"第七课 进入专业量化赛道的必修课\"></a>第七课 进入专业量化赛道的必修课</h1>\n      \n        <h2 id=\"最根本的数据处理：Level1-Ticks\"   >\n          <a href=\"#最根本的数据处理：Level1-Ticks\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最根本的数据处理：Level1-Ticks\" class=\"headerlink\" title=\"最根本的数据处理：Level1 Ticks\"></a>最根本的数据处理：Level1 Ticks</h2>\n      <ul>\n<li>排查错误的需要<ul>\n<li>在不同交易软件处理后的分钟数据不完全一致<ul>\n<li>切分点不懂(OHLC值的差异)</li>\n<li>左右边界(时间戳)靠拢方式不同</li>\n</ul>\n</li>\n<li>附加信息的处理<ul>\n<li>交易状态</li>\n<li>涨跌停价的处理</li>\n<li>资金流向(超大中小单)统计</li>\n<li>换手率、量比、成交量/额等的积累</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">Tick级别</th>\n<th align=\"center\">Level 1</th>\n<th align=\"center\">Level 2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">行情数据类别</td>\n<td align=\"center\">快照行情</td>\n<td align=\"center\">逐笔行情</td>\n</tr>\n<tr>\n<td align=\"center\">推送频度</td>\n<td align=\"center\">固定间隔(~3秒)</td>\n<td align=\"center\">委托队列和逐笔成交明细</td>\n</tr>\n<tr>\n<td align=\"center\">盘口报价显示</td>\n<td align=\"center\">五档行情</td>\n<td align=\"center\">十档行情(深交所千档)</td>\n</tr>\n<tr>\n<td align=\"center\">使用方式</td>\n<td align=\"center\">免费(客户端)</td>\n<td align=\"center\">付费使用</td>\n</tr>\n</tbody></table></div>\n<ul>\n<li>交易状态的处理<ul>\n<li>记录交易状态(正常交易或停/复牌)的重要性<ul>\n<li>回测错误和无效交易指令</li>\n<li>技术指标计算误差</li>\n</ul>\n</li>\n<li>交易状态的获取<ul>\n<li>第三方的量化API(通常已有)</li>\n<li>交易所行情接收</li>\n<li>盘前/盘中信息库</li>\n<li>Tick消息字段</li>\n<li>紧急公告消息(临时停牌)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"深入探讨两个实战量化策略\"   >\n          <a href=\"#深入探讨两个实战量化策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#深入探讨两个实战量化策略\" class=\"headerlink\" title=\"深入探讨两个实战量化策略\"></a>深入探讨两个实战量化策略</h2>\n      \n        <h3 id=\"Hans123\"   >\n          <a href=\"#Hans123\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Hans123\" class=\"headerlink\" title=\"Hans123\"></a>Hans123</h3>\n      <ul>\n<li><p>Hans123策略即增强</p>\n<ul>\n<li>日内交易策略，趋势突破系统</li>\n<li>在开盘30(或N)分钟后准备入场</li>\n<li>上轨 = 开盘后30分钟内的高点</li>\n<li>下轨 = 开盘后30分钟内的低点</li>\n<li>当价格突破上轨，买入开仓</li>\n<li>当价格跌穿下轨，卖出开仓</li>\n<li>突破时如已有持仓，则先止损再反手</li>\n<li>如有持仓，在收盘前无条件平仓</li>\n</ul>\n</li>\n<li><p>遇到极端情况</p>\n<ul>\n<li>Hans窗口内的振幅限制</li>\n<li>日内止盈/止损(小周期K线)</li>\n<li>大周期涨跌空间及后市判断</li>\n<li>每交易日的开平仓次数限制</li>\n</ul>\n</li>\n<li><p>如何适用于股票自动交易？</p>\n<ul>\n<li>T+1制度的限制</li>\n<li>指数/板块到个股</li>\n<li>从日内到日间</li>\n<li>止盈/止损措施</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"量化策略的完整研发和系统搭建\"   >\n          <a href=\"#量化策略的完整研发和系统搭建\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化策略的完整研发和系统搭建\" class=\"headerlink\" title=\"量化策略的完整研发和系统搭建\"></a>量化策略的完整研发和系统搭建</h2>\n      \n        <h2 id=\"如何优化你的量化策略：再谈人工智能\"   >\n          <a href=\"#如何优化你的量化策略：再谈人工智能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何优化你的量化策略：再谈人工智能\" class=\"headerlink\" title=\"如何优化你的量化策略：再谈人工智能\"></a>如何优化你的量化策略：再谈人工智能</h2>\n      \n        <h2 id=\"预告：你未来必踩的坑-怎么上实盘？\"   >\n          <a href=\"#预告：你未来必踩的坑-怎么上实盘？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#预告：你未来必踩的坑-怎么上实盘？\" class=\"headerlink\" title=\"预告：你未来必踩的坑-怎么上实盘？\"></a>预告：你未来必踩的坑-怎么上实盘？</h2>\n      \n        <h1 id=\"第八课-实战型量化投资必备知识\"   >\n          <a href=\"#第八课-实战型量化投资必备知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第八课-实战型量化投资必备知识\" class=\"headerlink\" title=\"第八课 实战型量化投资必备知识\"></a>第八课 实战型量化投资必备知识</h1>\n      \n        <h2 id=\"量化投资策略类型及模型原理\"   >\n          <a href=\"#量化投资策略类型及模型原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化投资策略类型及模型原理\" class=\"headerlink\" title=\"量化投资策略类型及模型原理\"></a>量化投资策略类型及模型原理</h2>\n      <ul>\n<li><p>常见品种</p>\n<ul>\n<li>股票</li>\n<li>ETF</li>\n<li>商品期货</li>\n<li>股指期货</li>\n<li>期权</li>\n<li>债券</li>\n<li>外汇</li>\n</ul>\n</li>\n<li><p>股票</p>\n<ul>\n<li>公司基本资料</li>\n<li>财务数据和分析</li>\n<li>新闻公告及重大事项</li>\n<li>行业分析</li>\n<li>技术分析</li>\n</ul>\n</li>\n<li><p>ETF</p>\n<ul>\n<li>交易型开放式指数基金</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"趋势型策略模型原理\"   >\n          <a href=\"#趋势型策略模型原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#趋势型策略模型原理\" class=\"headerlink\" title=\"趋势型策略模型原理\"></a>趋势型策略模型原理</h2>\n      <ul>\n<li><p>供需关系</p>\n<ul>\n<li>趋势的动力来自于供需关系的不平衡</li>\n</ul>\n</li>\n<li><p>因果关系</p>\n<ul>\n<li>趋势形成之前需要准备过程</li>\n</ul>\n</li>\n<li><p>势力与结果</p>\n<ul>\n<li>成交量的增长没有使价格大幅增长，这是走势停止行为。</li>\n</ul>\n</li>\n<li><p>要点总结</p>\n<ul>\n<li>头寸和退出<ul>\n<li>可以小亏，必须大赚</li>\n</ul>\n</li>\n<li>风险<ul>\n<li>截断亏损，让利润奔跑</li>\n</ul>\n</li>\n<li>分散化<ul>\n<li>永远不要把鸡蛋放一个篮子</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"配对交易策略原理\"   >\n          <a href=\"#配对交易策略原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#配对交易策略原理\" class=\"headerlink\" title=\"配对交易策略原理\"></a>配对交易策略原理</h2>\n      <ul>\n<li><p>套利交易-策略</p>\n<ul>\n<li>无风险套利</li>\n<li>配对交易</li>\n<li>统计套利</li>\n</ul>\n</li>\n<li><p>对冲/套期保值-手段</p>\n<ul>\n<li>反向交易，规避单边持仓风险</li>\n<li>期现、跨期、跨品种、跨市场</li>\n</ul>\n</li>\n<li><p>市场中性(消除beta) vs Alpha(绝对收益)</p>\n</li>\n<li><p>波动率套利</p>\n<ul>\n<li>利用转债中的期权，对冲个股风险。当转债所包含的期权相对其标的股票低估时，通常其<strong>隐含波动率</strong>处于历史低位，此时买入转债同时做空一定数量的股票(根据模型计算获得)</li>\n<li>在随后的交易日中，通过调整做空比例来达到市场中性，并赚取转债固定利息和期权固执上升所带来的低风险收益，其风险远小于单买股票或债券。</li>\n</ul>\n</li>\n<li><p>期权套利</p>\n<ul>\n<li>期权套利是由期权合约或合约之间定价偏差所带来的套利机会。</li>\n<li>期权套利策略灵活多样，包括买卖期权平价关系套利策略、价差期权组合套利策略、期权凸性套利策略、期权箱体套利策略等等。</li>\n</ul>\n</li>\n<li><p>ETF套利</p>\n<ul>\n<li>ETF套利策略同样分为折价套利和溢价套利</li>\n<li>折价套利是当ETF价值小于对应的一篮子股票市值，则买日ETF后，赎回一篮子股票，再在股票市场卖出进行套利。</li>\n<li>溢价套利是当ETF价值大于对应的一篮子股票市值，则从股票市场购入一篮子股票，申购ETF份额，然后从二级市场卖出ETF份额进行套利。</li>\n</ul>\n</li>\n<li><p>跨期套利</p>\n</li>\n</ul>\n\n        <h2 id=\"量化策略研发流程与基本技能\"   >\n          <a href=\"#量化策略研发流程与基本技能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化策略研发流程与基本技能\" class=\"headerlink\" title=\"量化策略研发流程与基本技能\"></a>量化策略研发流程与基本技能</h2>\n      \n        <h2 id=\"常用的量化平台概述及如何选择\"   >\n          <a href=\"#常用的量化平台概述及如何选择\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常用的量化平台概述及如何选择\" class=\"headerlink\" title=\"常用的量化平台概述及如何选择\"></a>常用的量化平台概述及如何选择</h2>\n      <ul>\n<li>第三方量化平台分类和举例<ul>\n<li>本地(图标/后台交易)<ul>\n<li>金字塔、MC、TB、WH、TS、MT4</li>\n</ul>\n</li>\n<li>云端(SaaS/券商定制)<ul>\n<li>聚宽、优矿、米筐</li>\n</ul>\n</li>\n<li>SDK/量化API(+终端/Web UI)<ul>\n<li>万得、东财Choice、掘金量化</li>\n</ul>\n</li>\n<li>开源框架(基于Python)<ul>\n<li>PyCTP、VNPY、QuickLib、Zipline</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"如何把你的主观交易逻辑变成一个量化模型\"   >\n          <a href=\"#如何把你的主观交易逻辑变成一个量化模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何把你的主观交易逻辑变成一个量化模型\" class=\"headerlink\" title=\"如何把你的主观交易逻辑变成一个量化模型\"></a>如何把你的主观交易逻辑变成一个量化模型</h2>\n      \n        <h1 id=\"第九课-以量化角度重新认识技术指标\"   >\n          <a href=\"#第九课-以量化角度重新认识技术指标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第九课-以量化角度重新认识技术指标\" class=\"headerlink\" title=\"第九课 以量化角度重新认识技术指标\"></a>第九课 以量化角度重新认识技术指标</h1>\n      \n        <h2 id=\"经典技术指标的基本原理及量化要点\"   >\n          <a href=\"#经典技术指标的基本原理及量化要点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#经典技术指标的基本原理及量化要点\" class=\"headerlink\" title=\"经典技术指标的基本原理及量化要点\"></a>经典技术指标的基本原理及量化要点</h2>\n      <ul>\n<li>客观看待，理性应用<ul>\n<li>扬长避短<ul>\n<li>间接性、滞后性、钝化</li>\n<li>连续背离现象</li>\n<li>时间周期相关</li>\n</ul>\n</li>\n<li>综合判断<ul>\n<li>靠单一指标解决问题是不现实的</li>\n<li>交叉验证，辅助决策</li>\n</ul>\n</li>\n<li>概率思维<ul>\n<li>行情多变，市场不可预测</li>\n<li>量化即概率，大数定律</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"编写程序去量化一个趋势型技术指标\"   >\n          <a href=\"#编写程序去量化一个趋势型技术指标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#编写程序去量化一个趋势型技术指标\" class=\"headerlink\" title=\"编写程序去量化一个趋势型技术指标\"></a>编写程序去量化一个趋势型技术指标</h2>\n      <ul>\n<li><p>指标之王MACD</p>\n</li>\n<li><p>环境准备</p>\n<ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://ycjq.95358.com/\" >一创聚宽</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li>python2.7</li>\n<li>pyecharts</li>\n<li>pandas</li>\n</ul>\n</li>\n<li><p>上传文件</p>\n<ul>\n<li><code>jukuan_db.py</code><ul>\n<li>数据获取接口</li>\n</ul>\n</li>\n<li><code>jukuan_macd_config.py</code><ul>\n<li>macd信号检测配置文件</li>\n</ul>\n</li>\n<li><code>jukuan_macd_signal.py</code><ul>\n<li>历史数据缓存以及信号检测</li>\n</ul>\n</li>\n<li><code>signal_statistics</code><ul>\n<li>信号统计</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"编写趋势型技术指标的性能评价指标\"   >\n          <a href=\"#编写趋势型技术指标的性能评价指标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#编写趋势型技术指标的性能评价指标\" class=\"headerlink\" title=\"编写趋势型技术指标的性能评价指标\"></a>编写趋势型技术指标的性能评价指标</h2>\n      \n        <h2 id=\"如何根据性能数据判断持仓周期\"   >\n          <a href=\"#如何根据性能数据判断持仓周期\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何根据性能数据判断持仓周期\" class=\"headerlink\" title=\"如何根据性能数据判断持仓周期\"></a>如何根据性能数据判断持仓周期</h2>\n      <ul>\n<li>交易成本的影响</li>\n<li>持仓周期、资金利用率与年化收益</li>\n<li>交易机会的多少与交易频次</li>\n<li>资金管理与风险控制</li>\n</ul>\n\n        <h1 id=\"第十课-基于多因子分析的股票\"   >\n          <a href=\"#第十课-基于多因子分析的股票\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第十课-基于多因子分析的股票\" class=\"headerlink\" title=\"第十课 基于多因子分析的股票\"></a>第十课 基于多因子分析的股票</h1>\n      \n        <h2 id=\"股票池选择策略的原因及基本框架\"   >\n          <a href=\"#股票池选择策略的原因及基本框架\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#股票池选择策略的原因及基本框架\" class=\"headerlink\" title=\"股票池选择策略的原因及基本框架\"></a>股票池选择策略的原因及基本框架</h2>\n      <ul>\n<li>一个交易系统的要素<ul>\n<li>市场：买卖什么</li>\n<li>头寸规模：要卖多少？</li>\n<li>入市：什么时候买卖</li>\n<li>止损：什么时候放弃一个亏损的头寸？</li>\n<li>退出：什么时候退出一个盈利的头寸？</li>\n<li>战术：怎么买卖？</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"基于多因子分析的股票池设计与实现\"   >\n          <a href=\"#基于多因子分析的股票池设计与实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基于多因子分析的股票池设计与实现\" class=\"headerlink\" title=\"基于多因子分析的股票池设计与实现\"></a>基于多因子分析的股票池设计与实现</h2>\n      <ul>\n<li><p>多因子模型的选股框架</p>\n<ul>\n<li>大类因子权重</li>\n<li>最终权重</li>\n</ul>\n</li>\n<li><p>对每只股票</p>\n<ul>\n<li>根据单因子分层进行打分</li>\n<li>根据分层打分的因子权重进行股票得分的综合计算</li>\n<li>根据综合打分进行排序，选取得分前10%股票进入股票池</li>\n</ul>\n</li>\n<li><p>单因子检验-零投资组合检验</p>\n</li>\n<li><p>多因子模型的原则</p>\n<ul>\n<li>因子尽量少</li>\n<li>因子间尽量独立</li>\n<li>时间尽可能长</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"股票池的性能评估\"   >\n          <a href=\"#股票池的性能评估\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#股票池的性能评估\" class=\"headerlink\" title=\"股票池的性能评估\"></a>股票池的性能评估</h2>\n      <ul>\n<li><p>股票池设计</p>\n<ul>\n<li>基本面：排除劣质<ul>\n<li>剔除总市值排名最小的10%的股票</li>\n<li>剔除PE(TTM)小于0或大于100的股票</li>\n<li>剔除ST股票</li>\n</ul>\n</li>\n<li>技术面：超跌反弹<ul>\n<li>取25日跌幅前10%的股票</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>单因子检验-市值</p>\n</li>\n<li><p>单因子检验-PE</p>\n</li>\n<li><p>股票池定义</p>\n<ul>\n<li>选股条件<ul>\n<li>剔除总市值排名最小的10%的股票</li>\n<li>剔除PE(TTM)小于0或大于100的股票</li>\n<li>剔除ST股票</li>\n<li>取25日跌幅前10%的股票</li>\n</ul>\n</li>\n<li>再平衡周期<ul>\n<li>25个交易日</li>\n</ul>\n</li>\n<li>容量<ul>\n<li>无限制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>股票池检验</p>\n<ul>\n<li>股票池第一次构建<ul>\n<li>买入股票池中所有的股票</li>\n</ul>\n</li>\n<li>股票池每次再平衡<ul>\n<li>卖出持仓股中已经不在股票池中的股票</li>\n<li>买入股票池中新纳入的股票</li>\n</ul>\n</li>\n<li>仓位<ul>\n<li>平均分配可用资金</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>股票池优化探讨</p>\n<ul>\n<li>引入质量因子：ROE</li>\n<li>引入资金面因子：连续N日主力资金净流入</li>\n<li>引入综合财务指标：财务优秀</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"使用定制化财务因子构建股票池\"   >\n          <a href=\"#使用定制化财务因子构建股票池\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#使用定制化财务因子构建股票池\" class=\"headerlink\" title=\"使用定制化财务因子构建股票池\"></a>使用定制化财务因子构建股票池</h2>\n      <ul>\n<li><p>风险</p>\n<ul>\n<li>资产负债率</li>\n<li>净资产负债率</li>\n<li>流动比率</li>\n<li>速动比率</li>\n</ul>\n</li>\n<li><p>运营效率</p>\n<ul>\n<li>总资产周转率</li>\n<li>固定资产周转率</li>\n<li>存货周转率</li>\n<li>应收账款周转率</li>\n</ul>\n</li>\n<li><p>盈利能力及质量</p>\n<ul>\n<li>营业收入增长率</li>\n<li>净利润增长率</li>\n<li>总资产增长率</li>\n<li>净资产增长率</li>\n</ul>\n</li>\n<li><p>前景与评估</p>\n</li>\n<li><p>盈利能力及质量评价因子</p>\n<ul>\n<li><code>因子评价=风险得分*0.1+运营效率得分*0.25+盈利能力及质量得分*0.4+前景与评估得分*0.25</code></li>\n</ul>\n</li>\n<li><p>财务指标计算-资产负债率</p>\n</li>\n<li><p>财务指标计算-流动比率</p>\n</li>\n<li><p>财务指标计算-净资产收益率</p>\n</li>\n<li><p>财务指标计算-销售收现比率</p>\n</li>\n</ul>\n\n        <h1 id=\"第十一课-趋势型策略的设计与实现\"   >\n          <a href=\"#第十一课-趋势型策略的设计与实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第十一课-趋势型策略的设计与实现\" class=\"headerlink\" title=\"第十一课 趋势型策略的设计与实现\"></a>第十一课 趋势型策略的设计与实现</h1>\n      \n        <h2 id=\"趋势型策略原理以及股票池机制的设计\"   >\n          <a href=\"#趋势型策略原理以及股票池机制的设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#趋势型策略原理以及股票池机制的设计\" class=\"headerlink\" title=\"趋势型策略原理以及股票池机制的设计\"></a>趋势型策略原理以及股票池机制的设计</h2>\n      <ul>\n<li>趋势与三个关系<ul>\n<li>供需关系</li>\n<li>因果关系</li>\n<li>努力与结果</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"什么样的股票迎来趋势的概率高？\"   >\n          <a href=\"#什么样的股票迎来趋势的概率高？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么样的股票迎来趋势的概率高？\" class=\"headerlink\" title=\"什么样的股票迎来趋势的概率高？\"></a>什么样的股票迎来趋势的概率高？</h3>\n      <ul>\n<li>事件驱动<ul>\n<li>高送转</li>\n<li>重大资产重组</li>\n<li>产业政策优惠</li>\n</ul>\n</li>\n<li>技术分析<ul>\n<li>上升通道</li>\n<li>突破压力位</li>\n</ul>\n</li>\n<li>过渡反应后的均值回复<ul>\n<li>反转后的小海龟</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"趋势型择时信号的设计方法与编程实现\"   >\n          <a href=\"#趋势型择时信号的设计方法与编程实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#趋势型择时信号的设计方法与编程实现\" class=\"headerlink\" title=\"趋势型择时信号的设计方法与编程实现\"></a>趋势型择时信号的设计方法与编程实现</h2>\n      \n        <h2 id=\"编写一个趋势策略并做回测与性能评估\"   >\n          <a href=\"#编写一个趋势策略并做回测与性能评估\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#编写一个趋势策略并做回测与性能评估\" class=\"headerlink\" title=\"编写一个趋势策略并做回测与性能评估\"></a>编写一个趋势策略并做回测与性能评估</h2>\n      <ul>\n<li><p>买入条件</p>\n<ul>\n<li>条件一：<ul>\n<li>15分钟bar，MA5上穿MA30</li>\n</ul>\n</li>\n<li>条件二：<ul>\n<li>15分钟bar，MACD底背离(DIF vs Close)</li>\n<li>5分钟bar，MACD连续底背离</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>头寸分配</p>\n<ul>\n<li>均仓</li>\n<li>根据历史不完全统计，采用一个相对“不激进”的均仓方式</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"优化趋势型策略的思路及方法\"   >\n          <a href=\"#优化趋势型策略的思路及方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#优化趋势型策略的思路及方法\" class=\"headerlink\" title=\"优化趋势型策略的思路及方法\"></a>优化趋势型策略的思路及方法</h2>\n      \n        <h1 id=\"第十二课-量化体系中的风险控制\"   >\n          <a href=\"#第十二课-量化体系中的风险控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第十二课-量化体系中的风险控制\" class=\"headerlink\" title=\"第十二课 量化体系中的风险控制\"></a>第十二课 量化体系中的风险控制</h1>\n      \n        <h2 id=\"风险的度量-波动率\"   >\n          <a href=\"#风险的度量-波动率\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#风险的度量-波动率\" class=\"headerlink\" title=\"风险的度量-波动率\"></a>风险的度量-波动率</h2>\n      <ul>\n<li>标准差</li>\n<li>平均真实波幅ATR<ul>\n<li>ATR：近N填真是波幅TR的算术平均值</li>\n<li>TR：以下指标中的最大值<ul>\n<li>今日最高价减去今日最低价</li>\n<li>今日最高价减去昨日收盘价的绝对值</li>\n<li>今日最低价减去昨日收盘价的绝对值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"常用的风险控制方法\"   >\n          <a href=\"#常用的风险控制方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常用的风险控制方法\" class=\"headerlink\" title=\"常用的风险控制方法\"></a>常用的风险控制方法</h2>\n      <ul>\n<li><p>系统性风险</p>\n<ul>\n<li>政策面</li>\n<li>资金面</li>\n<li>国际环境</li>\n<li>黑天鹅事件</li>\n</ul>\n</li>\n<li><p>大盘调制指数</p>\n<ul>\n<li>指数均线</li>\n<li>金叉/死叉</li>\n<li>多头排列/空头排列</li>\n<li>最大回撤倍数</li>\n</ul>\n</li>\n<li><p>流动性限制</p>\n<ul>\n<li>持仓头寸不超过该股票流通市值的2%</li>\n<li>日成交量不超过该股票成交量的10%</li>\n</ul>\n</li>\n<li><p>期货的隔夜风险控制</p>\n<ul>\n<li>持仓不过节</li>\n<li>隔夜操作需要控制仓位，降低第二天反向跳空爆仓的风险</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"策略性能的评估与优化\"   >\n          <a href=\"#策略性能的评估与优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#策略性能的评估与优化\" class=\"headerlink\" title=\"策略性能的评估与优化\"></a>策略性能的评估与优化</h2>\n      <ul>\n<li><p>止盈止损系统</p>\n<ul>\n<li>止盈<ul>\n<li>最大盈利法</li>\n<li>技术信号止盈</li>\n</ul>\n</li>\n<li>止损<ul>\n<li>最大亏损法</li>\n<li>技术信号止损</li>\n</ul>\n</li>\n<li>联合止盈止损<ul>\n<li>跟踪止盈止损</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>跟踪止盈止损</p>\n<ul>\n<li>回撤N倍ATR止盈止损</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"实现止盈止损模块以提高策略性能\"   >\n          <a href=\"#实现止盈止损模块以提高策略性能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#实现止盈止损模块以提高策略性能\" class=\"headerlink\" title=\"实现止盈止损模块以提高策略性能\"></a>实现止盈止损模块以提高策略性能</h2>\n      \n        <h2 id=\"探讨波动率与风险的关系\"   >\n          <a href=\"#探讨波动率与风险的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#探讨波动率与风险的关系\" class=\"headerlink\" title=\"探讨波动率与风险的关系\"></a>探讨波动率与风险的关系</h2>\n      <ul>\n<li><p>A股特质-缓涨急跌</p>\n<ul>\n<li>波动率与股市经常呈明显的负相关<ul>\n<li>熊市阶段：波动率放大</li>\n<li>牛市逐步上涨阶段：波动率稳定</li>\n<li>牛市末期：波动率放大</li>\n<li>震荡市：波动率缩小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>绝对风险</p>\n<ul>\n<li>波动率大的交易标的风险大，需要更加严格控制其买入风险</li>\n</ul>\n</li>\n<li><p>相对风险</p>\n<ul>\n<li>交易标的波动率随时间逐步放大，当超过一定阈值，需要更加严格控制其买入风险</li>\n<li>波动率的圆形底形态</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第十三课-量化体系中的资金管理\"   >\n          <a href=\"#第十三课-量化体系中的资金管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第十三课-量化体系中的资金管理\" class=\"headerlink\" title=\"第十三课 量化体系中的资金管理\"></a>第十三课 量化体系中的资金管理</h1>\n      \n        <h2 id=\"量化策略中的经典资金管理模型\"   >\n          <a href=\"#量化策略中的经典资金管理模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#量化策略中的经典资金管理模型\" class=\"headerlink\" title=\"量化策略中的经典资金管理模型\"></a>量化策略中的经典资金管理模型</h2>\n      <ul>\n<li><p>确定头寸规模的四种模型</p>\n<ul>\n<li>每一固定金额交易一个单位</li>\n<li>等价值交易单位</li>\n<li>百分比风险模型</li>\n<li>百分比波动幅度模型</li>\n</ul>\n</li>\n<li><p>头寸管理模型的应用</p>\n<ul>\n<li>标的价格差别</li>\n<li>风险偏好类型</li>\n<li>总风险控制</li>\n<li>标的波动差别</li>\n</ul>\n</li>\n<li><p>波动率的衡量</p>\n<ul>\n<li>标准差</li>\n<li>考虑前期时间窗口波动率的变化</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"用Python编程实现资金管理模块\"   >\n          <a href=\"#用Python编程实现资金管理模块\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#用Python编程实现资金管理模块\" class=\"headerlink\" title=\"用Python编程实现资金管理模块\"></a>用Python编程实现资金管理模块</h2>\n      \n        <h2 id=\"构建一个完善的量化交易策略\"   >\n          <a href=\"#构建一个完善的量化交易策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#构建一个完善的量化交易策略\" class=\"headerlink\" title=\"构建一个完善的量化交易策略\"></a>构建一个完善的量化交易策略</h2>\n      <ul>\n<li><p>股票池</p>\n</li>\n<li><p>细节考虑-流动性风险</p>\n<ul>\n<li>持仓头寸不超过该股票流通市值的2%</li>\n<li>日成交量不超过该股票成交量的10%</li>\n</ul>\n</li>\n<li><p>细节考虑-资金</p>\n<ul>\n<li>单日可用资金上限</li>\n<li>单个交易标的资金上限</li>\n<li>总可用资金上限</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"再讨论：策略的性能评估和优化\"   >\n          <a href=\"#再讨论：策略的性能评估和优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#再讨论：策略的性能评估和优化\" class=\"headerlink\" title=\"再讨论：策略的性能评估和优化\"></a>再讨论：策略的性能评估和优化</h2>\n      <ul>\n<li>平均分配风险<ul>\n<li>预计建仓N个交易标的，按照风险平均分配原则，每个交易标的承担的风险为：总风险/N</li>\n<li><code>头寸数量 = (总风险/N)/单个头寸风险</code></li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第十四课-期货趋势型策略开发\"   >\n          <a href=\"#第十四课-期货趋势型策略开发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第十四课-期货趋势型策略开发\" class=\"headerlink\" title=\"第十四课 期货趋势型策略开发\"></a>第十四课 期货趋势型策略开发</h1>\n      \n        <h2 id=\"趋势型量化策略必备的期货知识\"   >\n          <a href=\"#趋势型量化策略必备的期货知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#趋势型量化策略必备的期货知识\" class=\"headerlink\" title=\"趋势型量化策略必备的期货知识\"></a>趋势型量化策略必备的期货知识</h2>\n      <ul>\n<li><p>典型的交易</p>\n<ul>\n<li>股票</li>\n<li>期货</li>\n<li>债券</li>\n<li>外汇</li>\n<li>期货</li>\n<li>数字货币</li>\n<li>……</li>\n</ul>\n</li>\n<li><p>期货交易的基本特征</p>\n<ul>\n<li>合约标准化</li>\n<li>交易集中化</li>\n<li>双向交易和对冲机制</li>\n<li>杠杆机制</li>\n<li>每日无负债结算制度</li>\n<li>T+0交易</li>\n</ul>\n</li>\n<li><p>期货市场的构成</p>\n<ul>\n<li>套期保值者(企业)<ul>\n<li>期现</li>\n<li>基差</li>\n</ul>\n</li>\n<li>投机者<ul>\n<li>机构投资者<ul>\n<li>期限</li>\n<li>对冲</li>\n<li>套利</li>\n<li>单边</li>\n</ul>\n</li>\n<li>个人散户投机者<ul>\n<li>套利</li>\n<li>单边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>期货投资分析方法综述</p>\n<ul>\n<li>技术分析<ul>\n<li>市场行为涵益一切信息</li>\n<li>价格沿趋势移动</li>\n<li>历史会重演</li>\n</ul>\n</li>\n<li>基本分析<ul>\n<li>因果关系明确，结论确定</li>\n<li>完备的即时资料</li>\n<li>极高的行业经验专业素质</li>\n</ul>\n</li>\n<li>程序化交易<ul>\n<li>技术分析程序化</li>\n<li>数量统计分析、交易</li>\n<li>高频交易</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>期货投资者的通病</p>\n<ul>\n<li>满仓操作</li>\n<li>逆势开仓</li>\n<li>持仓综合征</li>\n<li>判顶断底</li>\n<li>死不认输</li>\n<li>逆势抢反弹</li>\n<li>频繁全天候操作</li>\n<li>把握不好进出场时机</li>\n<li>盲目跟风</li>\n<li>主力盯单心态</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"期货量化工具介绍\"   >\n          <a href=\"#期货量化工具介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#期货量化工具介绍\" class=\"headerlink\" title=\"期货量化工具介绍\"></a>期货量化工具介绍</h2>\n      <ul>\n<li>期货量化平台选择<ul>\n<li>TB（交易开拓者）</li>\n<li>MC（Multicharts）</li>\n<li>金字塔</li>\n<li>WH8（文华赢智）</li>\n<li>VN.PY（开源框架）</li>\n<li>自行研发</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"趋势型策略原理\"   >\n          <a href=\"#趋势型策略原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#趋势型策略原理\" class=\"headerlink\" title=\"趋势型策略原理\"></a>趋势型策略原理</h2>\n      <ul>\n<li><p>增仓动作（有持仓情况下）</p>\n<ul>\n<li>多头：相对于上次入场价格，每上涨N/2就新增一个单位的多头头寸，每根K线内可多次加仓</li>\n<li>空头：相对于上次入场价格，每下跌N/2就新增一个单位的空头头寸，每根K先内可多次加仓</li>\n</ul>\n</li>\n<li><p>退出（有持仓情况下）</p>\n<ul>\n<li>新增规则：相对于上次入场价格，如超过最大允许的损失幅度（2*N），则清仓。</li>\n<li>加仓所在的那根K线内，不进行止损。</li>\n</ul>\n</li>\n<li><p>其它细节</p>\n<ul>\n<li>长周期突破点保障信号<ul>\n<li>入市过滤条件</li>\n</ul>\n</li>\n<li>前次突破失败与否的判别<ul>\n<li>盈利性退出</li>\n<li>亏损性退出</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>期货交易策略的注意事项</p>\n<ul>\n<li>移仓换月（主力合约切换）</li>\n<li>杠杆效应（保证金交易）</li>\n<li>波动幅度（隔夜跳空风险）</li>\n<li>套利机会（跨期、跨品种）</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"用TB开发商品期货趋势型策略\"   >\n          <a href=\"#用TB开发商品期货趋势型策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#用TB开发商品期货趋势型策略\" class=\"headerlink\" title=\"用TB开发商品期货趋势型策略\"></a>用TB开发商品期货趋势型策略</h2>\n      \n        <h1 id=\"第十五课-均值回复型策略的设计与开发\"   >\n          <a href=\"#第十五课-均值回复型策略的设计与开发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第十五课-均值回复型策略的设计与开发\" class=\"headerlink\" title=\"第十五课 均值回复型策略的设计与开发\"></a>第十五课 均值回复型策略的设计与开发</h1>\n      \n        <h2 id=\"均值回复型策略原理\"   >\n          <a href=\"#均值回复型策略原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#均值回复型策略原理\" class=\"headerlink\" title=\"均值回复型策略原理\"></a>均值回复型策略原理</h2>\n      <ul>\n<li><p>理查德·塞勒的基金的理念</p>\n</li>\n<li><p>行为金融学指导下的交易策略</p>\n</li>\n<li><p>巴菲特的投资密码</p>\n<ul>\n<li>别人贪婪我恐惧，别人恐惧我贪婪</li>\n<li>很平常的价钱买一家很棒的公司远远超过用很棒的价钱买一家平常的公司</li>\n</ul>\n</li>\n<li><p>做趋势 VS. 做震荡</p>\n<ul>\n<li>大尺度：趋势+反转</li>\n<li>中尺度：趋势跟随+均值回复</li>\n<li>小尺度：均值回复</li>\n<li>微小尺度：随机游走</li>\n</ul>\n</li>\n<li><p>思考</p>\n<ul>\n<li>时段1和时段2间隔时间长度的影响<ul>\n<li>对应：均值回复的尺度</li>\n</ul>\n</li>\n<li>不同起始点的影响<ul>\n<li>对应：在什么样的大趋势下有此特征</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"思路-短期市场反转\"   >\n          <a href=\"#思路-短期市场反转\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#思路-短期市场反转\" class=\"headerlink\" title=\"思路-短期市场反转\"></a>思路-短期市场反转</h2>\n      <ol>\n<li>建立一个股票池：过去3（或1）个月表现最差的N只股票构成的组合</li>\n<li>再平衡周期：1个月</li>\n<li>头寸管理：<ul>\n<li>所有入选股票均仓</li>\n<li>按照市值加权</li>\n</ul>\n</li>\n<li>多空组合<ul>\n<li>做多表现最差组合</li>\n<li>做空表现最好组合</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"在聚宽上编写一个均值回复型股票量化策略\"   >\n          <a href=\"#在聚宽上编写一个均值回复型股票量化策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#在聚宽上编写一个均值回复型股票量化策略\" class=\"headerlink\" title=\"在聚宽上编写一个均值回复型股票量化策略\"></a>在聚宽上编写一个均值回复型股票量化策略</h2>\n      <ul>\n<li>策略编写的考虑<ul>\n<li>投资标的选择<ul>\n<li>投资组合的容量</li>\n<li>期货VS.股票</li>\n</ul>\n</li>\n<li>多空双向交易<ul>\n<li>纯多头</li>\n<li>做多/做空机制</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"策略对交易成本的敏感范围检测\"   >\n          <a href=\"#策略对交易成本的敏感范围检测\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#策略对交易成本的敏感范围检测\" class=\"headerlink\" title=\"策略对交易成本的敏感范围检测\"></a>策略对交易成本的敏感范围检测</h2>\n      \n        <h3 id=\"压力测试-考虑各种成本\"   >\n          <a href=\"#压力测试-考虑各种成本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#压力测试-考虑各种成本\" class=\"headerlink\" title=\"压力测试-考虑各种成本\"></a>压力测试-考虑各种成本</h3>\n      <ul>\n<li>各类交易费用<ul>\n<li>交易所手续费</li>\n<li>券商佣金</li>\n</ul>\n</li>\n<li>保证金账户设置<ul>\n<li>融资/融券利率</li>\n<li>保证金比率</li>\n</ul>\n</li>\n<li>滑点；冲击成本</li>\n</ul>\n\n        <h2 id=\"在策略中实现头寸管理进行策略优化\"   >\n          <a href=\"#在策略中实现头寸管理进行策略优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#在策略中实现头寸管理进行策略优化\" class=\"headerlink\" title=\"在策略中实现头寸管理进行策略优化\"></a>在策略中实现头寸管理进行策略优化</h2>\n      \n        <h3 id=\"头寸管理\"   >\n          <a href=\"#头寸管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#头寸管理\" class=\"headerlink\" title=\"头寸管理\"></a>头寸管理</h3>\n      <ul>\n<li><p>分配资金方式：均仓(现有方式)VS.按波动率</p>\n</li>\n<li><p>波动率增大，意味着风险增加，分配的仓位就小，反之亦然</p>\n</li>\n<li><p>平均真实波幅ATR=MA(TR,N)</p>\n<ul>\n<li>TR = 当日的真实波动幅度 =Max(H-L,|H-PDC|,|PDC-L|)</li>\n<li>其中：H=当日最高价，L=当日最低价，PDC=前一日收盘价</li>\n</ul>\n</li>\n<li><p>头寸规模单位 = 账户的%风险/(ATR*每一最小交易单位)</p>\n</li>\n<li><p>更多优化方向</p>\n<ul>\n<li>调仓时，卖旧买新的逻辑如何更接近实战</li>\n<li>大小周期，加择时，止盈止损</li>\n<li>借鉴海龟交易法的动态头寸管理</li>\n<li>行业板块占比均衡</li>\n<li>成分股筛选和权重调整</li>\n<li>参数优化（但要避免拟合）</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"总结-2\"   >\n          <a href=\"#总结-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>均值回复策略的原理，思路验证</li>\n<li>纯多头和多空双向的实现和比较</li>\n<li>评估交易成本的影响</li>\n<li>通过头寸管理方法进行策略优化</li>\n</ul>\n","categories":["课堂笔记"],"tags":["课堂笔记","量化交易","Python"]},{"title":"创业者的成长之路笔记","url":"/notebooks-%E5%88%9B%E4%B8%9A%E8%80%85%E7%9A%84%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E7%AC%94%E8%AE%B0/","content":"\n        <h1 id=\"第一单元\"   >\n          <a href=\"#第一单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第一单元\" class=\"headerlink\" title=\"第一单元\"></a>第一单元</h1>\n      \n        <h2 id=\"1-1-感知创业\"   >\n          <a href=\"#1-1-感知创业\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-感知创业\" class=\"headerlink\" title=\"1.1 感知创业\"></a>1.1 感知创业</h2>\n      <ul>\n<li>狭义上的创业<ul>\n<li>创办一所企业，赚他娘的钱</li>\n</ul>\n</li>\n<li>广义上的创业<ul>\n<li>开创一个新视野</li>\n<li>对自己拥有的或即将拥有的资源进行优化整合，从而创造出更大价值的过程。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"采访\"   >\n          <a href=\"#采访\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#采访\" class=\"headerlink\" title=\"采访\"></a>采访</h3>\n      <ul>\n<li>创业者的心态不同<ul>\n<li>创业不是被动打工，要打鸡血主动。</li>\n<li>坚持不放弃。</li>\n</ul>\n</li>\n</ul>\n<p>汇聚一群志同道合的同志开创新事业</p>\n\n        <h2 id=\"1-2-认知创业者\"   >\n          <a href=\"#1-2-认知创业者\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-2-认知创业者\" class=\"headerlink\" title=\"1.2 认知创业者\"></a>1.2 认知创业者</h2>\n      \n        <h2 id=\"采访-1\"   >\n          <a href=\"#采访-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#采访-1\" class=\"headerlink\" title=\"采访\"></a>采访</h2>\n      <ul>\n<li>大学期间的收获<ul>\n<li>个人能力的提升<ul>\n<li>决策能力</li>\n<li>工作能力</li>\n<li>管理能力</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>对于创业认知的改变<ol>\n<li>解决温饱</li>\n<li>改变世界</li>\n</ol>\n</li>\n<li>对于风口的把控能力</li>\n<li>保持新鲜活力，善于产生思想碰撞</li>\n<li>创业前叫圆梦，创业后叫责任</li>\n</ul>\n<p>创业的热情，对自己事业的热爱。</p>\n\n        <h1 id=\"第二单元\"   >\n          <a href=\"#第二单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第二单元\" class=\"headerlink\" title=\"第二单元\"></a>第二单元</h1>\n      \n        <h2 id=\"2-1-创业意识\"   >\n          <a href=\"#2-1-创业意识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-创业意识\" class=\"headerlink\" title=\"2.1 创业意识\"></a>2.1 创业意识</h2>\n      \n        <h3 id=\"2-2-1-创业意识的内涵\"   >\n          <a href=\"#2-2-1-创业意识的内涵\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-1-创业意识的内涵\" class=\"headerlink\" title=\"2.2.1 创业意识的内涵\"></a>2.2.1 创业意识的内涵</h3>\n      <p>意识是人的头脑对于客观物质世界的反应，是感觉、思维等各种<strong>心里过程的总和</strong>，是社会的人堆客观存在的主观反映。</p>\n\n        <h3 id=\"2-2-2-创业意识的内涵\"   >\n          <a href=\"#2-2-2-创业意识的内涵\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-2-创业意识的内涵\" class=\"headerlink\" title=\"2.2.2 创业意识的内涵\"></a>2.2.2 创业意识的内涵</h3>\n      <p>意识的内涵：</p>\n<ul>\n<li>穿也活动或过程室友创业意识和创业行为这两大方面构成的。</li>\n<li>创业意识是指在创业实践活动中对创业者起<strong>动力</strong>作用的个性倾向。</li>\n<li>创业意识集中表现了创业素质中的社会性质，支配着创业者对创业活动的<strong>态度和行为</strong>，并规定其态度和行为的方向、力度、层次和水平，具有较强的主观选择性和能动性，是创业素质的重要组成部分。</li>\n<li>创业意识是创业者素质系统中的第一个子系统即<strong>驱动系统</strong>，是创业行为产生的根本前提和先导，<strong>没有创业意识也就没有创业行为</strong>。</li>\n</ul>\n<p>创业意识的产生：</p>\n<p>创业意识是在<strong>创业知识、创业技能与创业经验</strong>的基础上产生的。有没有创业知识、创业技能与创业经验做为基础，很难产生创业意识，最多只能得出一点非常浮现的创业想法或意向。因此，创业意识是<strong>创业知识、创业技能和创业经验的进一步升华</strong>。</p>\n\n        <h3 id=\"2-2-3-创业意识的要素\"   >\n          <a href=\"#2-2-3-创业意识的要素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-3-创业意识的要素\" class=\"headerlink\" title=\"2.2.3 创业意识的要素\"></a>2.2.3 创业意识的要素</h3>\n      <p>创业意识是由创业需要、创业动机、创业星宇、创业理想、创业信念和创业世界观等要素组成的。</p>\n<ul>\n<li>创业需要<ul>\n<li>创业需要上升为创业动机。具有仅有创业需要不一定有创业行为，只有创业需要上升为创业动机时，创业行为才有可能发生。</li>\n</ul>\n</li>\n<li>创业动机<ul>\n<li>激发创业动机的内外条件。引起创业动机的<strong>内在条件</strong>是创业需要；引起创业动机的<strong>外在条件</strong>是创业目标或对象。</li>\n<li>创业动机的作用。创业动机是一种成就动机，是竭力追求获得最佳价值和优异效益的动因。创业动机对创业行为产生促进、推动左右。创业者创业动机的形成标志着创业实践活动的即将开始，<strong>有了创业动机，才会有创业行为</strong>。</li>\n</ul>\n</li>\n<li>创业兴趣<ul>\n<li>要把创业兴趣升华到创业爱好</li>\n</ul>\n</li>\n<li>创业理想<ul>\n<li>当创业动机和创业兴趣积累到一定程度时就形成了创业理想。主要是一种<strong>职业理想和事业理想</strong>，而非政治理想和道德理想。</li>\n</ul>\n</li>\n<li>创业信念<ul>\n<li>创业没有失败者，只有放弃者</li>\n<li>创业信念是认识、情感和意志的有机统一，是一种综合性、稳定性和持久性很强的心理品质。因此创业信念是创业者的精神支柱，是创业意识的核心部分。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"2-2-创业精神\"   >\n          <a href=\"#2-2-创业精神\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-创业精神\" class=\"headerlink\" title=\"2.2 创业精神\"></a>2.2 创业精神</h2>\n      <p>创业精神是指在创业者的主观世界中，那些具有<strong>开创性</strong>的思想、观念、个性、意志、作风和品质等</p>\n<p>创业者的个体创业精神是指以个人力量，在个人意志的引导下，开创新事业的思想、理念和品质。</p>\n\n        <h3 id=\"创业精神的层次\"   >\n          <a href=\"#创业精神的层次\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业精神的层次\" class=\"headerlink\" title=\"创业精神的层次\"></a>创业精神的层次</h3>\n      <ol>\n<li>哲学层次创业精神</li>\n<li>心理学层次创业精神</li>\n<li>行为学层次创业精神</li>\n</ol>\n\n        <h3 id=\"创业精神的主题\"   >\n          <a href=\"#创业精神的主题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业精神的主题\" class=\"headerlink\" title=\"创业精神的主题\"></a>创业精神的主题</h3>\n      <p>创业精神是一种追求机会的行为境界，不断追求和把握机会和机遇、勇敢地面对各种各样的挑战。</p>\n<p>创业精神是持续变革、革新、转换和引入新理念、新方法、新技术等的集中体现。创新是创业精神的核心内涵。</p>\n<p>一是对规模的追求；二是对质量个价值的追求；三是追求持续的创新和发展</p>\n<p>这三个主题随着创业行为深化而不断丰富新的内涵，进而不断提升创业的质量与价值并贯穿创业过程的始终。</p>\n\n        <h3 id=\"创业精神的特征\"   >\n          <a href=\"#创业精神的特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业精神的特征\" class=\"headerlink\" title=\"创业精神的特征\"></a>创业精神的特征</h3>\n      <ul>\n<li>高度综合性</li>\n<li>三维整体性</li>\n<li>整体先进性</li>\n<li>鲜明时代性</li>\n</ul>\n\n        <h1 id=\"第三单元\"   >\n          <a href=\"#第三单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第三单元\" class=\"headerlink\" title=\"第三单元\"></a>第三单元</h1>\n      \n        <h2 id=\"3-1-磨炼创业心理品质与思维\"   >\n          <a href=\"#3-1-磨炼创业心理品质与思维\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-1-磨炼创业心理品质与思维\" class=\"headerlink\" title=\"3.1 磨炼创业心理品质与思维\"></a>3.1 磨炼创业心理品质与思维</h2>\n      \n        <h3 id=\"创业心理品质的定义\"   >\n          <a href=\"#创业心理品质的定义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业心理品质的定义\" class=\"headerlink\" title=\"创业心理品质的定义\"></a>创业心理品质的定义</h3>\n      <p>创业心理品质是指创业者在创业实践活动中表现出来的<strong>心里过程和个性心理特征</strong>。主要体现在创业者的独立性、敢为性’坚韧性、可执行、适应性、合作性等方面。创业心理品质是创业者在创业实践活动中克服重重困难、达成创业目标的前提和关键。</p>\n\n        <h3 id=\"创业心理品质的内涵\"   >\n          <a href=\"#创业心理品质的内涵\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业心理品质的内涵\" class=\"headerlink\" title=\"创业心理品质的内涵\"></a>创业心理品质的内涵</h3>\n      <ol>\n<li>强烈的创业需要动机</li>\n<li>高度的自信心</li>\n<li>较强的自我控制力</li>\n<li>较强的冒险精神与拼搏意识</li>\n<li>较强的创新意识与创新能力</li>\n<li>高度诚信与较强协作能力</li>\n</ol>\n\n        <h3 id=\"创业心理品质的塑造\"   >\n          <a href=\"#创业心理品质的塑造\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业心理品质的塑造\" class=\"headerlink\" title=\"创业心理品质的塑造\"></a>创业心理品质的塑造</h3>\n      <p>良好的创业邻里品质是创业者创业成功的基本前提和条件。一个创业者的创业心理品质不是先天就有的，而是通过后天的实践活动、教育培养逐步形成的。</p>\n<p>从意义上来说，每个人都有特定的创业心理品质结构，每个人都具有显性的、隐性的创业心理品质，都有相对优势、劣势的创业心理品质。</p>\n\n        <h3 id=\"创业心理品质的塑造-1\"   >\n          <a href=\"#创业心理品质的塑造-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业心理品质的塑造-1\" class=\"headerlink\" title=\"创业心理品质的塑造\"></a>创业心理品质的塑造</h3>\n      <ol>\n<li>强化自我修炼</li>\n<li>学习和借鉴创业成功者的经验</li>\n<li>在创业实践中不断总结经验和教训</li>\n<li>积极参加创业心理咨询和训练</li>\n</ol>\n\n        <h2 id=\"3-2-创业思维\"   >\n          <a href=\"#3-2-创业思维\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-创业思维\" class=\"headerlink\" title=\"3.2 创业思维\"></a>3.2 创业思维</h2>\n      \n        <h3 id=\"创业思维定义\"   >\n          <a href=\"#创业思维定义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业思维定义\" class=\"headerlink\" title=\"创业思维定义\"></a>创业思维定义</h3>\n      \n        <h1 id=\"第四单元\"   >\n          <a href=\"#第四单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第四单元\" class=\"headerlink\" title=\"第四单元\"></a>第四单元</h1>\n      \n        <h2 id=\"洞察力\"   >\n          <a href=\"#洞察力\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#洞察力\" class=\"headerlink\" title=\"洞察力\"></a>洞察力</h2>\n      <p>洞察力，是指通过表面现象精确判断出现象背后的本质的能力</p>\n<p>敏锐的观察力是创业者必备的素质之一。有敏锐洞察力的创业者往往善于把握创业机会。</p>\n\n        <h3 id=\"洞察力的本质\"   >\n          <a href=\"#洞察力的本质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#洞察力的本质\" class=\"headerlink\" title=\"洞察力的本质\"></a>洞察力的本质</h3>\n      <p>洞察力的本质是一种深入观察、理解和把我事物或问题的能力</p>\n<p>洞察力是人们对个人认识、情感、行为的动机与相互关系的透彻分析</p>\n\n        <h3 id=\"洞察力的意义\"   >\n          <a href=\"#洞察力的意义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#洞察力的意义\" class=\"headerlink\" title=\"洞察力的意义\"></a>洞察力的意义</h3>\n      <p>缺乏洞察力：往往会把组织引向停滞和萧条，瞬间的粗心大意就有可能导致失败。</p>\n<p>具备洞察力：往往能够发现别人容易忽略甚至从未注意到的机会，并会鞭策组织保持它的优势地位。</p>\n\n        <h3 id=\"创业机会\"   >\n          <a href=\"#创业机会\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业机会\" class=\"headerlink\" title=\"创业机会\"></a>创业机会</h3>\n      <p>创业机会是指具有较强吸引力的、较为持久的合适的一种有利于其创业的奇迹，并最终表现在能够为客户提供有价值或增加价值的产品或服务之中。</p>\n<p>创业机会本身是无形的，一般附着在不断发展变化的事物当中。</p>\n<p>普遍性、偶然性、消逝性</p>\n\n        <h3 id=\"创业机会识别\"   >\n          <a href=\"#创业机会识别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业机会识别\" class=\"headerlink\" title=\"创业机会识别\"></a>创业机会识别</h3>\n      <ol>\n<li>先前经验</li>\n<li>专业知识</li>\n<li>认知因素</li>\n<li>社会关系网络</li>\n<li>创造性</li>\n</ol>\n\n        <h3 id=\"创业者对创业机会的洞察\"   >\n          <a href=\"#创业者对创业机会的洞察\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业者对创业机会的洞察\" class=\"headerlink\" title=\"创业者对创业机会的洞察\"></a>创业者对创业机会的洞察</h3>\n      <ol>\n<li>现有市场机会与潜在市场机会</li>\n<li>行业市场机会与边缘市场机会</li>\n<li>目前市场机会与外来市场机会</li>\n<li>全面市场机会与局部市场机会</li>\n</ol>\n\n        <h2 id=\"沟通能力\"   >\n          <a href=\"#沟通能力\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#沟通能力\" class=\"headerlink\" title=\"沟通能力\"></a>沟通能力</h2>\n      \n        <h3 id=\"沟通的含义\"   >\n          <a href=\"#沟通的含义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#沟通的含义\" class=\"headerlink\" title=\"沟通的含义\"></a>沟通的含义</h3>\n      <p>沟通是信息凭借一定符号载体，从发送者到接受者进行传递，并获取理解的过程。</p>\n\n        <h3 id=\"创业者具备沟通能力的意义\"   >\n          <a href=\"#创业者具备沟通能力的意义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业者具备沟通能力的意义\" class=\"headerlink\" title=\"创业者具备沟通能力的意义\"></a>创业者具备沟通能力的意义</h3>\n      <ol>\n<li>良好的沟通有助于提升创业团队洞察力</li>\n<li>良好的沟通有助于协调外部资源</li>\n<li>良好的沟通有助于拓展业务渠道</li>\n</ol>\n\n        <h3 id=\"创业者提升沟通能力的技巧\"   >\n          <a href=\"#创业者提升沟通能力的技巧\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业者提升沟通能力的技巧\" class=\"headerlink\" title=\"创业者提升沟通能力的技巧\"></a>创业者提升沟通能力的技巧</h3>\n      <ol>\n<li>倾听技巧<ul>\n<li>聚精会神聆听</li>\n<li>注视眼睛</li>\n<li>无打断</li>\n<li>换位</li>\n<li>提问</li>\n<li>等待思考后的回答</li>\n</ul>\n</li>\n<li>提问技巧<ul>\n<li>因人设问</li>\n<li>顺势而变</li>\n<li>善用开放式提问</li>\n<li>善用封闭式提问</li>\n</ul>\n</li>\n<li>表达技巧</li>\n<li>非语言技巧</li>\n</ol>\n\n        <h1 id=\"第五单元\"   >\n          <a href=\"#第五单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第五单元\" class=\"headerlink\" title=\"第五单元\"></a>第五单元</h1>\n      \n        <h2 id=\"团队组建能力\"   >\n          <a href=\"#团队组建能力\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#团队组建能力\" class=\"headerlink\" title=\"团队组建能力\"></a>团队组建能力</h2>\n      \n        <h3 id=\"团队的涵义\"   >\n          <a href=\"#团队的涵义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#团队的涵义\" class=\"headerlink\" title=\"团队的涵义\"></a>团队的涵义</h3>\n      <p>团队就是由两个或两个以上、相互作用、相互依赖的个体，为了特定目标而按照一定规则结合在一起的组织。</p>\n<p>创业团队：有着共同目标、共享创业收益、共同承担创业风险的一群创建新事业的人构成的组织。</p>\n\n        <h3 id=\"创业团队的类型\"   >\n          <a href=\"#创业团队的类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业团队的类型\" class=\"headerlink\" title=\"创业团队的类型\"></a>创业团队的类型</h3>\n      <ul>\n<li>网状创业团队</li>\n<li>星状创业团队</li>\n<li>虚拟星状创业团队</li>\n</ul>\n\n        <h3 id=\"创业团队组建的方式\"   >\n          <a href=\"#创业团队组建的方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业团队组建的方式\" class=\"headerlink\" title=\"创业团队组建的方式\"></a>创业团队组建的方式</h3>\n      <ol>\n<li>明确团队职位</li>\n<li>明确职位要求</li>\n<li>选聘人才</li>\n</ol>\n\n        <h3 id=\"创业团队组建的原则\"   >\n          <a href=\"#创业团队组建的原则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创业团队组建的原则\" class=\"headerlink\" title=\"创业团队组建的原则\"></a>创业团队组建的原则</h3>\n      <ol>\n<li>坚定信念，目标一致</li>\n<li>互补搭配，协调统一</li>\n<li>权责明确，形成核心</li>\n</ol>\n\n        <h2 id=\"领导力\"   >\n          <a href=\"#领导力\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#领导力\" class=\"headerlink\" title=\"领导力\"></a>领导力</h2>\n      \n        <h1 id=\"第六单元\"   >\n          <a href=\"#第六单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第六单元\" class=\"headerlink\" title=\"第六单元\"></a>第六单元</h1>\n      \n        <h2 id=\"执行力\"   >\n          <a href=\"#执行力\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#执行力\" class=\"headerlink\" title=\"执行力\"></a>执行力</h2>\n      ","categories":["课堂笔记"],"tags":["课堂笔记"]},{"title":"C++","url":"/notebooks-c/","content":"\n        <h1 id=\"第1单元-初识C\"   >\n          <a href=\"#第1单元-初识C\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第1单元-初识C\" class=\"headerlink\" title=\"第1单元 初识C++\"></a>第1单元 初识C++</h1>\n      \n        <h2 id=\"1-1-C-简介\"   >\n          <a href=\"#1-1-C-简介\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-C-简介\" class=\"headerlink\" title=\"1.1 C++简介\"></a>1.1 C++简介</h2>\n      \n        <h3 id=\"1-1-1-C-的发展简史\"   >\n          <a href=\"#1-1-1-C-的发展简史\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-1-C-的发展简史\" class=\"headerlink\" title=\"1.1.1 C++的发展简史\"></a>1.1.1 C++的发展简史</h3>\n      \n        <h4 id=\"1-1-1-1-课程介绍\"   >\n          <a href=\"#1-1-1-1-课程介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-1-1-课程介绍\" class=\"headerlink\" title=\"1.1.1.1 课程介绍\"></a>1.1.1.1 课程介绍</h4>\n      \n        <h5 id=\"书籍介绍\"   >\n          <a href=\"#书籍介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#书籍介绍\" class=\"headerlink\" title=\"书籍介绍\"></a>书籍介绍</h5>\n      <ul>\n<li>C++ Prime </li>\n<li>大话数据结构</li>\n</ul>\n\n        <h4 id=\"1-1-1-2-编程环境\"   >\n          <a href=\"#1-1-1-2-编程环境\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-1-2-编程环境\" class=\"headerlink\" title=\"1.1.1.2 编程环境\"></a>1.1.1.2 编程环境</h4>\n      <p>推荐使用Visual Studio 2019 </p>\n<p>不过我用的是VS Code</p>\n\n        <h4 id=\"1-1-1-3-C-发展史\"   >\n          <a href=\"#1-1-1-3-C-发展史\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-1-3-C-发展史\" class=\"headerlink\" title=\"1.1.1.3 C++发展史\"></a>1.1.1.3 C++发展史</h4>\n      <p>前期的阶段老师没讲</p>\n\n        <h5 id=\"重要的C-版本\"   >\n          <a href=\"#重要的C-版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重要的C-版本\" class=\"headerlink\" title=\"重要的C++版本\"></a>重要的C++版本</h5>\n      <ul>\n<li>C++98</li>\n<li>C++11</li>\n<li>C++20</li>\n</ul>\n<p>我们学的是C++11版本的</p>\n<p>同时编译器使用的是2019版本的，因为编译器往往需要过两年才能适配新版本的语法。</p>\n\n        <h5 id=\"C-的主要用途\"   >\n          <a href=\"#C-的主要用途\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-的主要用途\" class=\"headerlink\" title=\"C++的主要用途\"></a>C++的主要用途</h5>\n      <ul>\n<li>服务器端编程</li>\n<li>算法设计</li>\n<li>通过Qt进行Linux、国产化操作系统的桌面应用程序开发，自主可控的软件开发。</li>\n</ul>\n\n        <h3 id=\"1-1-2-C-的特点\"   >\n          <a href=\"#1-1-2-C-的特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-2-C-的特点\" class=\"headerlink\" title=\"1.1.2 C++的特点\"></a>1.1.2 C++的特点</h3>\n      \n        <h4 id=\"1-1-2-1支持四种编程范式\"   >\n          <a href=\"#1-1-2-1支持四种编程范式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-2-1支持四种编程范式\" class=\"headerlink\" title=\"1.1.2.1支持四种编程范式\"></a>1.1.2.1支持四种编程范式</h4>\n      <p>Java号称是纯面向对象的语言，他的main封装在class类里面。</p>\n<p>四种编程范式：面向过程、面向对象、泛型编程、函数式编程</p>\n<ul>\n<li>面向过程<ul>\n<li>瀑布式开发模型<ul>\n<li>其实就是正常的程序流程构设</li>\n<li>非常理想化，没有考虑在实际开发过程中可能产生的需求变化和将来的软件升级。</li>\n<li>在软件开发过程中唯一不变的是变化！</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>面向对象，OOP(Object-Oriented Programming)<ul>\n<li>三个基本特征：封装、继承、多态</li>\n</ul>\n</li>\n<li>泛型编程 <ul>\n<li>与类型无关的编程，是通过模板实现的。以模板为基础，STL实现通用的容器类。</li>\n<li>感觉上就是调用库。</li>\n</ul>\n</li>\n<li>函数式编程</li>\n</ul>\n\n        <h4 id=\"1-1-2-2-适合编写大型应用程序\"   >\n          <a href=\"#1-1-2-2-适合编写大型应用程序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-2-2-适合编写大型应用程序\" class=\"headerlink\" title=\"1.1.2.2 适合编写大型应用程序\"></a>1.1.2.2 适合编写大型应用程序</h4>\n      <ol>\n<li>不适合编写操作系统，操作系统的内核还是由C语言完成的。</li>\n<li>C++的一些语法设计，考虑了很多人同时开发，例如命名空间namespace。</li>\n<li>面向对象程序设计（OOP），根本上解决了需求发生变化、软件升级的问题</li>\n</ol>\n\n        <h4 id=\"1-1-2-3-可复用、可扩充、可维护和灵活性好\"   >\n          <a href=\"#1-1-2-3-可复用、可扩充、可维护和灵活性好\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-2-3-可复用、可扩充、可维护和灵活性好\" class=\"headerlink\" title=\"1.1.2.3 可复用、可扩充、可维护和灵活性好\"></a>1.1.2.3 可复用、可扩充、可维护和灵活性好</h4>\n      \n        <h4 id=\"1-1-2-4-C-的缺点\"   >\n          <a href=\"#1-1-2-4-C-的缺点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-2-4-C-的缺点\" class=\"headerlink\" title=\"1.1.2.4 C++的缺点\"></a>1.1.2.4 C++的缺点</h4>\n      <ul>\n<li>C++的强大在于提供高级抽象的同时又不放弃对程序的细节控制。</li>\n<li>过于频繁的更换，除了增加功能以外，也使得C++变得越来越复杂。苦了人脑，幸福电脑。</li>\n</ul>\n\n        <h2 id=\"1-2-第一个C-程序\"   >\n          <a href=\"#1-2-第一个C-程序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-2-第一个C-程序\" class=\"headerlink\" title=\"1.2 第一个C++程序\"></a>1.2 第一个C++程序</h2>\n      \n        <h3 id=\"1-2-1-Hello-World\"   >\n          <a href=\"#1-2-1-Hello-World\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-2-1-Hello-World\" class=\"headerlink\" title=\"1.2.1 Hello World\"></a>1.2.1 Hello World</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;<span class=\"string\">&quot;Hello World!\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"1-2-1-1-C-与C的不同\"   >\n          <a href=\"#1-2-1-1-C-与C的不同\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-2-1-1-C-与C的不同\" class=\"headerlink\" title=\"1.2.1.1 C++与C的不同\"></a>1.2.1.1 C++与C的不同</h4>\n      <ol>\n<li>头文件没有后缀名</li>\n<li>C++兼容C，可以在C语言头文件名称前加上<strong>c</strong>后去除后缀名进行引用。</li>\n<li>基本输出不同</li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;Hello,World!\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//std::cout是标准命名空间中定义、ostream类型的全局变量，代表显示器。</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>std是标准命名空间（standard）</li>\n<li>::是域操作符（相当于的）</li>\n<li>cout是控制台输出设备</li>\n<li>&lt;&lt;是输出运算符</li>\n</ul>\n\n        <h2 id=\"1-3-C-对C语言的扩充\"   >\n          <a href=\"#1-3-C-对C语言的扩充\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-C-对C语言的扩充\" class=\"headerlink\" title=\"1.3 C++对C语言的扩充\"></a>1.3 C++对C语言的扩充</h2>\n      \n        <h3 id=\"1-3-1-命名空间\"   >\n          <a href=\"#1-3-1-命名空间\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-1-命名空间\" class=\"headerlink\" title=\"1.3.1 命名空间\"></a>1.3.1 命名空间</h3>\n      <p>为了解决合作开发时命名冲突的问题，C++引用了命名空间。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Li&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printInt</span><span class=\"params\">()</span></span>&#123;std::cout &lt;&lt; a &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//endl是标准命名空间定义的换行符</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Han&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printInt</span><span class=\"params\">()</span></span>&#123;std::cout &lt;&lt; a &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>在不同的namespace中可以重复定义相同的函数或相同的变量。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Han::a = <span class=\"number\">300</span>;</span><br><span class=\"line\">    Li::<span class=\"built_in\">printInt</span>();<span class=\"comment\">//输出100</span></span><br><span class=\"line\">    Han::<span class=\"built_in\">printInt</span>();<span class=\"comment\">//输出300</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"1-3-1-1-命名空间简写方法\"   >\n          <a href=\"#1-3-1-1-命名空间简写方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-1-1-命名空间简写方法\" class=\"headerlink\" title=\"1.3.1.1 命名空间简写方法\"></a>1.3.1.1 命名空间简写方法</h4>\n      <ol>\n<li>使用 <strong>::</strong> 引用命名空间中定义的元素<br><code>std::cout &lt;&lt; &quot;C++&quot; &lt;&lt; std::endl;</code></li>\n<li>使用using引用命名空间中的某个元素</li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;C++&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"3\">\n<li>使用using引用命名空间<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;C++&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></div></figure></li>\n</ol>\n\n        <h3 id=\"1-3-2-控制台输入输出\"   >\n          <a href=\"#1-3-2-控制台输入输出\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-2-控制台输入输出\" class=\"headerlink\" title=\"1.3.2  控制台输入输出\"></a>1.3.2  控制台输入输出</h3>\n      \n        <h4 id=\"C-的I-O解决方案\"   >\n          <a href=\"#C-的I-O解决方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-的I-O解决方案\" class=\"headerlink\" title=\"C++的I/O解决方案\"></a>C++的I/O解决方案</h4>\n      <ul>\n<li>使用 <strong>cin</strong> 接收从键盘输入的数据，用 <strong>cout</strong> 向屏幕上输出数据（这2个过程又称为“标准I/O”）。</li>\n<li>C++也对从文件中读取数据和向文件中写入数据做了支持（统称为“文件I/O”）。</li>\n</ul>\n\n        <h4 id=\"C-标准库中包含了“流类”\"   >\n          <a href=\"#C-标准库中包含了“流类”\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-标准库中包含了“流类”\" class=\"headerlink\" title=\"C++标准库中包含了“流类”\"></a>C++标准库中包含了“流类”</h4>\n      <ul>\n<li>istream：常用语接收从键盘输入的数据；</li>\n<li>ostream：常用语将数据输出到屏幕上；</li>\n<li>ifstream： 用于读取文件中的数据；</li>\n<li>ofstream： 继承自istream和ostream类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出；</li>\n<li>fstream：兼ifstream和ofstream类功能于一身，既能读取文件中的数据，又能向文件中写入数据。</li>\n<li>cin是istream类的对象，cout是ostream类的对象，在<iostream>头文件中声明。</li>\n<li>使用cin和cout需要包含<iostream>头文件，当然还需要使用std命名空间。</li>\n</ul>\n\n        <h4 id=\"输入\"   >\n          <a href=\"#输入\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h4>\n      <ul>\n<li>输入流对象cin和输入运算符&gt;&gt;配合，用于用户输入</li>\n<li>在连续输入多个变量时，以空白(空格、回车、制表符)为分隔符</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\"><span class=\"comment\">//如果是字符型的话，分隔符会被识别成数据。</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"输出\"   >\n          <a href=\"#输出\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h4>\n      <ul>\n<li>输出对象cout和输出运算符&lt;&lt;配合，用于用户输出</li>\n<li>可以连续输出多个不同类型的常量或变量</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;Hello,C++&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"comment\">//注意流的方向，要指向cout</span></span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li><strong>两个运算符都是从左向右结合</strong></li>\n<li>cin&gt;&gt;a的返回值时cin,cout&gt;&gt;”Hello,C++”的返回值是cout。所以可以连续执行。</li>\n</ol>\n\n        <h4 id=\"小例子\"   >\n          <a href=\"#小例子\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小例子\" class=\"headerlink\" title=\"小例子\"></a>小例子</h4>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>,b=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Please Enter Two Integers:&quot;</span></span><br><span class=\"line\">    cin &gt;&gt;a &gt;&gt; b;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; <span class=\"string\">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class=\"string\">&quot;=&quot;</span> &lt;&lt; a+b &lt;&lt;endl; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>C语言中的<code>scanf</code>是不安全的函数，如果要使用需要<code>#define _CRT_SECURE_NO_WARNINGS</code></p>\n\n        <h3 id=\"1-3-3-增强类型\"   >\n          <a href=\"#1-3-3-增强类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-3-增强类型\" class=\"headerlink\" title=\"1.3.3 增强类型\"></a>1.3.3 增强类型</h3>\n      <ol>\n<li>const常变量</li>\n<li>bool布尔类型</li>\n<li>enum枚举类型</li>\n</ol>\n\n        <h4 id=\"1-3-3-1-const的基本概念\"   >\n          <a href=\"#1-3-3-1-const的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-3-1-const的基本概念\" class=\"headerlink\" title=\"1.3.3.1 const的基本概念\"></a>1.3.3.1 const的基本概念</h4>\n      <ul>\n<li>定义只读变量的关键字</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//const的量一定要赋值进行初始化</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * pa = &amp;a;</span><br><span class=\"line\"> <span class=\"comment\">//const int * 类型的值不能用于初始化int*类型的实体</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>在C语言中const变量不能定义数组长度，但是在C++中可以。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[size];</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"1-3-3-2-const与指针\"   >\n          <a href=\"#1-3-3-2-const与指针\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-3-2-const与指针\" class=\"headerlink\" title=\"1.3.3.2 const与指针\"></a>1.3.3.2 const与指针</h4>\n      <ul>\n<li>指向<code>常量</code>的指针，称为<strong>常量指针</strong>。<ul>\n<li>解释：所指的量是一个常量。</li>\n<li>int * const p</li>\n<li>当使用是形参时，传入变量地址就可以。</li>\n</ul>\n</li>\n<li><code>不能指向其他变量</code>的指针，称为<strong>指针常量</strong>。<ul>\n<li>const int * p;</li>\n<li>int const * p;</li>\n<li>解释：只能指向某一量，设定后无法更改。</li>\n<li>数组就是<strong>指针常量</strong></li>\n</ul>\n</li>\n<li>指向整型常量的指针常量。<ul>\n<li>const int * const p;</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"1-3-3-布尔类型\"   >\n          <a href=\"#1-3-3-布尔类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-3-布尔类型\" class=\"headerlink\" title=\"1.3.3 布尔类型\"></a>1.3.3 布尔类型</h3>\n      <p>在C语言的C99版本中可以引用&lt;stdbool.h&gt;来使用bool类型</p>\n<ul>\n<li>enum</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SEASON</span>&#123;</span>SPRIG,SUMMER,AUTUMN,WINTER&#125;;</span><br><span class=\"line\">SEASON s1 = SUMMER；</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"1-3-4-参数默认值\"   >\n          <a href=\"#1-3-4-参数默认值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-4-参数默认值\" class=\"headerlink\" title=\"1.3.4 参数默认值\"></a>1.3.4 参数默认值</h3>\n      <p>直接在形参中初始化</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y=<span class=\"number\">1</span>,<span class=\"keyword\">int</span> z=<span class=\"number\">2</span>)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;x+y+z&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">add</span>(<span class=\"number\">1</span>);     <span class=\"comment\">//4</span></span><br><span class=\"line\">    <span class=\"built_in\">add</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);   <span class=\"comment\">//5</span></span><br><span class=\"line\">    <span class=\"built_in\">add</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">//6</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li>参数默认值可在函数声明中出现一次，如果没有函数声明，只有函数定义，那么可以在函数定义中设定</li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//fun.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b=<span class=\"number\">1</span>,<span class=\"keyword\">int</span> c=<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//fun.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b+c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li>默认参数赋值的顺序时自右向左</li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b=<span class=\"number\">0</span>,<span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//这种是错的</span></span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"1-3-5-函数重载\"   >\n          <a href=\"#1-3-5-函数重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-5-函数重载\" class=\"headerlink\" title=\"1.3.5 函数重载\"></a>1.3.5 函数重载</h3>\n      <ul>\n<li>所谓函数重载，是指在同一个作用域内、函数名相同、参数列表不同的多个函数。</li>\n<li>编译器会根据所给的参数自动选择相应的函数。</li>\n<li>参数列表不同：<ol>\n<li>参数类型不同</li>\n<li>参数个数不同</li>\n<li>参数类型、个数均不同</li>\n</ol>\n<ul>\n<li><strong>形参变量名不同不构成重载！</strong></li>\n</ul>\n</li>\n<li>当重载函数有默认值时，要防止二义性！<ul>\n<li>两个同名函数之间，只差若干个默认值，当未指定默认值时，程序就不知道使用哪个函数了。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"1-3-6-引用\"   >\n          <a href=\"#1-3-6-引用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-6-引用\" class=\"headerlink\" title=\"1.3.6 引用\"></a>1.3.6 引用</h3>\n      \n        <h4 id=\"1-3-6-1-引用的基本概念\"   >\n          <a href=\"#1-3-6-1-引用的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-6-1-引用的基本概念\" class=\"headerlink\" title=\"1.3.6.1 引用的基本概念\"></a>1.3.6.1 引用的基本概念</h4>\n      <ul>\n<li>引用就是给变量取的一个别名</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ra = a;</span><br><span class=\"line\">ra = <span class=\"number\">200</span>;</span><br><span class=\"line\">cout&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>引用的语法<ul>\n<li>类型 &amp; 引用名 = 变量名；</li>\n</ul>\n</li>\n<li>&amp;的含义<ol>\n<li>int &amp; ra = a;    在定义变量的时候使用&amp;，表示引用</li>\n<li>int *p;p=&a;     一元操作，表示取地址</li>\n<li>a &amp; b;           二元运算符，表示运算中的按位与</li>\n<li>a &amp;&amp; b;            表示逻辑与</li>\n</ol>\n</li>\n<li>使用引用的注意事项<ol>\n<li>引用必须初始化</li>\n<li>不能引用常量</li>\n<li>不能引用数组</li>\n<li>引用只能时某个固定变量的引用，不能再引用其他变量。</li>\n</ol>\n</li>\n<li>没必要在一个函数内使用引用，通常在两个函数之间使用引用<ul>\n<li>形参是引用<ul>\n<li>在C语言中，函数参数的两种形式<ul>\n<li>传值</li>\n<li>传地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>返回值是引用</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"1-3-6-2-函数参数的三种形式\"   >\n          <a href=\"#1-3-6-2-函数参数的三种形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-6-2-函数参数的三种形式\" class=\"headerlink\" title=\"1.3.6.2 函数参数的三种形式\"></a>1.3.6.2 函数参数的三种形式</h4>\n      \n        <h5 id=\"1-传值\"   >\n          <a href=\"#1-传值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-传值\" class=\"headerlink\" title=\"1. 传值\"></a>1. 传值</h5>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Swap1</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;<span class=\"keyword\">int</span> temp=x;x=y;y=temp&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">100</span>,b=<span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap1</span>(a,b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>传值，子函数无法改变调用函数中变量的值。</li>\n<li>每个函数的一次运行都会有一个自动分配的栈，局部变量位于栈中。形参也是局部变量。</li>\n</ul>\n<p>函数每一次运行都会有一个独立的栈，用来存放局部变量。这就导致了<code>主函数</code>和<code>自定义函数</code>中分别定义的变量不互通，主函数传入变量的时候仅仅传入了值，而非变量本身。</p>\n\n        <h5 id=\"2-传地址\"   >\n          <a href=\"#2-传地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-传地址\" class=\"headerlink\" title=\"2. 传地址\"></a>2. 传地址</h5>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Swap2</span><span class=\"params\">(<span class=\"keyword\">int</span> *p,inty *q)</span></span>&#123;<span class=\"keyword\">int</span> temp=*p;*p=*q;*q=temp;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">100</span>,b=<span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap2</span>(&amp;a,&amp;b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>传地址，子函数可以修改调用函数中变量的值</li>\n<li>下面是比较常见的初学者的错误写法</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Swap3</span>(<span class=\"keyword\">int</span> *p,<span class=\"keyword\">int</span> *q)&#123;<span class=\"keyword\">int</span> *temp=p;p=q;q=temp;&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这种方式直接传输地址，使得不同函数可以直接读取或写入<code>其他函数栈</code>中<code>相应地址</code>的<code>变量</code>。</p>\n\n        <h5 id=\"3-传引用\"   >\n          <a href=\"#3-传引用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-传引用\" class=\"headerlink\" title=\"3. 传引用\"></a>3. 传引用</h5>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Swap4</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x,<span class=\"keyword\">int</span> &amp;y)</span></span>&#123;<span class=\"keyword\">int</span> temp=x;x=y;y=temp&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">100</span>,b=<span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap4</span>(a,b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>传引用，可以达到传指针同样的效果，但是调用更方便。</li>\n<li>与传地址不同的地方就是函数定义不是<code>*x</code>了，而是<code>&amp;x</code>，这样传入的可以直接传入变量</li>\n<li>个人理解：直接将传入函数<code>命名别名</code>后，在函数中进行使用。</li>\n<li>尽管在形参中没有认为进行初始化，但是<code>从形参到实参的过程就是初始化！</code></li>\n</ul>\n\n        <h4 id=\"1-3-6-3-引用——函数的返回值\"   >\n          <a href=\"#1-3-6-3-引用——函数的返回值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-6-3-引用——函数的返回值\" class=\"headerlink\" title=\"1.3.6.3 引用——函数的返回值\"></a>1.3.6.3 引用——函数的返回值</h4>\n      <p>不会在一个函数内部使用引用，引用仅应用于两个函数之间</p>\n<ol>\n<li>函数参数是引用类型</li>\n<li>函数的返回值是引用</li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> &amp; <span class=\"title\">At</span><span class=\"params\">(<span class=\"keyword\">int</span> b[],<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b[index];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">At</span>(a,<span class=\"number\">1</span>) = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">//b[index]等价于a[1]</span></span><br><span class=\"line\">    <span class=\"comment\">//等价于a[1] = 100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>也就是说，可以让<code>函数调用作为左值</code>。</li>\n<li>可以避免返回值被拷贝</li>\n<li>注意：不能返回局部变量的引用<ul>\n<li>因为局部变量存在函数的栈中，函数一旦运行结束，栈会被释放清空，那么这个数据就不存在了。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"1-3-6-4-引用——常引用\"   >\n          <a href=\"#1-3-6-4-引用——常引用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-6-4-引用——常引用\" class=\"headerlink\" title=\"1.3.6.4 引用——常引用\"></a>1.3.6.4 引用——常引用</h4>\n      <ul>\n<li>int &amp; a=b;a就是b。</li>\n<li>针对引用类型的函数参数，形参就是实参。这带来两种用途：<ol>\n<li>子函数可以通过引用类型的参数来修改调用函数中的变量，并且不用使用指针（都不喜欢指针，能不用尽量不用）。</li>\n<li>避免了形参到实参的初始化过程，从而提高了效率。</li>\n</ol>\n</li>\n<li>如果只想2，而不想1，可以使用<code>常引用</code><figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">const</span> XYZ &amp; r)</span></span>&#123;……&#125;</span><br></pre></td></tr></table></div></figure></li>\n<li>在面向对象编程中，类类型属于自定义类型，比简单类型占用更多的内存空间。如果函数的参数类型是类类型，为了提高效率，我们往往使用常引用。</li>\n</ul>\n\n        <h3 id=\"1-3-7-内存管理——堆、栈\"   >\n          <a href=\"#1-3-7-内存管理——堆、栈\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-7-内存管理——堆、栈\" class=\"headerlink\" title=\"1.3.7 内存管理——堆、栈\"></a>1.3.7 内存管理——堆、栈</h3>\n      <ul>\n<li>不是数据结构中的堆和栈</li>\n</ul>\n<ol>\n<li>C语言的内存区域<ul>\n<li>堆<ul>\n<li>堆是用于存放进程运行中被动态分配的<code>内存段</code>。当进程调用<code>malloc/free</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被剔除（堆被缩减）。</li>\n</ul>\n</li>\n<li>栈<ul>\n<li>栈又称堆栈，存放<code>程序的局部变量</code>(但不包括static声明的变量)和<code>函数被调用时的参数和返回值</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>从低位地址到高位地址逐个是：</p>\n<ol>\n<li>代码区：函数代码块的二进制代码。</li>\n<li>数据区</li>\n<li>文字常量区：常量字符串存放于此</li>\n<li>未初始化静态变量区：没有初始化的全局变量和静态变量</li>\n<li>已初始化的静态变量区：初始化的全局变量和静态变量</li>\n<li>堆区：动态分配的数据</li>\n<li>栈区：局部变量存放于此</li>\n<li>命令行参数区：命令行参数和局部变量</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li> C++内存区域</li>\n</ol>\n<ul>\n<li>C++中内存分成5个区：<ol>\n<li>栈：内存由编译器在需要时<code>自动</code>分配和释放。通常用来存储局部变量和函数参数。（为运行函数而分配的局部变量、函数参数、返回地址等存放在<code>栈区</code>）</li>\n<li>堆：内存使用<code>new</code>进行分配，使用<code>delete</code>释放。如果未能对内存进行正确的释放，会造成<code>内存泄漏</code>。</li>\n<li>自由存储区：使用<code>malloc</code>进行分配，使用<code>free</code>进行回收。</li>\n<li>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。(全局变量、静态数据、常量存放在<code>全局数据区</code>)</li>\n<li>常量存储区：存储常量，不允许被修改。</li>\n</ol>\n</li>\n<li>栈和堆的对比<ul>\n<li>栈<ol>\n<li>内个函数的第一次运行都会有一个独立的栈</li>\n<li>自动分配、自动释放</li>\n<li>通过变量直接使用</li>\n</ol>\n</li>\n<li>堆<ol>\n<li>全局只有一个堆</li>\n<li>手动分配、手动释放</li>\n<li>通过指针间接使用</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">&#125;<span class=\"comment\">//函数运行结束，栈被自动释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//运行了两次，有两个栈，栈中的a都为1</span></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> * p =<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这里*p是局部变量，存在栈中。同时堆中开辟了一块int类型大小的空间。</span></span><br><span class=\"line\">    *p = <span class=\"number\">100</span>;<span class=\"comment\">//p指向的内存单元为100，也就是堆中相应内存单元为100.</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    <span class=\"comment\">//将堆中数据回收，但*p还在，仍然指向堆中的那个地址，称为“野指针”</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"1-3-8-new-delete\"   >\n          <a href=\"#1-3-8-new-delete\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-8-new-delete\" class=\"headerlink\" title=\"1.3.8 new/delete\"></a>1.3.8 new/delete</h3>\n      <ul>\n<li><p>在C语言中，动态分配内存用<code>malloc()</code>函数，释放内存用<code>free()</code>函数。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>));<span class=\"comment\">//分配一个int型的内存空间</span></span><br><span class=\"line\"><span class=\"comment\">//将int大小的空间分配给p并将无类型的p进行强制类型转换</span></span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);<span class=\"comment\">//释放内存</span></span><br><span class=\"line\"><span class=\"comment\">//分配在堆中</span></span><br></pre></td></tr></table></div></figure></li>\n<li><p>C++新增了两个关键字，使用起来更简介</p>\n<ul>\n<li><code>new</code>用来动态分配内存<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;<span class=\"comment\">//分配一个int型的内存空间</span></span><br></pre></td></tr></table></div></figure></li>\n<li>delete用来释放内存<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> p;</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>根据后面的数据类型来<code>自动推断所需空间大小</code></li>\n<li>返回具体类型的指针，不需要进行类型转换</li>\n</ol>\n<ul>\n<li><p>分配一组连续的数据（动态数组）</p>\n<ul>\n<li>C语言版本<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);</span><br></pre></td></tr></table></div></figure></li>\n<li>版本<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">delete</span> []p;</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n</li>\n<li><p>new/delete的优点</p>\n<ul>\n<li><code>new</code>可以自动推断所需空间大小，而<code>malloc</code>需要通过<code>sizeof</code>进行计算。</li>\n<li><code>new</code>自动返回所需类型指针，而<code>malloc</code>返回的是<code>void *</code>，还需要类型转换</li>\n<li><code>new</code>在分配空间的同时还可以初始化，而<code>malloc</code>只能分配空间<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">//将p初始化为100</span></span><br></pre></td></tr></table></div></figure></li>\n<li>我们可以笼统的说<code>new</code>和<code>malloc</code>都是在<code>堆</code>中分配内存，但仍然有差别，所以<code>new/delete</code>和<code>malloc/free</code>不能混用。</li>\n<li><code>new/delete</code>支持C++的新特性，包括：重载、调用构造/析构函数。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"1-3-8-静态数组、动态数组\"   >\n          <a href=\"#1-3-8-静态数组、动态数组\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-8-静态数组、动态数组\" class=\"headerlink\" title=\"1.3.8 静态数组、动态数组\"></a>1.3.8 静态数组、动态数组</h3>\n      <ul>\n<li>静态数组<figure class=\"highlight c\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">100</span>;<span class=\"comment\">//SIZE是常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[SIZE]; <span class=\"comment\">// 定义数组时，数组的大小必须是常量</span></span><br></pre></td></tr></table></div></figure></li>\n<li>动态数组<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> size = <span class=\"number\">100</span>;<span class=\"comment\">//size是变量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size];<span class=\"comment\">//可以在内存中分配任意大小的内存</span></span><br></pre></td></tr></table></div></figure></li>\n<li>指针p和数组名a都指向内存中一段内存的首地址，且用法都是一样的<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">*(a+<span class=\"number\">10</span>)=<span class=\"number\">123</span>;</span><br><span class=\"line\">p[<span class=\"number\">10</span>]=<span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"comment\">//相互等价</span></span><br></pre></td></tr></table></div></figure></li>\n<li>差别在于，a是<code>指针常量</code>，p是<code>指针变量</code>,<code>p++</code>可以，<code>a++</code>不行。</li>\n</ul>\n\n        <h3 id=\"1-3-9-各种指针和指针数组\"   >\n          <a href=\"#1-3-9-各种指针和指针数组\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-9-各种指针和指针数组\" class=\"headerlink\" title=\"1.3.9 各种指针和指针数组\"></a>1.3.9 各种指针和指针数组</h3>\n      <p>因为指针的存在，所以C/C++的程序可以直接访问内存，从而提高程序的运行速度。</p>\n<p>在大型程序中，核心数据不可能存放在栈中，一定是存放在堆中，所以只有通过指针进行访问。换言之，<strong>核心数据一定是<code>new</code>出来的</strong>！</p>\n<ul>\n<li>在开发的过程中，能不用指针运算，尽量不用指针运算。<ul>\n<li>使用下标运算，而不是用<code>*</code>运算，例如：<code>*(P+1)等价于p[i]</code>，不过<code>*p</code>比<code>p[0]</code>好看一些。</li>\n<li>能够使用引用，尽量使用引用，例如：通过指针和引用都可以实现交换函数，<code>swap(&amp;a,&amp;b)</code>肯定不如<code>swap(a,b)</code>。</li>\n</ul>\n</li>\n</ul>\n<p>struct和class中指针类型的成员变量，习惯上不会使用引用，而是指针</p>\n\n        <h4 id=\"各种指针\"   >\n          <a href=\"#各种指针\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#各种指针\" class=\"headerlink\" title=\"各种指针\"></a>各种指针</h4>\n      <ol>\n<li>指针和const组合：<ul>\n<li>常量指针：指向常量的指针</li>\n<li>指针常量：<code>int a[100]</code>;</li>\n</ul>\n</li>\n<li>指针和数组结合：<ul>\n<li>指向数组的指针：<code>int *p = a</code></li>\n<li>指针数组：数组的每一个元素都是指针。<ul>\n<li><code>int *a[100]</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指针的指针：<ul>\n<li>指针和自己结合，<code>int **p</code></li>\n<li>不仅仅数组名是指针常量，函数名也是指针常量<ul>\n<li>通过函数指针，C语言也能做到面向对象</li>\n<li>函数指针-&gt;仿函数-&gt;Lambda表达式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"1-4-C-中的两个新语法\"   >\n          <a href=\"#1-4-C-中的两个新语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-4-C-中的两个新语法\" class=\"headerlink\" title=\"1.4 C++中的两个新语法\"></a>1.4 C++中的两个新语法</h2>\n      \n        <h3 id=\"1-4-1-nullptr——野指针\"   >\n          <a href=\"#1-4-1-nullptr——野指针\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-4-1-nullptr——野指针\" class=\"headerlink\" title=\"1.4.1 nullptr——野指针\"></a>1.4.1 nullptr——野指针</h3>\n      <p>野指针主要是因为这些疏忽而出现的删除或申请访问受限内存区域的指针。</p>\n<ol>\n<li>指针变量未初始化<ul>\n<li>任何指针变量刚被创建时不会自动称为空指针，它的缺省值是随机的，它会乱指一气。这个时候，通过指针访问内存就会出错。所以，指针变量在创建的同时应该被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li>\n</ul>\n</li>\n<li>指针释放后未置空<ul>\n<li>有时指针在free或delete后未赋值NULL，便会是人认为是合法的。他们只是吧指针所指的内存给释放掉，并没有吧指针本身干掉，此时指针指向的就是垃圾内存。释放后的指针应立即将指针归置为NULL，防止产生“野指针”。</li>\n</ul>\n</li>\n<li>指针操作超越变量作用域<ul>\n<li>在子函数中定义的局部变量指针，当函数运行结束后会被释放，此时再通过指针访问内存，就会报错。</li>\n</ul>\n</li>\n</ol>\n<p>不能将<code>nullptr</code>转换为int类型。</p>\n\n        <h3 id=\"1-4-2-基于范围的for循环\"   >\n          <a href=\"#1-4-2-基于范围的for循环\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-4-2-基于范围的for循环\" class=\"headerlink\" title=\"1.4.2 基于范围的for循环\"></a>1.4.2 基于范围的for循环</h3>\n      <p>类似于Python的for语法</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> v[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e:v)</span><br><span class=\"line\">    cout&lt;&lt;e&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> v[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)</span><br><span class=\"line\">    cout&lt;&lt;v[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"第2单元-类与对象\"   >\n          <a href=\"#第2单元-类与对象\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第2单元-类与对象\" class=\"headerlink\" title=\"第2单元 类与对象\"></a>第2单元 类与对象</h1>\n      \n        <h2 id=\"2-1-面向对象程序设计思想\"   >\n          <a href=\"#2-1-面向对象程序设计思想\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-面向对象程序设计思想\" class=\"headerlink\" title=\"2.1 面向对象程序设计思想\"></a>2.1 面向对象程序设计思想</h2>\n      \n        <h3 id=\"2-1-1-面向对象的编程思想\"   >\n          <a href=\"#2-1-1-面向对象的编程思想\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-1-面向对象的编程思想\" class=\"headerlink\" title=\"2.1.1 面向对象的编程思想\"></a>2.1.1 面向对象的编程思想</h3>\n      <p>对于<strong>面向对象</strong>程序设计而言，最重要的一个特征就是<strong>数据封装</strong>。</p>\n<p>所谓<strong>数据封装</strong>，就是通过类来实现信息的抽象和隐藏。学习了类的相关知识，才能真正走进面向程序设计的世界。</p>\n\n        <h4 id=\"面向过程程序设计\"   >\n          <a href=\"#面向过程程序设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#面向过程程序设计\" class=\"headerlink\" title=\"面向过程程序设计\"></a>面向过程程序设计</h4>\n      <p><strong>面向过程程序设计</strong>对于较为简单的需求通常能够很好地满足。如果<strong>问题比较复杂</strong>，在项目开始之初就完成模块的<strong>合理划分</strong>往往比较困难。当<strong>数据结构</strong>改变时，所有相关的<strong>处理过程</strong>都要进行相应的修改，程序的<strong>可用性极差</strong>。</p>\n<p>在程序中使用对象映射现实中的事物，利用对象之间的关系描述事物之间的联系，这种思想就是面向对象。</p>\n<p>Object-Oriented，简称OO。</p>\n<p>把构成问题的事物按照一定的规则划分为多个独立的对象，然后通过调用对象的方法解决问题。</p>\n<p>当应用程序功能发生变更时，只需要修改个别对象就可以了。</p>\n\n        <h4 id=\"面向对象程序设计思想\"   >\n          <a href=\"#面向对象程序设计思想\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#面向对象程序设计思想\" class=\"headerlink\" title=\"面向对象程序设计思想\"></a>面向对象程序设计思想</h4>\n      <ol>\n<li>分析(OOAnalyse)</li>\n<li>设计(OODesign)</li>\n<li>开发(OOProgramming)</li>\n<li>C++是一个面向对象的编程语言(OOPLanguage)</li>\n</ol>\n\n        <h4 id=\"概述\"   >\n          <a href=\"#概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4>\n      <p><strong>面向对象程序设计</strong>描述的是客观世界中的事物，以<strong>对象</strong>代表一个<strong>具体的事物</strong>，把<strong>数据和数据的操作方法</strong>放在一起而形成的一个<strong>相互依存</strong>又不可分割的整体。</p>\n<p>由此可见，<strong>面向对象程序设计</strong>所强调的基本原则就是<strong>直接面对客观存在的事实</strong>，将人们在日常生活中习惯的<strong>思维方式和思维表达式</strong>应用<strong>软件开发</strong>中，使<strong>软件开发</strong>从过分专业化的<strong>方法、规则</strong>中回到客观世界，回到人们通常的<strong>思维方式</strong>。<strong>面向对象</strong>的思想更适合用于<strong>大型系统项目</strong>的开发。</p>\n\n        <h3 id=\"2-1-2-面向对象的三大特征\"   >\n          <a href=\"#2-1-2-面向对象的三大特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-2-面向对象的三大特征\" class=\"headerlink\" title=\"2.1.2 面向对象的三大特征\"></a>2.1.2 面向对象的三大特征</h3>\n      \n        <h4 id=\"面向对象的三大特征\"   >\n          <a href=\"#面向对象的三大特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#面向对象的三大特征\" class=\"headerlink\" title=\"面向对象的三大特征\"></a>面向对象的三大特征</h4>\n      <p>三大特征具有承上启下的关系，而且适用于所有面向对象的编程语言。</p>\n<ul>\n<li>封装<ul>\n<li>封装就是隐藏。它将数据(属性)和数据处理过程(行为)封装成一个独立性很强的模块(类)。对外提供接口，不需要让外界知道具体的实现细节。</li>\n<li>不封装会有哪些问题？<ul>\n<li>容易因为传参错误出现逻辑错误。</li>\n<li>面向对象的程序设计过程中，数据和处理数据的函数封装在一个类中，不存在跨模块处理数据的问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>继承<ul>\n<li>继承描述的是父类和子类的关系。通过继承，子类可以扩展父类的功能，从而提高了代码的<strong>可重用性</strong>，降低了代码维护的难度。</li>\n<li>共同的功能写在父类中</li>\n<li>不同的功能写在子类中</li>\n</ul>\n</li>\n<li>多态<ul>\n<li>是指不同事物对统一信息产生的不同行为。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"2-2-初始类和对象\"   >\n          <a href=\"#2-2-初始类和对象\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-初始类和对象\" class=\"headerlink\" title=\"2.2 初始类和对象\"></a>2.2 初始类和对象</h2>\n      \n        <h3 id=\"2-2-1-类的定义\"   >\n          <a href=\"#2-2-1-类的定义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-1-类的定义\" class=\"headerlink\" title=\"2.2.1 类的定义\"></a>2.2.1 类的定义</h3>\n      <p>C++中的类(class)可以看做C语言中的结构体(struct)的升级版。</p>\n<p>结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的成员，只是他们的取值不一样。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> score;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot;今年&quot;</span> &lt;&lt; age &lt;&lt; <span class=\"string\">&quot;岁，&quot;</span>;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;考了&quot;</span> &lt;&lt; score &lt;&lt; <span class=\"string\">&quot;分&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Student s1;</span><br><span class=\"line\">    s1.name = <span class=\"string\">&quot;小明&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这里有问题，会在之后的章节里探讨</span></span><br><span class=\"line\">    sl.age = <span class=\"number\">15</span>;</span><br><span class=\"line\">    sl.score = <span class=\"number\">95</span>;</span><br><span class=\"line\">    sl.<span class=\"built_in\">Display</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li>关键字从<code>struct</code>变成了<code>class</code></li>\n<li>访问权限<code>public</code>表示共有，是为了可以从外部访问。</li>\n<li><code>Display</code>从全局函数变成了成员函数，也就是对象s1的成员函数，所以函数参数、函数中通过形参引用<code>name</code>等成员，都省略了</li>\n<li>Display(s1)写成了s1.Display();</li>\n</ol>\n\n        <h4 id=\"类的语法格式\"   >\n          <a href=\"#类的语法格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#类的语法格式\" class=\"headerlink\" title=\"类的语法格式\"></a>类的语法格式</h4>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    成员访问限定符:</span><br><span class=\"line\">        数据成员;</span><br><span class=\"line\">    成员访问限定符:</span><br><span class=\"line\">        成员函数;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>标识符的命名规范:</p>\n<ol>\n<li>只能包含字母、数字、下划线</li>\n<li>只能以字母、下划线开头</li>\n<li>不能是关键字</li>\n</ol>\n<p>限定访问规则：<br><code>puiblic &gt; protected &gt; private</code></p>\n<p>类是事物的抽象描述，若想定义类就需要抽象出事物的属性及方法。</p>\n\n        <h3 id=\"2-2-2-类外定义成员函数\"   >\n          <a href=\"#2-2-2-类外定义成员函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-2-类外定义成员函数\" class=\"headerlink\" title=\"2.2.2 类外定义成员函数\"></a>2.2.2 类外定义成员函数</h3>\n      <p>成员函数的函数体既可以写在类中，也可以类外实现。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Student.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Study</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Student.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Student.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Student::Stundy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;学习C++&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>Stundent.cpp -&gt; Stundent.lib,然后和Stundent.h一起发布供第三方调用</p>\n\n        <h1 id=\"第2次上课\"   >\n          <a href=\"#第2次上课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第2次上课\" class=\"headerlink\" title=\"第2次上课\"></a>第2次上课</h1>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\"><span class=\"comment\">//在Visual Studio中，*要跟int后面</span></span><br></pre></td></tr></table></div></figure>\n\n<p>一定要提防野指针，编译器无法识别！人工纠错非常的困难！</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\"><span class=\"comment\">//在堆中分配内存，新建栈中指针p并指向堆</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> p;</span><br><span class=\"line\"><span class=\"comment\">//回收堆中内存，但p的指向还在</span></span><br><span class=\"line\">*p = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"comment\">//编译器不会报错，运行的时候会随机报错，因为p指向的空间已经无法使用，无法写入数据！</span></span><br><span class=\"line\">p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\"><span class=\"comment\">//重新申请内存并使p指向这个内存。</span></span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"网课\"   >\n          <a href=\"#网课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课\" class=\"headerlink\" title=\"网课\"></a>网课</h1>\n      \n        <h3 id=\"2-2-3-对象的创建和使用\"   >\n          <a href=\"#2-2-3-对象的创建和使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-3-对象的创建和使用\" class=\"headerlink\" title=\"2.2.3 对象的创建和使用\"></a>2.2.3 对象的创建和使用</h3>\n      <ul>\n<li>对象的定义语法：</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">类名 对象名 [= 初始值];</span><br><span class=\"line\">类名 对象名 [(初始值列表)];</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>上述定义的对象和变量一样，仍然在栈中(自动分配和释放)</li>\n<li>访问对象的公有成员(含成员变量、成员函数)，和结构体变量</li>\n<li>访问成员的方法一致：<ul>\n<li>对象名.成员变量</li>\n<li>对象名.成员函数(实例列表)</li>\n</ul>\n</li>\n<li>也可以在堆中创建对象：<ul>\n<li><code>Student* ps = new Student; delete ps;</code></li>\n</ul>\n</li>\n<li>指针是栈里的局部变量，指向堆(手动分配和释放)里面的对象</li>\n<li>访问对象的公有成员(含成员变量、成员函数)，和结构体指针访问成员的方法一致：<ul>\n<li>指针-&gt;成员变量</li>\n<li>指针-&gt;成员函数(实例参数)</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"字符串类string的使用\"   >\n          <a href=\"#字符串类string的使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#字符串类string的使用\" class=\"headerlink\" title=\"字符串类string的使用\"></a>字符串类string的使用</h4>\n      <ul>\n<li><p>C语言不存在字符串类型，都是用字符数组(字符指针)处理字符串</p>\n</li>\n<li><p>C++支持字符数组，另外还提供了字符串类：string。使用前必须<code>#include &lt;string&gt;</code></p>\n</li>\n<li><p>使用string定义字符串，无须担心长度、空间等问题，且string重载了大量运算符，实现了大量成员函数，足以满足字符串的日常处理操作。</p>\n</li>\n<li><p>用法</p>\n<ul>\n<li>访问字符串中的字符与数组相同，可以连等。</li>\n<li>字符串间可以用加号链接<ul>\n<li><code>cout&lt;&lt;S1+S2&lt;&lt;endl;</code></li>\n<li><code>cout&lt;&lt;S1+=S2&lt;&lt;endl;</code></li>\n</ul>\n</li>\n<li>字符串的比较<ul>\n<li><code>cout&lt;&lt;(S1&lt;S2)&lt;&lt;endl;</code></li>\n</ul>\n</li>\n<li>计算字符串的长度<ul>\n<li><code>cout&lt;&lt;S1.length()&lt;&lt;endl</code></li>\n<li>一个汉字两个长度</li>\n</ul>\n</li>\n<li>字符串交换<ul>\n<li><code>S1.swap(S2)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"2-3-封装\"   >\n          <a href=\"#2-3-封装\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-3-封装\" class=\"headerlink\" title=\"2.3 封装\"></a>2.3 封装</h2>\n      <ul>\n<li><p>C++的封装是通过类类型(简称类)实现的，通过类把具体事物抽象成一个由属性(成员变量)和行为(成员函数)组成的独立单位(即类)。</p>\n</li>\n<li><p>在类的封装设计中，通过访问权限控制类成员访问，</p>\n<ul>\n<li>需要隐藏的、内部实现的细节设为私有<code>private</code>，仅供内部访问；</li>\n<li>允许子类访问的设为保护<code>protected</code></li>\n<li>需要对外提供访问接口的设为共有<code>public</code></li>\n</ul>\n</li>\n<li><p>成员函数的简单分类</p>\n<ul>\n<li>构造函数和析构函数<ul>\n<li>构造函数用于对象的创建和初始化</li>\n<li>析构函数用于对象的释放</li>\n</ul>\n</li>\n<li>针对成员变量的Set/Get、Add/Del函数<ul>\n<li>大多数变量往往设为私有，通过共有的Set/Get函数可以访问私有成员</li>\n<li>针对数组类型的成员变量，往往有Add/Del函数。</li>\n</ul>\n</li>\n<li>其他功能性函数<ul>\n<li>与应用程序具体的功能、业务规则有关</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>通常，成员变量是私有的，对每个成员变量会对应有一对共有的Set/Get函数</p>\n\n        <h2 id=\"2-4-this指针\"   >\n          <a href=\"#2-4-this指针\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-4-this指针\" class=\"headerlink\" title=\"2.4 this指针\"></a>2.4 this指针</h2>\n      <ul>\n<li>类中每个对象的<strong>数据成员</strong>都占用独立空间，但<strong>成员函数</strong>是共享的，可是各个<strong>对象调用相同的函数</strong>时，显示的是对象<strong>各自的信息</strong>。</li>\n<li><code>this</code>是C++中的一个关键字，也是一个<strong>常量指针</strong>，它指向当前对象，通过它可以访问当前对象的所有成员。</li>\n<li><code>this</code>实际上是成员函数的一个<strong>隐式</strong>的形参，在调用成员函数时将对象的地址作为实参传递给<code>this</code>。所谓“隐式”，是说它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</li>\n<li>三个作用：<ul>\n<li>如果成员函数的形参与类的成员变量重名，可以用<code>this</code>指针解决。</li>\n<li>如果成员函数需要返回当前对象，应该写成<code>return *this;</code></li>\n<li>可以在成员函数中，以<code>this</code>指针为实参，调用其他函数。</li>\n</ul>\n</li>\n<li>三点注意事项：<ul>\n<li><code>this</code>只能在成员函数内部使用，用在其他地方没有意义，也是非法的。</li>\n<li><code>this</code>是指针常量，它的值是不能被修改的，一切企图修改该指针的操作，如复制、递增、递减等都是不允许的。</li>\n<li>只有当对象被创建后<code>this</code>才有意义，因此不能在<code>static</code>成员函数中使用</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"2-5-构造函数\"   >\n          <a href=\"#2-5-构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-5-构造函数\" class=\"headerlink\" title=\"2.5 构造函数\"></a>2.5 构造函数</h2>\n      \n        <h3 id=\"2-5-1-自定义构造函数\"   >\n          <a href=\"#2-5-1-自定义构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-5-1-自定义构造函数\" class=\"headerlink\" title=\"2.5.1 自定义构造函数\"></a>2.5.1 自定义构造函数</h3>\n      <p>在C++中，如何<strong>自动进行对象初始化</strong>，并在对象撤销时，<strong>自动执行清理任务</strong></p>\n<ul>\n<li>构造函数是类的特殊成员函数，用于初始化对象。</li>\n<li>构造函数在创建对象时会<strong>自动/隐式</strong>调用。</li>\n<li>C++中的每个类至少要有一个构造函数</li>\n<li>如果类中没有定义构造函数，系统会提供一个<strong>默认构造函数</strong>。</li>\n<li>默认构造函数没有参数，也没有函数体，不具有实际的初始化意义。</li>\n<li>构造函数有严格的接口形式，有四个特点：<ul>\n<li>与类同名</li>\n<li>不能设置返回值类型，void也不写，不能使用return语句返回</li>\n<li>可以由参数，可以重载；</li>\n<li>一般设为<code>public</code></li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"自定义有参构造函数\"   >\n          <a href=\"#自定义有参构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#自定义有参构造函数\" class=\"headerlink\" title=\"自定义有参构造函数\"></a>自定义有参构造函数</h4>\n      <ul>\n<li>参数可以由默认值</li>\n<li>参数默认值写在声明处</li>\n<li>建议尽量使用初始化表。某些情况下，<strong>必须使用</strong>初始化表进行初始化！</li>\n<li>常变量、引用必须初始化，所以常成员变量、引用类型的成员变量，只能通过初始化进行初始化！成员对象也需要通过初始化表初始化。</li>\n</ul>\n\n        <h3 id=\"2-5-2-重载构造函数\"   >\n          <a href=\"#2-5-2-重载构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-5-2-重载构造函数\" class=\"headerlink\" title=\"2.5.2 重载构造函数\"></a>2.5.2 重载构造函数</h3>\n      <ul>\n<li>函数重载：<ul>\n<li>同一作用域内</li>\n<li>函数名相同</li>\n<li>但参数列表不同</li>\n</ul>\n</li>\n<li>三点注意：<ul>\n<li>不以返回值不同来作为重载的条件；</li>\n<li>形参变量名不同不意味着参数列表不同；</li>\n<li>有参数默认值时，要防止二义性</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"2-5-3-含有成员对象的类的构造函数\"   >\n          <a href=\"#2-5-3-含有成员对象的类的构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-5-3-含有成员对象的类的构造函数\" class=\"headerlink\" title=\"2.5.3 含有成员对象的类的构造函数\"></a>2.5.3 含有成员对象的类的构造函数</h3>\n      <ul>\n<li>什么是成员对象？<ul>\n<li>C++允许将一个对象作为另一个类的成员变量，即类中的成员变量可以是其他类的对象，这样的成员变量称为类的子对象或成员对象。</li>\n<li>创建含有成员对象的对象时，先执行成员对象的构造函数，再执行类的构造函数。</li>\n</ul>\n</li>\n</ul>\n<p>委托</p>\n\n        <h3 id=\"2-5-4-三角形项目的分析与设计\"   >\n          <a href=\"#2-5-4-三角形项目的分析与设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-5-4-三角形项目的分析与设计\" class=\"headerlink\" title=\"2.5.4 三角形项目的分析与设计\"></a>2.5.4 三角形项目的分析与设计</h3>\n      <ol>\n<li>分析<ul>\n<li>需求分析，开发人员经过深入细致的调研和分析，准确理解用户和项目的功能、性能、可靠性等具体要求，将用户非形式的需求表述转化为完整的希求定义，从而确定系统必须做什么的过程。</li>\n<li>在学习过程中，老师就是用户，main函数中的测试代码，以及预期的运行结果就是我们的需求。</li>\n</ul>\n</li>\n<li>设计<ul>\n<li>要把软件“做什么”转换为“怎么做”。即确定程序是由哪些模块组成的，以及模块之间的关系。</li>\n<li>在学习过层中，一个或若干个类就是一个模块。对应UML中的类图，也就是类的.h头文件。</li>\n</ul>\n</li>\n<li>实现<ul>\n<li>也就是编码的过程。也就是.cpp文件中每个成员函数具体是如何实现的。</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"分析\"   >\n          <a href=\"#分析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4>\n      <ol>\n<li>能够根据三个顶点的坐标，或者三条边的长度，构造三角形对象</li>\n<li>能够按照三个点的坐标显示三角形，其中每个顶点的x、y坐标能用方括号括起来，三个点用花括号括起来</li>\n<li>能够计算三角形的面积，如果三条边长不合理，则面积为零。</li>\n</ol>\n\n        <h4 id=\"设计\"   >\n          <a href=\"#设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h4>\n      <ul>\n<li>三类成员函数<ul>\n<li>构造函数/析构函数</li>\n<li>Set/Get函数</li>\n<li>功能函数</li>\n</ul>\n</li>\n<li>从调用者的角度来讲，应该把公有成员写在<strong>前面</strong>。但是在编码过程中，<strong>首先</strong>写成员变量。这二者不矛盾！</li>\n</ul>\n<p>点类的设计：</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"keyword\">float</span> xx = <span class=\"number\">0</span>, <span class=\"keyword\">float</span> yy = <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">Distance</span><span class=\"params\">(<span class=\"keyword\">const</span> Point&amp; other)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetX</span><span class=\"params\">(<span class=\"keyword\">float</span> xx)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetY</span><span class=\"params\">(<span class=\"keyword\">float</span> yy)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> :</span><br><span class=\"line\">    <span class=\"keyword\">float</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>三角形类的设计：</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Triangle</span>(<span class=\"keyword\">const</span> Point&amp; ppl,<span class=\"keyword\">const</span> Point&amp; pp2, <span class=\"keyword\">const</span> Point&amp; pp3);</span><br><span class=\"line\">    <span class=\"built_in\">Triangle</span>(<span class=\"keyword\">float</span> a, <span class=\"keyword\">float</span> b, <span class=\"keyword\">float</span> c);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">Area</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Point p1;</span><br><span class=\"line\">    Point p2;</span><br><span class=\"line\">    Point p3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"2-5-5-三角形项目的实现\"   >\n          <a href=\"#2-5-5-三角形项目的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-5-5-三角形项目的实现\" class=\"headerlink\" title=\"2.5.5 三角形项目的实现\"></a>2.5.5 三角形项目的实现</h3>\n      <p>没听懂这里为什么float不用常引用而正常的要用</p>\n\n        <h3 id=\"2-5-6-三角形项目的调试\"   >\n          <a href=\"#2-5-6-三角形项目的调试\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-5-6-三角形项目的调试\" class=\"headerlink\" title=\"2.5.6 三角形项目的调试\"></a>2.5.6 三角形项目的调试</h3>\n      <p>形参是int类型，实参是float类型，变量赋值转换的时候0.9会被转成0！</p>\n\n        <h2 id=\"2-6-析构函数\"   >\n          <a href=\"#2-6-析构函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-6-析构函数\" class=\"headerlink\" title=\"2.6 析构函数\"></a>2.6 析构函数</h2>\n      <ul>\n<li>构造函数<ul>\n<li>分配内存</li>\n<li>初始化工作</li>\n</ul>\n</li>\n<li>析构函数<ul>\n<li>回收内存</li>\n<li>清理工作</li>\n</ul>\n</li>\n</ul>\n<p>析构函数的语法：</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ABC.h 类的声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ABC</span>&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">ABC</span>();<span class=\"comment\">//构造函数的声明</span></span><br><span class=\"line\">  ~<span class=\"built_in\">ABC</span>();<span class=\"comment\">//析构函数的声明</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ABC.cpp 成员函数的类外实现</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;ABC.h&quot;</span></span></span><br><span class=\"line\">ABC::<span class=\"built_in\">ABC</span>()&#123;……;&#125;<span class=\"comment\">//构造函数的类外实现</span></span><br><span class=\"line\">ABC::~<span class=\"built_in\">ABC</span>()&#123;……;&#125;<span class=\"comment\">//析构函数的类外实现</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>析构函数时类的特殊成员函数，用于释放对象</p>\n</li>\n<li><p>析构函数在释放对象时会<strong>自动/隐式</strong>调用</p>\n</li>\n<li><p>C++中的每个类有且只有一个析构函数</p>\n</li>\n<li><p>如果类中没有定义析构函数，系统会提供一个<strong>默认析构函数</strong></p>\n</li>\n<li><p>默认析构函数没有参数，也没有函数体，不具有实际的意义</p>\n</li>\n<li><p>与类同名，前面加<code>~</code></p>\n</li>\n<li><p>不能设置返回值类型，不写<code>void</code>，不能使用<code>return</code>语句返回</p>\n</li>\n<li><p>没有参数，不能重载</p>\n</li>\n<li><p>父类的析构函数通常是虚拟析构函数</p>\n</li>\n<li><p>释放对象的三种时机：</p>\n<ol>\n<li>在函数中定义对象；当函数调用结束-&gt;释放栈-&gt;释放对象</li>\n<li>使用<code>static</code>修饰的静态对象，程序运行结束-&gt;释放静态内存空间-&gt;释放静态对象</li>\n<li>使用<code>new</code>运算符创建的对象，调用<code>delete</code>释放对象</li>\n</ol>\n</li>\n<li><p>栈中对象的析构函数的调用顺序，与析构函数的调用顺序相反</p>\n<ul>\n<li>因为栈是先进后出的顺序，从最后一个开始释放</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"2-6-1-指针类型的成员变量\"   >\n          <a href=\"#2-6-1-指针类型的成员变量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-6-1-指针类型的成员变量\" class=\"headerlink\" title=\"2.6.1 指针类型的成员变量\"></a>2.6.1 指针类型的成员变量</h3>\n      <ul>\n<li>如果一个类中有指针类型的成员变量，就需要在构造函数中通过<code>new</code>分配了内存，也就需要使用手动释放该段内存，即在析构函数中通过<code>delete</code>释放内存。</li>\n<li>从另一个角度讲：如果没有指针类型的成员变量，程序员也不需要实现析构函数，默认析构函数就可以</li>\n</ul>\n<p>类函数传入指针字符串变量的时候，类使用的是堆内的字符串，是公共的，类内没有自己的字符串，如果通过外部修改了这个字符串，那么类内的字符串也会被修改！因此强烈建议在类内开辟单独的内存，然后把字符串复制进去！</p>\n\n        <h3 id=\"2-6-2-正确处理指针类型的成员变量\"   >\n          <a href=\"#2-6-2-正确处理指针类型的成员变量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-6-2-正确处理指针类型的成员变量\" class=\"headerlink\" title=\"2.6.2 正确处理指针类型的成员变量\"></a>2.6.2 正确处理指针类型的成员变量</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _CRT_SECURE_NO_WARNINGS <span class=\"comment\">//忽略安全问题，继续使用strcpy等字符串函数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Student</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s,<span class=\"keyword\">int</span> a):<span class=\"built_in\">age</span>(a)&#123; <span class=\"comment\">//const char *对应字符串常量</span></span><br><span class=\"line\">      name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(s)+<span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"built_in\">strcpy</span>(name,s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Student</span>()&#123;<span class=\"keyword\">delete</span>[] name;&#125; <span class=\"comment\">//new[]对应deletep[]</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Student::<span class=\"built_in\">age</span>(<span class=\"keyword\">int</span> a)&#123;</span><br><span class=\"line\">  age = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Student <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;Alice&quot;</span>,<span class=\"number\">20</span>)</span></span>; <span class=\"comment\">//调用构造函数-&gt;new-&gt;拷贝Alice</span></span><br><span class=\"line\">  Student* s2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>(<span class=\"string\">&quot;Bob&quot;</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> s2; <span class=\"comment\">//调用析构函数-&gt;释放Bob</span></span><br><span class=\"line\">&#125; <span class=\"comment\">//调用析构函数-&gt;释放Alice</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>如何处理<code>void Student::SetName(const char* s)</code>？<ol>\n<li>不能让<code>name=s</code>，只能使用<code>strcpy</code>，以保证对象有自己<strong>独立</strong>的字符串。</li>\n<li>要考虑新名字比老名字长的问题。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//释放老名字</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span>[] name;</span><br><span class=\"line\"><span class=\"comment\">//重新分配内存空间</span></span><br><span class=\"line\">name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(s)+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"comment\">//字符串拷贝，以拥有自己的名字</span></span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(name,s);</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"2-7-拷贝构造函数\"   >\n          <a href=\"#2-7-拷贝构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-7-拷贝构造函数\" class=\"headerlink\" title=\"2.7 拷贝构造函数\"></a>2.7 拷贝构造函数</h2>\n      \n        <h3 id=\"2-7-1-拷贝构造函数\"   >\n          <a href=\"#2-7-1-拷贝构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-7-1-拷贝构造函数\" class=\"headerlink\" title=\"2.7.1 拷贝构造函数\"></a>2.7.1 拷贝构造函数</h3>\n      <ul>\n<li><p>简单类型变量：</p>\n<ul>\n<li>int a(0);</li>\n<li>int b(a);</li>\n</ul>\n</li>\n<li><p>类类型</p>\n<ul>\n<li>Triangle t1(3.4.5); //自定义带参构造函数</li>\n<li>Triangle t2(t1); //拷贝构造函数-自身类型的变量/对象</li>\n</ul>\n</li>\n<li><p>拷贝构造函数</p>\n<ul>\n<li>共性：是一种特殊的构造函数，拥有构造函数的所有特性。</li>\n<li>特性：并且使用自身类型的对象的引用作为构造函数的参数。</li>\n<li>目的：通过一个对象初始化另一个对象。</li>\n</ul>\n</li>\n</ul>\n<p>语法：</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    构造函数名(<span class=\"keyword\">const</span> 类名&amp; 对象名)&#123;……&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"函数调用中的拷贝构造函数\"   >\n          <a href=\"#函数调用中的拷贝构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#函数调用中的拷贝构造函数\" class=\"headerlink\" title=\"函数调用中的拷贝构造函数\"></a>函数调用中的拷贝构造函数</h4>\n      <p>结论：函数参数为引用类型，因为实参就是形参，所以不会调用拷贝构造函数</p>\n\n        <h3 id=\"2-7-2-浅拷贝\"   >\n          <a href=\"#2-7-2-浅拷贝\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-7-2-浅拷贝\" class=\"headerlink\" title=\"2.7.2 浅拷贝\"></a>2.7.2 浅拷贝</h3>\n      <ul>\n<li>如果程序没有自定义拷贝构造函数，C++会提供一个<strong>默认拷贝构造函数</strong>。</li>\n<li>默认拷贝构造函数的运行方式是：<strong>按位(bit by bit)复制</strong>，相当于自然界的克隆。</li>\n<li>如果有指针类型的成员变量，简单的按位复制会导致两个对象中的指针指向同一段内存。而由于构造函数使用<code>new</code>分配内存，析构函数使用delete释放内存，进而导致一段内存会被释放两次，程序崩溃。</li>\n</ul>\n<p>类成员套类成员的时候，不会调用构造函数，如果构造函数有cpy的拷贝功能的话，会造成两个成员的字符串指针相同。同时释放函数栈的时候会调用两次析构函数，如果析构函数中有内存释放的话，会造成程序崩溃！</p>\n<ul>\n<li>结论<ul>\n<li>如果没有指针类型的成员变量，默认析构函数、默认拷贝构造函数已经足够用了。</li>\n<li>如果有指针类型的成员变量，必须自定义析构函数、自定义拷贝构造函数。</li>\n<li>两个指针指向同一段内存，最容易造成<strong>指针悬挂</strong>。</li>\n<li>两个指针指向非法的内存地址，那么这个指针就是悬挂指针，也叫<strong>野指针</strong>。意为无法正常使用的指针。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"2-7-3-深拷贝\"   >\n          <a href=\"#2-7-3-深拷贝\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-7-3-深拷贝\" class=\"headerlink\" title=\"2.7.3 深拷贝\"></a>2.7.3 深拷贝</h3>\n      <ul>\n<li>在含有指针类型成员变量的情况下，使用默认拷贝构造函数，按照按位复制的方法，则会产生<strong>浅拷贝</strong>。所以，我们要自定义拷贝构造函数以实现<strong>深拷贝</strong>。</li>\n<li>新拷贝可以为新对象的指针分配一块内存空间，并将数据复制到新空间，以确保两个对象的指针指向各自的空间。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Demo::<span class=\"built_in\">Demo</span>(<span class=\"keyword\">const</span> Demo&amp; d)&#123;</span><br><span class=\"line\">  name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(d.name)+<span class=\"number\">1</span>];<span class=\"comment\">//分配空间</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(name,d.name);<span class=\"comment\">//拷贝函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Demo</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s); <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">  <span class=\"built_in\">Demo</span>(<span class=\"keyword\">const</span> Demo&amp; d); <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">  ~<span class=\"built_in\">Demo</span>();</span><br><span class=\"line\">  <span class=\"keyword\">char</span>* name;  <span class=\"comment\">//设置为公有成员变量，是为了方便观察</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Demo::<span class=\"built_in\">Demo</span>(<span class=\"keyword\">const</span> cahr* s)&#123;</span><br><span class=\"line\">  name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>][<span class=\"built_in\">strlen</span>(s)+<span class=\"number\">1</span>]; <span class=\"comment\">//分配空间</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(name,s); <span class=\"comment\">//拷贝数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Demp::<span class=\"built_in\">Demo</span>(<span class=\"keyword\">const</span> Demo&amp; d)&#123;</span><br><span class=\"line\">  name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(d.name)+<span class=\"number\">1</span>]; <span class=\"comment\">//分配空间</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(name,d.name); <span class=\"comment\">// 拷贝数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Demo::~<span class=\"built_in\">Demo</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"提前剧透：赋值运算符\"   >\n          <a href=\"#提前剧透：赋值运算符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#提前剧透：赋值运算符\" class=\"headerlink\" title=\"提前剧透：赋值运算符\"></a>提前剧透：赋值运算符</h4>\n      <ul>\n<li><p>在定义的同时进行赋值叫做初始化，定义完成以后再赋值(不管在定义的时候有没有赋值)就叫做赋值。初始化只能有一次，赋值可以有多次。</p>\n</li>\n<li><p>编译器提供默认赋值运算符，其机制也是“按位复制”。</p>\n</li>\n<li><p>int a(10); //Student s1(“Alice”);//带参构造函数</p>\n</li>\n<li><p>int b(a); Student s2(s1);//拷贝构造函数</p>\n</li>\n<li><p>a = b; s2 = s1; //赋值运算符</p>\n</li>\n</ul>\n\n        <h4 id=\"“空”类的五个默认\"   >\n          <a href=\"#“空”类的五个默认\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#“空”类的五个默认\" class=\"headerlink\" title=\"“空”类的五个默认\"></a>“空”类的五个默认</h4>\n      <ul>\n<li><code>class A&#123;&#125;;</code>是一个空类</li>\n<li>空类中至少包含四个成员函数<ol>\n<li>默认构造函数</li>\n<li>默认析构函数</li>\n<li>默认拷贝构造函数</li>\n<li>默认赋值运算符</li>\n</ol>\n</li>\n<li>非静态成员函数拥有默认参数<code>this</code>。</li>\n</ul>\n\n        <h2 id=\"2-8-关键字修饰类的成员\"   >\n          <a href=\"#2-8-关键字修饰类的成员\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-8-关键字修饰类的成员\" class=\"headerlink\" title=\"2.8 关键字修饰类的成员\"></a>2.8 关键字修饰类的成员</h2>\n      <ul>\n<li><p>const</p>\n</li>\n<li><p>static</p>\n</li>\n<li><p>&amp;</p>\n</li>\n<li><p>他们都是int类型</p>\n</li>\n<li><p>他们都需要初始化</p>\n<ul>\n<li>差别在于静态变量<strong>默认</strong>初始化为0</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"2-8-1-常成员\"   >\n          <a href=\"#2-8-1-常成员\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-8-1-常成员\" class=\"headerlink\" title=\"2.8.1 常成员\"></a>2.8.1 常成员</h3>\n      <ul>\n<li><p><code>const int a</code></p>\n</li>\n<li><p>const和指针结合，有指向常量的指针、指针常量两种形式，而数字名是指针常量。</p>\n</li>\n<li><p>在类中：</p>\n<ol>\n<li>const修饰成员变量，常成员变量</li>\n<li>const修饰成员函数，常成员函数</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"常成员变量\"   >\n          <a href=\"#常成员变量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常成员变量\" class=\"headerlink\" title=\"常成员变量\"></a>常成员变量</h4>\n      <ul>\n<li>常成员变量，也是常变量，具有只读属性，所以不能作为左值(即不能出现在赋值运算符的左侧)，所以只能通过初始化表进行初始化。</li>\n</ul>\n\n        <h4 id=\"常成员函数\"   >\n          <a href=\"#常成员函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常成员函数\" class=\"headerlink\" title=\"常成员函数\"></a>常成员函数</h4>\n      <ul>\n<li><p>使用const修饰的成员函数称为常成员函数</p>\n</li>\n<li><p>常成员函数的类内声明如下：</p>\n<ul>\n<li>返回值类型 函数名(参数列表)const;</li>\n</ul>\n</li>\n<li><p>长成员函数的类外实现如下：</p>\n<ul>\n<li>返回值类型 类名::函数名(参数列表) const{函数体}</li>\n</ul>\n</li>\n<li><p>常成员函数的用法</p>\n<ol>\n<li>常成员函数只能读取成员变量，而不能修改成员变量</li>\n<li>常成员函数只能调用类内的其他成员函数，不能调用非常成员函数</li>\n<li>常对象只能调用常函数</li>\n<li>类中的常成员函数和非常成员函数，若函数名相同，及时参数列表也相同，也构成重载</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>&#123;x=<span class=\"number\">100</span>;&#125; <span class=\"comment\">//f1是非常成员函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span><span class=\"keyword\">const</span></span>&#123; <span class=\"comment\">//f2是常成员函数</span></span><br><span class=\"line\">      x = <span class=\"number\">100</span>;  <span class=\"comment\">//常成员函数不能修改成员变量对的值</span></span><br><span class=\"line\">      <span class=\"built_in\">f1</span>(); <span class=\"comment\">//常成员函数不能调用非常成员函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Domo d1; <span class=\"comment\">//d1是一个对象</span></span><br><span class=\"line\">  d1.<span class=\"built_in\">f1</span>(); <span class=\"comment\">//d1既可以调用普通的成员函数</span></span><br><span class=\"line\">  d1.<span class=\"built_in\">f2</span>(); <span class=\"comment\">//也能调用常成员函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Demo d2; <span class=\"comment\">//d2是一个常对象</span></span><br><span class=\"line\">  d2.<span class=\"built_in\">f1</span>(); <span class=\"comment\">//常对象不能调用非常成员函数</span></span><br><span class=\"line\">  d2.<span class=\"built_in\">f2</span>(); <span class=\"comment\">//常对象只能调用常成员函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"2-8-2-静态成员\"   >\n          <a href=\"#2-8-2-静态成员\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-8-2-静态成员\" class=\"headerlink\" title=\"2.8.2 静态成员\"></a>2.8.2 静态成员</h3>\n      <ul>\n<li><p>回忆静态static局部变量的知识点</p>\n</li>\n<li><p>静态变量存储在静态区域中</p>\n</li>\n<li><p>静态局部变量默认初始值为0</p>\n</li>\n<li><p>静态局部变量可以被一个函数的每次调用所 “共享”</p>\n</li>\n<li><p>一个类的静态成员变量可以被该类的所有对象所“共享”</p>\n</li>\n<li><p>静态成员变量需要类外初始化</p>\n<ul>\n<li>类型 类名::静态成员变量(初始值);</li>\n</ul>\n</li>\n<li><p>使用static修饰的成员函数，称为静态成员函数。</p>\n</li>\n<li><p>成员函数都有默认参数this指针，指向当前对象。由于静态成员属于类、而不属于某个对象，所以静态成员函数的参数中没有默认的this指针。所以，静态成员函数无法调用非静态成员。</p>\n</li>\n</ul>\n\n        <h3 id=\"2-8-3-单例模式\"   >\n          <a href=\"#2-8-3-单例模式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-8-3-单例模式\" class=\"headerlink\" title=\"2.8.3 单例模式\"></a>2.8.3 单例模式</h3>\n      <ul>\n<li><p>单例模式属于23种经典设计模式中最简单的一个，是唯一一个非面向对象的设计模式。</p>\n</li>\n<li><p>设计模式是软件开发人员你在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n</li>\n<li><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>\n</li>\n<li><p>动机：在软件系统中，经常有这样一些特殊的类，必须保证他们在系统中只存在一个实例，才能确保它们逻辑正确性以及良好的效率。</p>\n</li>\n<li><p>这应该是类的设计者的责任，而不是使用者的责任。</p>\n<ul>\n<li>应该通过技术来保证，而非文字或口头来约束！</li>\n</ul>\n</li>\n<li><p>单例模式属于创建型模式。单利类负责创建自己的对象，同时确保对象的唯一性。即：</p>\n<ol>\n<li>单例类只能有一个实例。</li>\n<li>单例类必须自己创建自己的唯一实例。</li>\n<li>单例类必须给所有其他对象提供这一实例。</li>\n</ol>\n</li>\n<li><p>单例模式到底怎么实现呢？需要用到哪些技术呢？</p>\n<ul>\n<li>静态成员属于类而不属于某个对象，具备唯一性。</li>\n<li>可以通过类名直接访问静态成员，而不是创建对象，提供了良好的访问方式。</li>\n</ul>\n</li>\n<li><p>第一步，置之死地而后生</p>\n<ul>\n<li>由于构造函数一般都是共有的，所以程序员可以任意的创建或定义对象。</li>\n<li>为了确保对象的唯一性，我们从“任意创建”的极端走向另一个极端，通过私有构造函数，确保无法从外部创建对象，而只能从内部创建对象，以确保对象的数量可控。</li>\n</ul>\n</li>\n<li><p>第二步：为了确保唯一性应该是类的功能，而不是调用者的责任，所以内部要封装一个<strong>唯一实例的指针</strong>。</p>\n</li>\n<li><p>第三步：根据成员变量设计静态成员变量读取函数。</p>\n</li>\n<li><p>第四步：实现静态成员变量读取函数。</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Singleton* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">GetName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Singleton* _instance;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::GetInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(_instance == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    _instance = <span class=\"keyword\">new</span> Singleton;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Singleton::SetName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span></span>&#123;</span><br><span class=\"line\">  name = s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">Singleton::GetName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Singleton* p = Singleton::<span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">  p-&gt;<span class=\"built_in\">SetName</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Singleton* p = Singleton::<span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">  q-&gt;<span class=\"built_in\">SetName</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">fun</span>();</span><br><span class=\"line\">  cout &lt;&lt; q-&gt;<span class=\"built_in\">GetName</span>() &lt;&lt; endl1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li>无需实例化一个对象</li>\n<li>任何地方的修改都是针对同一个对象</li>\n</ol>\n\n        <h2 id=\"2-9-友元\"   >\n          <a href=\"#2-9-友元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-9-友元\" class=\"headerlink\" title=\"2.9 友元\"></a>2.9 友元</h2>\n      <ul>\n<li>友元，friend，好朋友</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>;<span class=\"comment\">//声明fun为友元</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetX</span><span class=\"params\">(<span class=\"keyword\">int</span> xx)</span></span>&#123;_x=xx;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>: </span><br><span class=\"line\">    <span class=\"keyword\">int</span> _x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Demo d;</span><br><span class=\"line\">  d._x = <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>friend关键字把“外部”细分成了两类，好友的权限扩大了，非好友仍然严格执行访问权限。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">otherModule</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Demo d;</span><br><span class=\"line\">  d._x = <span class=\"number\">100</span>;<span class=\"comment\">//错误</span></span><br><span class=\"line\">  d.<span class=\"built_in\">Set</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>一般来说，只把用一个模块内部的函数或类声明为友元。友元一般用来给同一个模块内部的其他函数、类开了一个后门，可以直接访问私有成员。</li>\n</ul>\n<p>在类中将某一函数添加为友元后，可以直接在函数内部调用私有成员变量。</p>\n<ul>\n<li>友元函数<ul>\n<li>把普通函数声明为友元函数</li>\n<li>把其他类的成员函数声明为友元函数</li>\n</ul>\n</li>\n<li>友元类</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>关于友元函数<ul>\n<li>友元函数不是成员函数</li>\n<li>友元函数的声明可以写在类中任意位置</li>\n<li>友元函数不受访问权限的影响</li>\n</ul>\n</li>\n<li>关于友元<ul>\n<li>友元是单向的；如果需要互为好友，就必须各自单独声明</li>\n<li>友元不具备传递性</li>\n<li>友元关系不能被继承——好朋友的好朋友不是好朋友</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"高内聚、低耦合\"   >\n          <a href=\"#高内聚、低耦合\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#高内聚、低耦合\" class=\"headerlink\" title=\"高内聚、低耦合\"></a>高内聚、低耦合</h3>\n      <ul>\n<li>高内聚低耦合，是软件工程中的概念，是判断软件设计好坏的标准，主要用于程序的面向对象的设计。</li>\n<li>目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。</li>\n<li>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系</li>\n<li>耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li>\n</ul>\n\n        <h2 id=\"2-10-总结\"   >\n          <a href=\"#2-10-总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-10-总结\" class=\"headerlink\" title=\"2.10 总结\"></a>2.10 总结</h2>\n      <ul>\n<li>对象数组如果没有初始化，则要求对象的无参构造函数。<ul>\n<li>默认可以传数组进</li>\n<li>设置了一个构造函数，数组可能会不能进去</li>\n<li>想要值和数组都近要么设置两个构造函数，要么带默认参数</li>\n</ul>\n</li>\n<li>函数以<code>char*</code>或者<code>const char*</code>作为参数，如果需要默认值，则该是<code>&quot;&quot;</code>，表示空字符串，而非<code>nullptr</code>。<ul>\n<li>如果使用空指针的话，程序会直接报错。</li>\n</ul>\n</li>\n<li>表示访问权限的三个关键字在类中可以出现多次，也没有顺序限制。</li>\n<li>为什么有一些成员变量名要以<code>_</code>开头？<ul>\n<li>系统级核心变量，避免重名，是一种习惯</li>\n<li>私有成员变量有些人也习惯在前面加上<code>_</code></li>\n</ul>\n</li>\n<li>class的默认访问权限是private</li>\n<li>在C++中，struct具有和class完全相同的功能，只是它的默认访问权限是public</li>\n</ul>\n\n        <h1 id=\"第3单元-运算符重载\"   >\n          <a href=\"#第3单元-运算符重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第3单元-运算符重载\" class=\"headerlink\" title=\"第3单元 运算符重载\"></a>第3单元 运算符重载</h1>\n      \n        <h2 id=\"3-1-运算符重载概述\"   >\n          <a href=\"#3-1-运算符重载概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-1-运算符重载概述\" class=\"headerlink\" title=\"3.1 运算符重载概述\"></a>3.1 运算符重载概述</h2>\n      \n        <h3 id=\"3-1-1-运算符重载的语法\"   >\n          <a href=\"#3-1-1-运算符重载的语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-1-1-运算符重载的语法\" class=\"headerlink\" title=\"3.1.1 运算符重载的语法\"></a>3.1.1 运算符重载的语法</h3>\n      <ul>\n<li>C++的一大特性就是重载Overload</li>\n<li>重载使得代码简洁高效</li>\n<li>不仅仅可以针对函数进行重载，也可以针对运算符进行重载。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"keyword\">float</span> xx = <span class=\"number\">0</span>, <span class=\"keyword\">float</span> yy = <span class=\"number\">0</span>): <span class=\"built_in\">x</span>(xx),<span class=\"built_in\">y</span>(yy)&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">Point <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">const</span> Point&amp; other)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(x+other.x,y+other.y);<span class=\"comment\">//这里用了匿名函数，直接定义了一个函数省略了变量名，一次性的。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Show</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;[&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&quot;]&quot;</span>;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> x,y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>运算符重载的本质就是函数重载。注：但是不能说运算符的本质是函数，运算符和函数对应的二进制代码还是有很大差别的。</li>\n<li>运算符的操作数，等价于函数参数</li>\n<li>使用<code>operator运算符</code>替代函数名即可</li>\n<li>例如，用<code>operator+</code>替换<code>add</code></li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"keyword\">float</span> xx = <span class=\"number\">0</span>, <span class=\"keyword\">float</span> yy = <span class=\"number\">0</span>):<span class=\"built_in\">x</span>(xx),<span class=\"built_in\">y</span>(yy)&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">Point <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">const</span> Point &amp; other)</span></span>;</span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span> +(<span class=\"keyword\">const</span> Point &amp; other);<span class=\"comment\">//加号运算符重载，重新定义+的功能。</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Point <span class=\"title\">Point::Add</span><span class=\"params\">(<span class=\"keyword\">const</span> Point &amp; other)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(x + other.x,y + other.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Point <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1.2</span>)</span>,<span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">3.4</span>)</span>,c</span>;</span><br><span class=\"line\">  c = a.<span class=\"built_in\">Add</span>(b);</span><br><span class=\"line\">  c = a.<span class=\"keyword\">operator</span>+(b); <span class=\"comment\">//按照函数的方式调用operator+</span></span><br><span class=\"line\">  c = a + b;<span class=\"comment\">//按照运算符的方式调用operator+</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>充分证明：运算符重载的本质就是函数重载</p>\n\n        <h4 id=\"运算符重载的规则\"   >\n          <a href=\"#运算符重载的规则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运算符重载的规则\" class=\"headerlink\" title=\"运算符重载的规则\"></a>运算符重载的规则</h4>\n      <ul>\n<li>只能重载C++中已有的运算符，且不能创建新的运算符。</li>\n<li>重载后运算符不能改变优先级和结合性，也不能改变操作数和语法结构。</li>\n<li>运算符重载的目的是针对实际运算数据类型的需要，重载要保持原有运算符的语义，且要避免没有目的地使用运算符重载。</li>\n<li>并非所有C++运算符都可以重载。不可重载的运算符包括：<ul>\n<li>::</li>\n<li>?:<ul>\n<li>这个是那个三元表达式</li>\n</ul>\n</li>\n<li>.</li>\n<li>.*<ul>\n<li>成员指针运算符</li>\n</ul>\n</li>\n<li>sizeof</li>\n<li>typeid</li>\n<li>等</li>\n</ul>\n</li>\n<li>可重载的运算符<ul>\n<li>单目运算符</li>\n<li>双目运算符<ul>\n<li>[]下标运算符是双目运算符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"3-1-3-运算符重载的形式\"   >\n          <a href=\"#3-1-3-运算符重载的形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-1-3-运算符重载的形式\" class=\"headerlink\" title=\"3.1.3 运算符重载的形式\"></a>3.1.3 运算符重载的形式</h3>\n      <ul>\n<li>运算符重载有两种形式<ul>\n<li>重载为类的成员变量</li>\n<li>重载为全局函数，往往声明为类的友元函数</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"重载为类的成员函数\"   >\n          <a href=\"#重载为类的成员函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重载为类的成员函数\" class=\"headerlink\" title=\"重载为类的成员函数\"></a>重载为类的成员函数</h4>\n      <ul>\n<li>双目运算符<ul>\n<li>左操作数是对象本身，由this指针指出<ul>\n<li>运算符能否作为成员函数重载的条件</li>\n</ul>\n</li>\n<li>右操作数通过函数参数传递</li>\n</ul>\n</li>\n<li>单目运算符<ul>\n<li>操作数就是对象本身，由this指针指出；参数列表为空</li>\n<li>如果运算符区分前置、后置两种操作，例如++、–，则函数需要带一个整形参数，即<code>operator++(int)</code><ul>\n<li>这是人为规定的。由于该参数不参与运算，所以无需变量名。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"keyword\">float</span> xx = <span class=\"number\">0</span>, <span class=\"keyword\">float</span> yy = <span class=\"number\">0</span>):<span class=\"built_in\">x</span>(xx),<span class=\"built_in\">y</span>(yy)&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>++();<span class=\"comment\">//前置++的声明</span></span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)<span class=\"comment\">//后置++的声明</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Point::Show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;[&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point Point::<span class=\"keyword\">operator</span>++()&#123;<span class=\"comment\">//前置++的实现</span></span><br><span class=\"line\">  ++x;<span class=\"comment\">//先++</span></span><br><span class=\"line\">  ++y;<span class=\"comment\">//先++</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; <span class=\"comment\">//再返回</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point Point::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;<span class=\"comment\">//后置++的实现</span></span><br><span class=\"line\">  <span class=\"comment\">//先返回，再++</span></span><br><span class=\"line\">  <span class=\"function\">Point <span class=\"title\">r</span><span class=\"params\">(*<span class=\"keyword\">this</span>)</span></span>;<span class=\"comment\">//用r记录需要返回的数据</span></span><br><span class=\"line\">  ++(*<span class=\"keyword\">this</span>);<span class=\"comment\">//当前对象++</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;<span class=\"comment\">//返回以前的数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"3-1-4-重载为全局函数\"   >\n          <a href=\"#3-1-4-重载为全局函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-1-4-重载为全局函数\" class=\"headerlink\" title=\"3.1.4 重载为全局函数\"></a>3.1.4 重载为全局函数</h3>\n      <ul>\n<li>重载为全局函数，往往声明为类的友元函数</li>\n<li>重载为全局函数时，所有操作数都需要通过参数进行传递。</li>\n<li>重载为全局函数，还是成员函数，一般没有差别。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> Point <span class=\"keyword\">operator</span>-(cosnt Point&amp; p1.<span class=\"keyword\">const</span> Point&amp; p2);<span class=\"comment\">//减法声明为友元</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Point</span>(<span class=\"keyword\">float</span> xx = <span class=\"number\">0</span>, <span class=\"keyword\">float</span> yy = <span class=\"number\">0</span>):<span class=\"built_in\">x</span>(xx),<span class=\"built_in\">y</span>(yy)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point&amp; other); <span class=\"comment\">//加法重载为的成员函数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">float</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Point::Show</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;[&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&quot;]&quot;</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point Point::<span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point&amp; other)&#123; <span class=\"comment\">//加法重载为成员函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(x+other.x,y+other.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point <span class=\"keyword\">operator</span>-(<span class=\"keyword\">const</span> Point&amp; p1, <span class=\"keyword\">const</span> Point&amp; p2)&#123; <span class=\"comment\">//减法重载为全局函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(p1.x - p2.x, p1.y-p2.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"3-2-常用运算符重载\"   >\n          <a href=\"#3-2-常用运算符重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-常用运算符重载\" class=\"headerlink\" title=\"3.2 常用运算符重载\"></a>3.2 常用运算符重载</h2>\n      \n        <h3 id=\"3-2-1-输入输出运算符的重载\"   >\n          <a href=\"#3-2-1-输入输出运算符的重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-1-输入输出运算符的重载\" class=\"headerlink\" title=\"3.2.1 输入输出运算符的重载\"></a>3.2.1 输入输出运算符的重载</h3>\n      <ul>\n<li>C++的IO系统提供了<code>&gt;&gt;</code>和<code>&lt;&lt;</code>两个运算符执行IO操作。但标准库只定义了基本数据类型的IO……</li>\n<li>输入输出运算符重载是双目运算符</li>\n<li>双目运算符重载为成员函数<ul>\n<li>左操作数十对象本身，由this指针指出</li>\n<li>右操作数通过函数参数传递</li>\n</ul>\n</li>\n<li>输入输出运算符只能重载为全局函数。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">ostream <span class=\"keyword\">operator</span>&lt;&lt;(ostream o, <span class=\"keyword\">const</span> Point&amp; p)&#123;</span><br><span class=\"line\"> ……;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> o;<span class=\"comment\">//输出运算符从左往右的顺序结合，左边运算符的返回值就是下一个运算符的左操作数</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>外部设备具有唯一性，代表外部设备的cout对象也不能有两个！</li>\n<li>形参到实参的拷贝，函数的返回值，都会调用拷贝构造函数</li>\n<li>为了避免在内存中有两个对象代表同一个设备，因此左操作数和返回值都是ostream&amp;</li>\n<li>输入和输出肯定要涉及数据的读写操作，所以不能是const</li>\n</ul>\n<p>自定义<code>class Demo</code>的输出运算符虫子啊，往往是一下形式：</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> Demo&amp; d);</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; i,<span class=\"keyword\">const</span> Demo&amp; d);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> Demo&amp; d)&#123;……;<span class=\"keyword\">return</span> o;&#125;</span><br><span class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; i,<span class=\"keyword\">const</span> Demo&amp; d)&#123;……;<span class=\"keyword\">return</span> i;&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>流输出运算符重载的知识点<ul>\n<li>为什么流输出运算符只能重载为全局函数，不能重载为成员函数？<ul>\n<li>重载为成员函数的条件是：左操作数是当前类型的对象，而流输出运算符的左操作数cout的类型是ostream。</li>\n</ul>\n</li>\n<li>流输出运算符重载的函数原型，使用了三处引用，有什么区别？<ul>\n<li>右操作数是当前类型的常引用，是为了避免实参到形参的拷贝以及起到制度作用；左操作数和返回值实际上都是cout，代表设备，类型都是<code>ostream&amp;</code>，是为了确保<strong>设备对象的唯一性</strong>。</li>\n</ul>\n</li>\n<li>流输出运算符为什么要返回左操作数？<ul>\n<li>返回左操作数，也就是返回cout，是为了实现流输出运算符的连续使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"3-2-2-关系运算符重载\"   >\n          <a href=\"#3-2-2-关系运算符重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-2-关系运算符重载\" class=\"headerlink\" title=\"3.2.2 关系运算符重载\"></a>3.2.2 关系运算符重载</h3>\n      <ul>\n<li>让数据有序是改进算法、提高程序运行速度的最基本的方法。</li>\n<li>如何对一个Point数组按照到原点的距离从小到大进行排序？<ul>\n<li>难点：需要重载&gt;运算符，因为Point类型无法进行比较</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIZE 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(Point arr[],<span class=\"keyword\">int</span> len)</span></span>&#123;……&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o, Point arr[])&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++)</span><br><span class=\"line\">    o &lt;&lt; arr[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Point allPoints[SIZE] = &#123;<span class=\"built_in\">Point</span>(<span class=\"number\">3</span>,<span class=\"number\">4</span>),<span class=\"built_in\">Point</span>(<span class=\"number\">1</span>,<span class=\"number\">8</span>),<span class=\"built_in\">Point</span>(<span class=\"number\">3</span>,<span class=\"number\">6</span>),<span class=\"built_in\">Point</span>(<span class=\"number\">4</span>,<span class=\"number\">7</span>)&#125;;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;排序前：&quot;</span>&lt;&lt;allPoints&lt;&lt;endl;</span><br><span class=\"line\">  <span class=\"built_in\">bubbleSort</span>(allPoints,SIZE);</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;排序后&quot;</span>&lt;&lt;allPoints&lt;&lt;endl;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><strong>两个浮点数不能用逻辑<code>==</code>判断是否相等</strong></li>\n</ul>\n<p><code>(abs(x-other.x)&lt;1e-7)&amp;&amp;(abs(y-other.y)&lt;1e-7)</code></p>\n<p>例子：</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在Point中重载&lt;</span></span><br><span class=\"line\"><span class=\"comment\">//规则：首先判断x，x小的，point对象也小，x相等的，在判断y</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> Point::<span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Point&amp; other)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(x-other.x)&lt;<span class=\"number\">1e-7</span>)<span class=\"comment\">//即x==other.x</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> y&lt;other.y;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x&lt;other.x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"3-2-3-重载赋值运算符\"   >\n          <a href=\"#3-2-3-重载赋值运算符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-3-重载赋值运算符\" class=\"headerlink\" title=\"3.2.3 重载赋值运算符\"></a>3.2.3 重载赋值运算符</h3>\n      <ul>\n<li><p>初始化运算符和赋值运算符是两个运算符，但都使用了<code>=</code>。</p>\n</li>\n<li><p>在定义变量(或对象)的时候，使用<code>=</code>，是初始化运算符。针对对象，会调用构造函数。例如：<code>int a = 3</code></p>\n</li>\n<li><p>针对已经存在的变量(或对象)使用<code>=</code>，则是赋值。例如：<code>int a;a=3;</code></p>\n</li>\n<li><p>赋值运算符可以重载</p>\n</li>\n<li><p>如果程序员不提供赋值运算符，则编译器会提供一个<strong>默认</strong>的赋值运算符。</p>\n<ul>\n<li>默认复制运算符<strong>按位拷贝</strong>。除了调用时机不一样，赋值运算符与拷贝构造函数基本一致。</li>\n<li>如果有指针类型的成员变量，则是<strong>浅拷贝</strong>。此时，应重载赋值运算符实现<strong>深拷贝</strong></li>\n</ul>\n</li>\n<li><p>赋值运算符的结合顺序是：从右向左，一致<code>Point a(1,2),b,c;</code></p>\n</li>\n<li><p>左侧=的右操作数是表达式<code>b=a</code>的值，所以赋值运算符的返回值类型是Point。为了提高效率(减少一次拷贝构造函数的调用)，返回值类型是<code>Point&amp;</code>。</p>\n</li>\n<li><p><code>MyString s1(&quot;Hello&quot;);</code></p>\n</li>\n<li><p><code>MyString s2(s1);</code></p>\n</li>\n<li><p><code>MyString s3(6,&#39;A&#39;);</code></p>\n</li>\n<li><p><code>s1=s3;</code></p>\n</li>\n<li><p><code>cout &lt;&lt; s1 &lt;&lt; &quot;,&quot; &lt;&lt; s2 &lt;&lt; &quot;,&quot; &lt;&lt; s3 &lt;&lt; endl;</code> </p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyString::<span class=\"built_in\">MyString</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str)&#123;</span><br><span class=\"line\">  _s = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(str)+<span class=\"number\">1</span>];<span class=\"comment\">//分配内存空间</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(_s,str);<span class=\"comment\">//拷贝数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyString::<span class=\"built_in\">MyString</span>(<span class=\"keyword\">const</span> MyString&amp; other)&#123;</span><br><span class=\"line\">  _s = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(other,_s)+<span class=\"number\">1</span>];<span class=\"comment\">//分类内存空间</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(_s,other._s);<span class=\"comment\">//拷贝数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyString&amp; MyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> MyString&amp; other)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] _s;  <span class=\"comment\">//对象创建的时候已经new[]了，必须先释放</span></span><br><span class=\"line\">  _s = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(other._s)+<span class=\"number\">1</span>];  <span class=\"comment\">//才能分配新的空间</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(_s,other._s);  <span class=\"comment\">//拷贝数据</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; <span class=\"comment\">//返回当前</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyString::<span class=\"built_in\">MyString</span>(<span class=\"keyword\">int</span> count,<span class=\"keyword\">char</span> c)&#123;</span><br><span class=\"line\">  _s = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[count+<span class=\"number\">1</span>]; <span class=\"comment\">//分配内存空间</span></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(_s,c,count); <span class=\"comment\">//前面设置count个c</span></span><br><span class=\"line\">  _s[count]=<span class=\"string\">&#x27;\\0&#x27;</span>; <span class=\"comment\">//最后一位设置结束标志</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyString::~<span class=\"built_in\">MyString</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] _s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> MyString&amp; str)&#123;</span><br><span class=\"line\">  o&lt;&lt;<span class=\"string\">&quot;\\&quot;&quot;</span>&lt;&lt;str._s&lt;&lt;<span class=\"string\">&quot;\\&quot;&quot;</span>;  <span class=\"comment\">//转义字符</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"3-2-4-下标运算符重载\"   >\n          <a href=\"#3-2-4-下标运算符重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-4-下标运算符重载\" class=\"headerlink\" title=\"3.2.4 下标运算符重载\"></a>3.2.4 下标运算符重载</h3>\n      <ul>\n<li>[]运算符<ul>\n<li>通常用于<strong>读、写</strong>数组中的某一个元素</li>\n<li>是一个双目运算符</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> MyString::<span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> index)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _s[index];<span class=\"comment\">//相当于*(_s+index)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">main</span>()&#123;</span><br><span class=\"line\">  <span class=\"function\">MyString <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;abc&quot;</span>)</span></span>;<span class=\"comment\">//str的成员变量_s指向了&quot;abc&quot;</span></span><br><span class=\"line\">  cout&lt;&lt;str[<span class=\"number\">1</span>]&lt;&lt;endl;<span class=\"comment\">//输出str.s[1],也就是&#x27;b&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>重载下标运算符的目的<ul>\n<li>采用“下标”这一程序员习惯的编写形式，读取/修改对象的部分内容。</li>\n<li>下标运算符的右操作数不一定是从0开始的自然数，可以是任意类型。</li>\n<li>可以实现<code>关键字到值的映射</code></li>\n<li>可以对下标进行越界检查</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"3-2-6-MyString\"   >\n          <a href=\"#3-2-6-MyString\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-6-MyString\" class=\"headerlink\" title=\"3.2.6 MyString\"></a>3.2.6 MyString</h3>\n      <ul>\n<li>前++</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyString MyString::<span class=\"keyword\">operator</span>++()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(_s);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;<span class=\"comment\">//空串直接返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* temp = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[len+<span class=\"number\">2</span>];</span><br><span class=\"line\">  temp[<span class=\"number\">0</span>] = _s[<span class=\"number\">0</span>];  <span class=\"comment\">//复制最前的字符串</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(temp+<span class=\"number\">1</span>,s); <span class=\"comment\">//复制旧字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] _s;      <span class=\"comment\">//释放旧字符串</span></span><br><span class=\"line\">  _s=temp;          <span class=\"comment\">//更新当前对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>后++</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyString MyString::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(_s);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;<span class=\"comment\">//空字符串直接返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">MyString <span class=\"title\">r</span><span class=\"params\">(_s)</span></span>;<span class=\"comment\">//准备好返回值，即当前字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* temp = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[len+<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(temp,_s);      <span class=\"comment\">//复制旧字符串</span></span><br><span class=\"line\">  temp[len]=_s[len<span class=\"number\">-1</span>];  <span class=\"comment\">//复制最后的字符</span></span><br><span class=\"line\">  temp[len+<span class=\"number\">1</span>]=<span class=\"string\">&#x27;\\0&#x27;</span>;     <span class=\"comment\">//结束标志</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] _s;          <span class=\"comment\">//释放旧字符串</span></span><br><span class=\"line\">  _s = temp;            <span class=\"comment\">//更新当前对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>前–</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyString MyString::<span class=\"keyword\">operator</span>--()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span>* temp = _s;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(*temp)<span class=\"comment\">//如果不为空，等价于*temp!=&#x27;\\0&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\">//吧后面的字符依次向前拷贝，</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*temp=*(temp+<span class=\"number\">1</span>))<span class=\"comment\">//遇见&#x27;\\0&#x27;为止</span></span><br><span class=\"line\">      ++temp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>后–</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyString MyString::<span class=\"keyword\">operator</span>--(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">  <span class=\"function\">MyString <span class=\"title\">r</span><span class=\"params\">(_s)</span></span>;<span class=\"comment\">//准备好返回的当前对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* temp = _s;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(*temp)&#123;  <span class=\"comment\">//如果不为空，等价于*temp!=&#x27;\\0&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*(temp+<span class=\"number\">1</span>))++temp;<span class=\"comment\">//找到最后一个字符</span></span><br><span class=\"line\">    *temp = <span class=\"string\">&#x27;\\0&#x27;</span>;<span class=\"comment\">//把最后一个字符置零</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>-=删除字符’b’<ul>\n<li>需要<strong>复制</strong>字符<ul>\n<li>拷贝</li>\n<li>src指向下一个字符</li>\n<li>dst指向下一个字符</li>\n</ul>\n</li>\n<li>需要<strong>删除</strong>字符<ul>\n<li>src指向下一个字符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//算法一</span></span><br><span class=\"line\">MyString MyString::<span class=\"keyword\">operator</span>-=(<span class=\"keyword\">char</span> c)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> src = <span class=\"number\">0</span>,dst = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(_s);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(src&lt;len)&#123; <span class=\"comment\">//循环遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_s[src]==c)<span class=\"comment\">//如果要删除字符</span></span><br><span class=\"line\">      src++;      <span class=\"comment\">//准备处理下一个字符</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>  <span class=\"comment\">//如果要复制字符，先复制、再移动</span></span><br><span class=\"line\">      _s[dst++]=_s[src++];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _s[dst] = <span class=\"number\">0</span>;  <span class=\"comment\">//设置结束标志</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//算法二</span></span><br><span class=\"line\">MyString MyString::<span class=\"keyword\">operator</span>-=(<span class=\"keyword\">char</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> src = <span class=\"number\">0</span>,dst = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(_s);<span class=\"function\">l</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">while</span><span class=\"params\">(src&lt;len)</span></span>&#123; <span class=\"comment\">//循环遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_s[src]!=c)</span><br><span class=\"line\">      _s[dst++]=_s[src];</span><br><span class=\"line\">    src++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _s[dst] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>原字符串复制n变<code>*=</code></li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyString MyString::<span class=\"keyword\">operator</span>*=(<span class=\"keyword\">int</span> n)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">2</span>) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(_s);</span><br><span class=\"line\">  <span class=\"keyword\">char</span>* temp = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[len * n+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(temp,<span class=\"number\">0</span>,len*n+<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i= <span class=\"number\">0</span>; i &lt; n;i++)</span><br><span class=\"line\">    <span class=\"built_in\">strcat</span>(temp,s);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] _s;</span><br><span class=\"line\">  _s = temp;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"3-3-类型转换\"   >\n          <a href=\"#3-3-类型转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-类型转换\" class=\"headerlink\" title=\"3.3 类型转换\"></a>3.3 类型转换</h2>\n      \n        <h3 id=\"3-3-1-转换构造函数\"   >\n          <a href=\"#3-3-1-转换构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-1-转换构造函数\" class=\"headerlink\" title=\"3.3.1 转换构造函数\"></a>3.3.1 转换构造函数</h3>\n      \n        <h3 id=\"3-3-2-1-转换构造函数\"   >\n          <a href=\"#3-3-2-1-转换构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-2-1-转换构造函数\" class=\"headerlink\" title=\"3.3.2.1 转换构造函数\"></a>3.3.2.1 转换构造函数</h3>\n      <ul>\n<li>如果构造函数只有一个参数，且参数不是本类的常引用，称之为<strong>转换构造函数</strong>。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(B b); <span class=\"comment\">//B是一个简单类型</span></span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"keyword\">const</span> C&amp; c);  <span class=\"comment\">//C是一个复杂类型</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li><p>将简单类型的变量，或者复杂类型的对象，转换成当前类型。</p>\n</li>\n<li><p>调用函数的时候，强调的是实参和形参类型匹配。</p>\n</li>\n<li><p>如果不一致，但是匹配，则编译器会自动调用默认类型转换或者类型转换函数。</p>\n</li>\n</ul>\n\n        <h3 id=\"3-3-2-2-返回匿名对象、返回引用、转换构造函数、运算符重载\"   >\n          <a href=\"#3-3-2-2-返回匿名对象、返回引用、转换构造函数、运算符重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-2-2-返回匿名对象、返回引用、转换构造函数、运算符重载\" class=\"headerlink\" title=\"3.3.2.2 返回匿名对象、返回引用、转换构造函数、运算符重载\"></a>3.3.2.2 返回匿名对象、返回引用、转换构造函数、运算符重载</h3>\n      <ul>\n<li><p>匿名对象、临时对象</p>\n</li>\n<li><p>匿名对象仅在当前语句有效，当前语句执行完毕后会被释放(调用析构函数)。</p>\n</li>\n<li><p>生存周期仅在当前这一行</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类的声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"keyword\">int</span> x=<span class=\"number\">0</span>)&#123;……;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个场景</span></span><br><span class=\"line\"><span class=\"function\">A <span class=\"title\">f1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//A result(100);</span></span><br><span class=\"line\">  <span class=\"comment\">//return result;</span></span><br><span class=\"line\">  <span class=\"comment\">//return A result(100);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">A</span>(<span class=\"number\">100</span>);<span class=\"comment\">//这里就是一个匿名函数，省略了对象名</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二个场景</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">(<span class=\"keyword\">const</span> A&amp; a)</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">f2</span>(<span class=\"built_in\">A</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第三个场景</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  A allAs[] = &#123;<span class=\"built_in\">A</span>(<span class=\"number\">1</span>),<span class=\"built_in\">A</span>(<span class=\"number\">2</span>),<span class=\"built_in\">A</span>(<span class=\"number\">3</span>)&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure></li>\n<li><p>编译器会尝试把int转换成匿名对象</p>\n</li>\n<li><p>建议</p>\n<ul>\n<li>直接返回匿名对象，编译器会自动优化，把匿名对象和返回值合二为一</li>\n</ul>\n</li>\n<li><p>能否返回引用？</p>\n<ul>\n<li>函数不能返回局部变量的引用</li>\n<li>在能够返回引用的情况下，返回引用能够提高程序的运行效率</li>\n</ul>\n</li>\n<li><p>全局函数和成员函数不构成重载(函数之间没有重载关系)，但能构成某一运算符的重载</p>\n</li>\n</ul>\n\n        <h3 id=\"3-3-3-类型转换函数\"   >\n          <a href=\"#3-3-3-类型转换函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-3-类型转换函数\" class=\"headerlink\" title=\"3.3.3 类型转换函数\"></a>3.3.3 类型转换函数</h3>\n      <ul>\n<li>转换构造函数可以实现<strong>任意类型=&gt;当前类类型</strong>的转换</li>\n<li>C++提供了类型转换函数实现当前类类型到任意类型的转换。</li>\n<li>自定义类型可以自己设计，但是如果要重新定义封装好的类型，就只能类型转换了</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span></span>;<span class=\"comment\">//A=&gt;B</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>如果B是自定义类类型</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">B</span>(<span class=\"keyword\">const</span> A&amp; a);<span class=\"comment\">//A=&gt;B</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure></li>\n<li><p>实例：</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyString</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str)&#123;……;&#125;</span><br><span class=\"line\">    <span class=\"comment\">/*int*/</span><span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">int</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">strlen</span>(_s);&#125;<span class=\"comment\">//省略了返回值类型</span></span><br><span class=\"line\">    <span class=\"comment\">//一是为了保持简洁的风格，而是因为省略了返回值类型不会造成歧义</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* _s;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">MyString <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;Hello,World!&quot;</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len=s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>另一个实例：</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o, <span class=\"keyword\">const</span> Name&amp; name);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">string</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  string&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">const</span> string&amp; index);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  string firstName; <span class=\"comment\">//名字</span></span><br><span class=\"line\">  string midName;   <span class=\"comment\">//中间名</span></span><br><span class=\"line\">  string lastName;  <span class=\"comment\">//姓氏</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Name::<span class=\"keyword\">operator</span> <span class=\"title\">string</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  stringstream ss;  <span class=\"comment\">//定义字符串流对象，#include &lt;sstream&gt;</span></span><br><span class=\"line\">  ss&lt;&lt;firstName&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;midName&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;lastName;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ss.<span class=\"built_in\">str</span>();  <span class=\"comment\">//把流对象转换成字符串并返回</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Name James;</span><br><span class=\"line\">  James[<span class=\"string\">&quot;first&quot;</span>]=<span class=\"string\">&quot;James&quot;</span>;</span><br><span class=\"line\">  James[<span class=\"string\">&quot;mid&quot;</span>]=<span class=\"string\">&quot;Robert&quot;</span>;</span><br><span class=\"line\">  James[<span class=\"string\">&quot;last&quot;</span>]=<span class=\"string\">&quot;Smith&quot;</span>;</span><br><span class=\"line\">  string str = James; <span class=\"comment\">//两侧类型不一致，编译器自动进行类型转换</span></span><br><span class=\"line\">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"3-4-仿函数——重载-运算符\"   >\n          <a href=\"#3-4-仿函数——重载-运算符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-4-仿函数——重载-运算符\" class=\"headerlink\" title=\"3.4 仿函数——重载()运算符\"></a>3.4 仿函数——重载()运算符</h2>\n      <ul>\n<li><p><code>()</code>，函数运算符，是函数的标志，用来标志参数列表。</p>\n</li>\n<li><p>不是有()就是函数</p>\n</li>\n<li><p>仿函数指的是：在类中重载了<code>()</code>之后，这个类的对象可以像函数一样使用。</p>\n</li>\n<li><p>仿函数在<code>STL的算法</code>中使用非常广泛。<code>Lambda表达式</code>也是对仿函数的扩展。</p>\n</li>\n<li><p>C语言中通过<code>函数指针</code>也可以达到仿函数、Lambda表达式的效果。</p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Show</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> string str)</span><span class=\"comment\">//()运算符重载函数</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      cout&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">float</span> num)</span><span class=\"comment\">//()运算符重载函数</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> num*num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Show s;</span><br><span class=\"line\">  <span class=\"built_in\">s</span>(<span class=\"string\">&quot;abcdef&quot;</span>);  <span class=\"comment\">//  把对象当做函数调用</span></span><br><span class=\"line\">  cout&lt;&lt;<span class=\"built_in\">s</span>(<span class=\"number\">4</span>)&lt;&lt;endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"第4单元-继承与派生\"   >\n          <a href=\"#第4单元-继承与派生\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第4单元-继承与派生\" class=\"headerlink\" title=\"第4单元 继承与派生\"></a>第4单元 继承与派生</h1>\n      \n        <h2 id=\"4-1-继承\"   >\n          <a href=\"#4-1-继承\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-继承\" class=\"headerlink\" title=\"4.1 继承\"></a>4.1 继承</h2>\n      \n        <h3 id=\"4-1-1-继承的概念\"   >\n          <a href=\"#4-1-1-继承的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-1-继承的概念\" class=\"headerlink\" title=\"4.1.1 继承的概念\"></a>4.1.1 继承的概念</h3>\n      <ul>\n<li><p>面向对象提供了继承机制</p>\n<ul>\n<li>可以在原有类的基础上，通过简单的程序构造功能更加强大的新类，从而实现<strong>代码复用</strong>，提高软件开发效率。</li>\n<li>换言之，继承就是一个类从另一个类获取成员变量和成员函数的过程。例如类B继承与类A，那么B就拥有A的成员变量和成员函数。</li>\n</ul>\n</li>\n<li><p>派生</p>\n<ul>\n<li>在C++中，派生(Derive)和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。</li>\n</ul>\n</li>\n<li><p>新构建的类称为<strong>子类</strong>或<strong>派生类</strong>，现有类称为<strong>父类</strong>或<strong>基类</strong>。</p>\n</li>\n<li><p>C++中可以通过派生形成类的层次结构，称之为<strong>类族</strong>，即一个基类可以是另一个更高层次的派生类，而派生类也可以继续产生派生类。</p>\n</li>\n<li><p>派生类的语法</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 派生类名:</span>继承方式 基类名&#123;</span><br><span class=\"line\">  派生类成员声明;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>小例子：</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fish</span>:</span><span class=\"keyword\">public</span> Animal&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span>:</span><span class=\"keyword\">public</span> Animal&#123;&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>派生类和基类的关系也称之为“is-a”，也就是：鱼是一种动物</p>\n</li>\n<li><p>还有一种关系叫做“has-a”，即组合。</p>\n</li>\n<li><p>几点注意事项</p>\n<ol>\n<li>积累的<strong>构造/析构函数不能被继承</strong><ul>\n<li>派生类拥有自己的构造/析构函数。同时，也拥有基类的所有成员(包括基类的构造/析构函数)，只是不能作为派生类的构造/析构函数来使用。</li>\n</ul>\n</li>\n<li>派生类继承基类的<strong>全部</strong>成员<ul>\n<li>拥有但不一定有访问权限</li>\n</ul>\n</li>\n<li>基类和派生类是<strong>多对多</strong>的关系<ol>\n<li>一个基类可以对多个派生类</li>\n<li>一个派生类可以对应多个基类</li>\n</ol>\n</li>\n<li>派生类可以<strong>新增成员</strong>，用于实现新功能</li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"Animal-Project实践\"   >\n          <a href=\"#Animal-Project实践\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Animal-Project实践\" class=\"headerlink\" title=\"Animal Project实践\"></a>Animal Project实践</h3>\n      <blockquote>\n<p>AnimalProject.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;Animal.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Fish <span class=\"title\">fish</span><span class=\"params\">(<span class=\"string\">&quot;海棠&quot;</span>)</span></span>;</span><br><span class=\"line\">  fish.<span class=\"built_in\">Eat</span>();</span><br><span class=\"line\">  fish.<span class=\"built_in\">Swim</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<blockquote>\n<p>Animal.h</p>\n</blockquote>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"built_in\">Animal</span>(string str);</span><br><span class=\"line\">   <span class=\"function\">string <span class=\"title\">GetName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fish</span>:</span> <span class=\"comment\">//派生类拥有基类的所有成员</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Fish</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Swim</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<blockquote>\n<p>Animal.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;Animal.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">Animal::<span class=\"built_in\">Animal</span>(string str):<span class=\"built_in\">name</span>(str)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">Animal::GetName</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> name;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Animal::Eat</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;name&lt;&lt;<span class=\"string\">&quot; eating&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fish::<span class=\"built_in\">Fish</span>(string str):<span class=\"built_in\">Animal</span>(str);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Fish::Swim</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"built_in\">GetName</span>()&lt;&lt;<span class=\"string\">&quot; swiming&quot;</span>&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>总结<ul>\n<li>继承的主要作用是实现<strong>代码复用</strong>。把类的相同成员那些在基类中，把类的不同成员写在派生类中。</li>\n<li>派生类拥有基类的所有成员，但是，派生类不能直接访问基类的私有成员。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"4-1-2-继承方式\"   >\n          <a href=\"#4-1-2-继承方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-2-继承方式\" class=\"headerlink\" title=\"4.1.2 继承方式\"></a>4.1.2 继承方式</h3>\n      <ul>\n<li>派生类拥有基类的所有成员，但是能否访问不仅受到成员自身的访问权限属性影响，还受继承方式影响。</li>\n<li>类的继承方式有三种：<ul>\n<li>共有public继承<ul>\n<li>最常用继承方式</li>\n<li>类内、子类、类外可以访问</li>\n</ul>\n</li>\n<li>保护protect继承<ul>\n<li>类内、子类可以访问</li>\n</ul>\n</li>\n<li>私有private继承<ul>\n<li>默认继承方式</li>\n<li>类内可以访问，子类不能访问</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>继承方式和访问权限是两个概念，只是使用了相同的关键字。</li>\n</ul>\n<ol>\n<li>基类成员在派生类中的访问权限不得高于继承方式中指定的权限<ul>\n<li>继承方式中的<code>public private</code>是用来指明基类成员在派生类中的<strong>最高访问权限</strong>的。</li>\n</ul>\n</li>\n<li>不管继承方式如何，基类中的private成员以及不可访问成员，在派生类中始终<strong>不能直接使用</strong>。</li>\n</ol>\n<ul>\n<li>在当前类中应该如何使用继承方式和访问权限？<ol>\n<li>当前类中不允许在派生类中使用、更不允许向外暴露的成员，应声明为<code>private</code></li>\n<li>当前类中允许派生类中使用、但不向外暴露(不能通过对象访问)，声明为<code>protected</code></li>\n<li>当前类中即允许派生类使用、也允许向外暴露的，声明为<code>public</code></li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"4-1-3-类型兼容\"   >\n          <a href=\"#4-1-3-类型兼容\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-3-类型兼容\" class=\"headerlink\" title=\"4.1.3 类型兼容\"></a>4.1.3 类型兼容</h3>\n      <p>不同类型的数据在一定条件下可以进行转换，称为类型转换，也称为类型兼容。</p>\n<p>在C++中，基类与派生类之间也存在类型兼容。</p>\n<ul>\n<li>类型兼容的形式<ol>\n<li>使用公有派生类对象为基类对象赋值</li>\n</ol>\n<ul>\n<li>子类变量可以赋值给父类变量</li>\n<li>父类变量不能赋值给子类变量</li>\n</ul>\n<ol start=\"2\">\n<li>使用公有派生类对象为基类对象的引用赋值</li>\n<li>使用公有派生类对象的指针为基类指针赋值</li>\n<li>如果函数的参数是基类对象、基类对象的引用、基类指针，则函数在调用时，可以使用公有派生类对象、公有派生类对象的地址作为实参。</li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"4-1-4-父类指针指向子类对象\"   >\n          <a href=\"#4-1-4-父类指针指向子类对象\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-4-父类指针指向子类对象\" class=\"headerlink\" title=\"4.1.4 父类指针指向子类对象\"></a>4.1.4 父类指针指向子类对象</h3>\n      <p>父类指针数组指向所有子类对象</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//元素类型 数组名[数组大小];</span></span><br><span class=\"line\">Animal* allAnis[<span class=\"number\">4</span>]; <span class=\"comment\">//父类指针数组</span></span><br><span class=\"line\">allAnis[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Fish</span>(<span class=\"string\">&quot;大鱼&quot;</span>);<span class=\"comment\">//父类指针指向子类对象</span></span><br><span class=\"line\">allAnis[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Bird</span>(<span class=\"string\">&quot;大鸟&quot;</span>);</span><br><span class=\"line\">allAnis[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Fish</span>(<span class=\"string\">&quot;小鱼&quot;</span>);</span><br><span class=\"line\">allAnis[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Bird</span>(<span class=\"string\">&quot;小鸟&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)</span><br><span class=\"line\">  allAnis[i]-&gt;<span class=\"built_in\">Eat</span>();  <span class=\"comment\">//通过父类指针数组的元素调用公有成员</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>RTTI(运行时类型识别)，它使程序能够获取由基类指针(引用)所指向的成员的实际派生类型。</li>\n<li>在C++中，为了支持RTTI提供了两个操作符<ul>\n<li>dynamic_cast</li>\n<li>typeid</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"4-2-派生类\"   >\n          <a href=\"#4-2-派生类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-2-派生类\" class=\"headerlink\" title=\"4.2 派生类\"></a>4.2 派生类</h2>\n      \n        <h3 id=\"4-2-1-派生类的构造函数与析构函数\"   >\n          <a href=\"#4-2-1-派生类的构造函数与析构函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-2-1-派生类的构造函数与析构函数\" class=\"headerlink\" title=\"4.2.1 派生类的构造函数与析构函数\"></a>4.2.1 派生类的构造函数与析构函数</h3>\n      <p>派生类的成员变量包括从基类继承的成员变量和新增的成员变量，因此，派生类的构造函数除了要初始化派生类中新增的成员变量，还要初始化基类的成员变量，即派生类的构造函数要负责调用基类的构造函数。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">派生类构造函数(参数列表):基类构造函数(基类构造函数参数列表)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  派生类新增成员的初始化语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>在定义派生类构造参数时，通过<code>:</code>运算符在后面完成基类构造函数的调用。基类构造函数的参数从派生类构造函数的参数列表中获取。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span> <span class=\"comment\">//基类</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"keyword\">int</span> aa,<span class=\"keyword\">int</span> bb):<span class=\"built_in\">ma</span>(aa),<span class=\"built_in\">mb</span>(bb)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ma,mb;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derive</span>:</span><span class=\"keyword\">public</span> Base&#123; <span class=\"comment\">//派生类</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derive</span>(<span class=\"keyword\">int</span> aa, <span class=\"keyword\">int</span> bb,<span class=\"keyword\">int</span> xx,<span class=\"keyword\">int</span> yy,<span class=\"keyword\">int</span> zz):<span class=\"built_in\">Base</span>(aa,bb),<span class=\"built_in\">mx</span>(xx),<span class=\"built_in\">my</span>(yy),<span class=\"built_in\">mz</span>(zz)&#123;&#125;<span class=\"comment\">//初始化各变量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max,my,mz;  <span class=\"comment\">//除此之外还有基类的两个</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>如果基类有无参构造函数(包括默认构造函数)，则在定义派生类构造函数时可以<strong>省略</strong>对基类构造函数的调用</p>\n</li>\n<li><p>尽管没有调用基类无参构造函数，但依然会执行基类无参构造函数</p>\n</li>\n<li><p>如果基类定义了有参构造函数，派生类必须定义构造函数，提供基类构造函数的参数，完成基类成员变量的初始化。</p>\n</li>\n<li><p>构造函数的调用顺序：基类=&gt;成员对象=&gt;派生类</p>\n</li>\n<li><p>析构函数的调用顺序反过来</p>\n</li>\n</ul>\n\n        <h3 id=\"4-2-2-在派生类中隐藏基类成员函数\"   >\n          <a href=\"#4-2-2-在派生类中隐藏基类成员函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-2-2-在派生类中隐藏基类成员函数\" class=\"headerlink\" title=\"4.2.2 在派生类中隐藏基类成员函数\"></a>4.2.2 在派生类中隐藏基类成员函数</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span>&#123;</span>  <span class=\"comment\">//定义交通工具类Vehicle</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>; <span class=\"comment\">//交通工具普通成员函数run()</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Vehicle::run</span><span class=\"params\">()</span></span>&#123;  <span class=\"comment\">//类外实现run()函数</span></span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;基类run()函数:行驶&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span>:</span>:<span class=\"keyword\">public</span> Vehicle&#123;  <span class=\"comment\">//定义小汽车类，继承Vehicle</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Car::run</span><span class=\"params\">()</span></span>&#123;  <span class=\"comment\">//小汽车类普通成员函数run()实现</span></span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;小汽车需要燃烧汽油，行驶速度快&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Car car;</span><br><span class=\"line\">  car.<span class=\"built_in\">run</span>();  <span class=\"comment\">//派生类run</span></span><br><span class=\"line\">  car.Vehicle::<span class=\"built_in\">run</span>(); <span class=\"comment\">//通过基类名与作用域限定符调用run()函数</span></span><br><span class=\"line\">  Vehicle* pv=&amp;car; </span><br><span class=\"line\">  pv-&gt;<span class=\"built_in\">run</span>();  <span class=\"comment\">//基类指针调用基类run()函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"4-3-多继承\"   >\n          <a href=\"#4-3-多继承\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-多继承\" class=\"headerlink\" title=\"4.3 多继承\"></a>4.3 多继承</h2>\n      <p>派生类有多个基类</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span>&#123;</span>&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base2</span>&#123;</span>&#125;</span><br><span class=\"line\">calss Derive:<span class=\"keyword\">public</span> Base1,<span class=\"keyword\">public</span> Base2 &#123;&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"4-4-虚继承\"   >\n          <a href=\"#4-4-虚继承\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-4-虚继承\" class=\"headerlink\" title=\"4.4 虚继承\"></a>4.4 虚继承</h2>\n      <p>间接基类的成员变量在底层派生类中只有一份拷贝，从而避免成员访问的二义性。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 派生类名:</span> <span class=\"keyword\">virtual</span> 权限控制符 基类名&#123;</span><br><span class=\"line\">  派生类成员</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"第5章-多态与虚函数\"   >\n          <a href=\"#第5章-多态与虚函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第5章-多态与虚函数\" class=\"headerlink\" title=\"第5章 多态与虚函数\"></a>第5章 多态与虚函数</h1>\n      \n        <h2 id=\"5-1-概述\"   >\n          <a href=\"#5-1-概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-1-概述\" class=\"headerlink\" title=\"5.1 概述\"></a>5.1 概述</h2>\n      <ul>\n<li><p>封装</p>\n</li>\n<li><p>继承</p>\n</li>\n<li><p>多态</p>\n</li>\n<li><p>向不同的对象发送同一个消息(即成员函数的调用)，会产生不同的行为。</p>\n</li>\n<li><p>多态是一种：调用同名函数却因上下文不同会有不同实现的一种机制。</p>\n</li>\n<li><p>多态带来的好处</p>\n<ul>\n<li>不用记大量的函数名</li>\n<li>会一句调用时的上下文来自动确定实现</li>\n<li>带来了面向对象的编程</li>\n</ul>\n</li>\n<li><p>静态多态(静态联编)</p>\n<ul>\n<li>编译时实现，不影响运行速度</li>\n<li>重载  Overload</li>\n</ul>\n</li>\n<li><p>动态多态(动态联编)</p>\n<ul>\n<li>运行时实现，需要查找虚函数表，影响运行速度</li>\n<li>继承和虚函数</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"5-2-虚函数实现多态\"   >\n          <a href=\"#5-2-虚函数实现多态\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-2-虚函数实现多态\" class=\"headerlink\" title=\"5.2 虚函数实现多态\"></a>5.2 虚函数实现多态</h2>\n      <p>虚函数是运行时多态，若某个基类函数声明为虚函数，则其公有派生类将定义与其基类虚函数原型相同的函数，这时，当使用基类指针或基类引用操作派生类对象时，系统会自动用派生类中的同名函数代替基类虚函数。</p>\n<ul>\n<li>虚函数的声明及类外实现格式</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名&#123;</span></span><br><span class=\"line\">访问权限:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> 函数类型 函数名(参数列表);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>小例子</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enemy</span>&#123;</span>  <span class=\"comment\">//基类 </span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>;  <span class=\"comment\">//基类的虚函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span><span class=\"keyword\">public</span> Enemy&#123; <span class=\"comment\">//共有派生类</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>;  <span class=\"comment\">//因为基类是虚函数，所以这里只能是虚函数，一虚到底</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Dog dog;</span><br><span class=\"line\">  Enemy* pe = &amp;dog;</span><br><span class=\"line\">  pe-&gt;<span class=\"built_in\">Attack</span>(); <span class=\"comment\">//基类指针</span></span><br><span class=\"line\">  Enemy&amp; re = dog;</span><br><span class=\"line\">  re.<span class=\"built_in\">Attack</span>();  <span class=\"comment\">//基类引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//都会输出&quot;狗咬了你一口&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Enemy::Attack</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;敌人发起攻击&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dog::Attack</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>类比常成员函数、静态成员函数</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名&#123;</span></span><br><span class=\"line\">  访问权限:</span><br><span class=\"line\">    函数类型 函数名(参数列表)<span class=\"keyword\">const</span>  <span class=\"comment\">//常成员函数</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> 函数类型 函数名(参数列表)  <span class=\"comment\">//静态成员函数</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> 变量类型 变量名; <span class=\"comment\">//静态成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> 函数类型 函数名(参数列表) <span class=\"comment\">//虚函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">函数类型 类名::函数名(参数列表)<span class=\"keyword\">const</span>&#123;函数体&#125;  <span class=\"comment\">//常成员函数的类外实现</span></span><br><span class=\"line\">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;  <span class=\"comment\">//静态成员函数的类外实现</span></span><br><span class=\"line\">变量类型 类名::变量名 = 初始值;   <span class=\"comment\">//静态成员变量的类外初始化</span></span><br><span class=\"line\">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;  <span class=\"comment\">//虚函数的在外实现</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>重载、隐藏和覆盖的区别</p>\n<ul>\n<li>重载 <ul>\n<li>都是以函数名相同为条件</li>\n<li>重载的规则最简单，因为没有跨类，不涉及类型兼容问题</li>\n</ul>\n</li>\n<li>隐藏<ul>\n<li>规则相对复杂</li>\n<li>参数不同，无论是否是虚函数，基类的函数都将被隐藏；</li>\n<li>参数相同，基类不是虚函数，构成隐藏(是虚函数，构成覆盖)</li>\n</ul>\n</li>\n<li>覆盖<ul>\n<li>基类与派生类有同名函数，参数相同，并且是虚函数</li>\n<li>虚函数的特点是“虚到底”。</li>\n<li>在覆盖的情况下，函数的调用取决于对象的类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>小总结</p>\n<ul>\n<li>重载就是重载</li>\n<li>隐藏与虚函数无关，出现同名函数的时候，基类的函数会被隐藏，除非使用基类类型指针或引用指向派生类，才有可能调用到被隐藏的函数。</li>\n<li>覆盖就是虚函数的隐藏，看最终指向的对象类型是啥就调用啥。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"5-2-1-所有敌人发起攻击！\"   >\n          <a href=\"#5-2-1-所有敌人发起攻击！\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-2-1-所有敌人发起攻击！\" class=\"headerlink\" title=\"5.2.1 所有敌人发起攻击！\"></a>5.2.1 所有敌人发起攻击！</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enemy</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout&lt;&lt;<span class=\"string\">&quot;敌人发起了攻击&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>:</span><span class=\"keyword\">public</span> Enemy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Cat</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;来了一只猫&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;猫挠了你一把&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span><span class=\"keyword\">public</span> Enemy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Cat</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;来了一只狗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)); <span class=\"comment\">//初始化随机数种子</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size = <span class=\"number\">4</span>;</span><br><span class=\"line\">  Enemy* allEnemies[size];  <span class=\"comment\">//元素类型 数组名[数组大小]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i) <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">rand</span>()%<span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">      allEnemies[i]=<span class=\"keyword\">new</span> Cat;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      allEnemies[i]=<span class=\"keyword\">new</span> Dog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i) <span class=\"comment\">//所有敌人发起攻击</span></span><br><span class=\"line\">      allEnemies[i]-&gt;<span class=\"built_in\">Attack</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"5-2-2-数函数实现的机制\"   >\n          <a href=\"#5-2-2-数函数实现的机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-2-2-数函数实现的机制\" class=\"headerlink\" title=\"5.2.2 数函数实现的机制\"></a>5.2.2 数函数实现的机制</h3>\n      <ul>\n<li><p>在编写程序时，我们需要根据函数名、返回值类型、参数列表等信息正确调用函数，这个匹配过程称之为绑定。</p>\n</li>\n<li><p>C++提供了两种函数绑定机制：静态绑定和动态绑定。</p>\n</li>\n<li><p>静态多态(重载)实现的机制是静态绑定(静态联编)，它是指在编译时期就能确定调用的函数。</p>\n</li>\n<li><p>动态多态(覆盖)实现的机制是动态绑定(动态联编)，它是指在运行时才能确定要调用的函数。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Enemy* pe:allEnemies)</span><br><span class=\"line\">  pe-&gt;<span class=\"built_in\">Attack</span>();</span><br></pre></td></tr></table></div></figure></li>\n<li><p>虚函数是通过虚函数表vtable实现动态绑定的。</p>\n</li>\n<li><p>虚函数对应一个指向vtable虚函数表的指针，而这个指向vtable的指针是存储在对象的内存空间的。换言之，必须在对象穿件之后才能访问虚函数，而构造函数就是用来创建对象的，所以构造函数不能是虚函数。</p>\n</li>\n</ul>\n\n        <h3 id=\"5-2-3-虚析构函数\"   >\n          <a href=\"#5-2-3-虚析构函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-2-3-虚析构函数\" class=\"headerlink\" title=\"5.2.3 虚析构函数\"></a>5.2.3 虚析构函数</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enemy</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;敌人发起了攻击&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Enemy</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;释放敌人&quot;</span>&lt;&lt;endl;&#125; <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>:</span><span class=\"keyword\">public</span> Enemy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Cat</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;来了一只猫&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;猫挠了你一把&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span><span class=\"keyword\">public</span> Enemy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Cat</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;来了一只狗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)); <span class=\"comment\">//初始化随机数种子</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size = <span class=\"number\">4</span>;</span><br><span class=\"line\">  Enemy* allEnemies[size];  <span class=\"comment\">//元素类型 数组名[数组大小]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i) <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">rand</span>()%<span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">      allEnemies[i]=<span class=\"keyword\">new</span> Cat;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      allEnemies[i]=<span class=\"keyword\">new</span> Dog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i) <span class=\"comment\">//所有敌人发起攻击</span></span><br><span class=\"line\">      allEnemies[i]-&gt;<span class=\"built_in\">Attack</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> allEnemies[i]; <span class=\"comment\">//释放第i个敌人</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这样对象会没有被完全释放，这个结果是错误的。正常情况下，首先要调用派生类的析构函数，再调用基类的析构函数。</span></span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li>通过delete释放对象时，会调用析构函数</li>\n<li>目前析构函数不是虚函数，所以函数的调用取决于变量的类型</li>\n<li>是通过基类指针释放的，所以会调用基类的析构函数，并且不会调用派生类的析构函数。</li>\n</ol>\n<ul>\n<li>为了确保整个对象被完全释放，所以应该声明析构函数为虚析构函数</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~类名();  <span class=\"comment\">//基类声明虚析构函数后，所有派生类的析构函数也自动称为虚析构函数。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>声明虚析构函数后，在通过基类指针释放派生类对象时，才会按照正常的释放流程，首先调用派生类的析构函数、在调用基类的析构函数，确保对象被正常释放。</li>\n<li>建议：即使默认析构函数已经满足功能需求，但是仍然建议习惯性的给基类设置虚析构函数！</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enemy</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;敌人发起了攻击&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Enemy</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;释放敌人&quot;</span>&lt;&lt;endl;&#125; <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>:</span><span class=\"keyword\">public</span> Enemy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Cat</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;来了一只猫&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;猫挠了你一把&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Cat</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;释放猫&quot;</span>&lt;&lt;endl;&#125; <span class=\"comment\">//猫虚析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span><span class=\"keyword\">public</span> Enemy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Cat</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;来了一只狗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;<span class=\"string\">&quot;狗咬了你一口&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Dog</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;释放狗&quot;</span>&lt;&lt;endl;&#125; <span class=\"comment\">//狗虚析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)); <span class=\"comment\">//初始化随机数种子</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size = <span class=\"number\">4</span>;</span><br><span class=\"line\">  Enemy* allEnemies[size];  <span class=\"comment\">//元素类型 数组名[数组大小]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i) <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">rand</span>()%<span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">      allEnemies[i]=<span class=\"keyword\">new</span> Cat;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      allEnemies[i]=<span class=\"keyword\">new</span> Dog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i) <span class=\"comment\">//所有敌人发起攻击</span></span><br><span class=\"line\">      allEnemies[i]-&gt;<span class=\"built_in\">Attack</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> allEnemies[i]; <span class=\"comment\">//释放第i个敌人</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"5-3-纯虚函数与抽象类\"   >\n          <a href=\"#5-3-纯虚函数与抽象类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-3-纯虚函数与抽象类\" class=\"headerlink\" title=\"5.3 纯虚函数与抽象类\"></a>5.3 纯虚函数与抽象类</h2>\n      <ul>\n<li>基类的虚函数没有什么意义，只需要声明好就行。</li>\n<li><code>virtual void Attack() = 0;</code></li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enemy</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>纯虚函数的作用是在基类中为派生类保留一个结构，方便派生类根据需要实现接口，进而实现多态。</p>\n</li>\n<li><p>如果一个类中包含纯虚函数，则该类称为抽象类。</p>\n<ul>\n<li>保留接口</li>\n<li>方便派生类实现接口</li>\n<li>实现多态</li>\n</ul>\n</li>\n<li><p>抽象类只能用来派生新类，而不能实例化对象</p>\n<ul>\n<li>可以定义抽象类指针或引用，并且抽象类指针指向派生类对象，这是面向对象编程常用的做法</li>\n</ul>\n</li>\n<li><p>如果派生类没有实现基类的全部接口，则派生类仍然是抽象类</p>\n</li>\n<li><p>针对接口进行编程</p>\n</li>\n<li><p>派生类必须实现基类的所有接口才行</p>\n</li>\n</ul>\n\n        <h2 id=\"5-4-强制类型转换\"   >\n          <a href=\"#5-4-强制类型转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-4-强制类型转换\" class=\"headerlink\" title=\"5.4 强制类型转换\"></a>5.4 强制类型转换</h2>\n      <ul>\n<li>转换构造函数</li>\n<li>类型转换函数</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"keyword\">const</span> B&amp;);  <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span></span>; <span class=\"comment\">//类型转换函数</span></span><br><span class=\"line\">&#125;;<span class=\"comment\">//强调的是如何实现转换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  <span class=\"function\">A <span class=\"title\">a</span><span class=\"params\">(b)</span></span>;   <span class=\"comment\">//调用转换构造函数</span></span><br><span class=\"line\">  b = (B)a; <span class=\"comment\">//电泳类型转换函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>C语言的强制类型转换简单粗暴，没有任何安全机制</p>\n</li>\n<li><p>C++提供了四个类型转换运算符，对应不同类型数据之间的转换</p>\n<ul>\n<li><code>static_cast&lt;type&gt;(expression)</code><ul>\n<li>用于代替C语言中通常的转换操作</li>\n</ul>\n</li>\n<li><code>dynamic_cast&lt;type&gt;(expression)</code><ul>\n<li>用于类层次间的向上转换和向下转换</li>\n</ul>\n</li>\n<li><code>const_cast&lt;type&gt;(expression)</code><ul>\n<li>用于用于去除常引用和常指针的const属性</li>\n</ul>\n</li>\n<li><code>reinterpret_cast&lt;type&gt;(expression)</code><ul>\n<li>为操作数的位模式提供底层的重新解释</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>static_cast&lt;type&gt;(expression)</code></p>\n<ul>\n<li>基本数据类型之间的转换<ul>\n<li>例：<code>int i = 1;double j = static_cast&lt;double&gt;(i);</code></li>\n</ul>\n</li>\n<li>把任何类型转换成void类型</li>\n<li>把空指针转换成目标类型的空指针</li>\n<li>向上类型转换是安全的；向下类型转换则不安全。</li>\n</ul>\n</li>\n</ul>\n<p>基类指针指向派生类对象</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Base* pb = <span class=\"keyword\">new</span> Derive;  <span class=\"comment\">//偷懒写法</span></span><br><span class=\"line\">Base* pb = <span class=\"keyword\">static_cast</span>&lt;Base*&gt;(<span class=\"keyword\">new</span> Derive);</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><code>dynamic_cast&lt;type&gt;(expression)</code><ul>\n<li>主要应用于类层次间的向上转换Upcasting和向下转换Downcasting</li>\n<li>只适用于含有虚函数的类型之间的转换</li>\n</ul>\n</li>\n<li>RTTI,Run-time Type Identification, 运行时类型识别<ul>\n<li>通过<code>typeid</code>和<code>dynamic_cast</code>两个运算符实现RTTI</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Animal</span>()&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span><span class=\"keyword\">public</span> Animal&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span>:</span><span class=\"keyword\">public</span> Animal&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Bird</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Fly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size = <span class=\"number\">4</span>;</span><br><span class=\"line\">  Animal* allAnis[size];  <span class=\"comment\">//基类指针数组，父类指针数组指向所有派生类对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;-------------初始化-------------&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">  allAnis[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Dog</span>(<span class=\"string\">&quot;黑狗&quot;</span>);</span><br><span class=\"line\">  allAnis[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Bird</span>(<span class=\"string\">&quot;翠鸟&quot;</span>);</span><br><span class=\"line\">  allAnis[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Dog</span>(<span class=\"string\">&quot;白狗&quot;</span>);</span><br><span class=\"line\">  allAnis[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> <span class=\"built_in\">Bird</span>(<span class=\"string\">&quot;黄鸟&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  cout &lt;&lt;<span class=\"string\">&quot;-------------运行中-------------&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(Animal* pa:allAnis)&#123;  <span class=\"comment\">//基于范围的循环</span></span><br><span class=\"line\">    pa-&gt;<span class=\"built_in\">Speak</span>();</span><br><span class=\"line\">    pa-&gt;<span class=\"built_in\">Eat</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(*pa)==<span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(Dog))&#123;</span><br><span class=\"line\">      Dog* pd = <span class=\"keyword\">dynamic_cast</span>&lt;Dog*&gt;(pa);</span><br><span class=\"line\">      pd-&gt;<span class=\"built_in\">Run</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(*pa) == <span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(Bird))&#123;</span><br><span class=\"line\">      Bird* pb = <span class=\"keyword\">dynamic_cast</span>&lt;Bird*&gt;(pa);</span><br><span class=\"line\">      pb-&gt;<span class=\"built_in\">Fly</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"第6单元-异常\"   >\n          <a href=\"#第6单元-异常\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第6单元-异常\" class=\"headerlink\" title=\"第6单元 异常\"></a>第6单元 异常</h1>\n      \n        <h2 id=\"6-1-异常处理方式\"   >\n          <a href=\"#6-1-异常处理方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-1-异常处理方式\" class=\"headerlink\" title=\"6.1 异常处理方式\"></a>6.1 异常处理方式</h2>\n      <ul>\n<li><p>语法错误</p>\n<ul>\n<li>在编译和连接阶段就能发现、只有100%符合语法规则的代码才能编译通过，属于最容易发现、定位、排除、最不用担心的错误。</li>\n</ul>\n</li>\n<li><p>逻辑错误</p>\n<ul>\n<li>编写代码的思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决</li>\n</ul>\n</li>\n<li><p>运行时错误</p>\n<ul>\n<li>在运行期间发生的错误</li>\n<li>除数为0、内存分配失败、数组越界、文件不存在等</li>\n<li>放任不管的话会发生程序崩溃</li>\n</ul>\n</li>\n<li><p>C++通过<code>try</code>、<code>throw</code>、<code>catch</code>结构实现了异常的检测、抛出和捕获</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  可能产生异常的语句或函数;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(异常类型<span class=\"number\">1</span>)&#123;处理异常的语句;&#125;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(异常类型<span class=\"number\">2</span>)&#123;处理异常的语句;&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(...)&#123;处理异常的语句&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>通常情况下，<code>try</code>语句中不包含抛出异常的语句，而是调用的函数如果发生异常，就通过<code>throw</code>关键字抛出异常。函数的上层调用者通过<code>try...catch</code>语句检测、捕获异常，并对异常进行处理。</li>\n<li>如果函数调用者也不能处理异常，则异常会即系向上一层调用者传递，直到异常被处理为止。如果最终异常没有被处理，则C++运行系统就会捕捉异常，终止程序运行。</li>\n<li>C++的异常处理机制使得异常的引发和处理不必在同一函数中完成，函数的调用者可以在适当的位置对函数排除的异常进行处理。这样，底层的函数可以着重解决具体的业务问题而不必考虑对异常的处理，而整个程序中相同类型的异常可以进行集中处理。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyString</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s = <span class=\"string\">&quot;&quot;</span>)&#123;_s = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(s)+<span class=\"number\">1</span>];<span class=\"built_in\">strcpy</span>(_s,s);&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>()&#123;<span class=\"keyword\">delete</span>[] _s;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> MyString&amp; s);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> index)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(index&lt;<span class=\"number\">0</span> || index &gt;= <span class=\"built_in\">strlen</span>(_s)) <span class=\"keyword\">throw</span> (<span class=\"string\">&quot;下标越界&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _s[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* _s;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">MyString <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;abc&quot;</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt;str &lt;&lt;endl;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    str[<span class=\"number\">3</span>]=<span class=\"string\">&#x27;C&#x27;</span>;</span><br><span class=\"line\">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;异常:&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>使用<code>try...catch</code>的注意事项<ul>\n<li>一个语句中只能有一个try块，但可以有多个catch语句块，以便与不同的异常类型匹配。<code>catch</code>语句必须有参数，如果<code>try</code>语句块中的代码抛出了异常，无论抛出的异常的值是什么，只要异常的类型与<code>catch</code>的参数类型匹配，异常就会被<code>catch</code>语句捕获。最后一个<code>catch</code>语句参数为<code>...</code>符号，表示可以捕获任意类型的异常。</li>\n<li>一旦某个<code>catch</code>语句捕获到了异常，后面的<code>catch</code>语句将不再被执行，其用法类似<code>switch...case</code>语句。</li>\n<li><code>try</code>和<code>catch</code>语句块中的代码必须使用大括号<code>&#123;&#125;</code>括起来，即使语句块中只有一行代码。</li>\n<li><code>try</code>语句和<code>catch</code>语句不能单独使用，必须连起来一起使用。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"6-2-栈解旋\"   >\n          <a href=\"#6-2-栈解旋\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-2-栈解旋\" class=\"headerlink\" title=\"6.2 栈解旋\"></a>6.2 栈解旋</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Demo</span>(<span class=\"keyword\">int</span> nn):<span class=\"built_in\">no</span>(nn)&#123;</span><br><span class=\"line\">      cout &lt;&lt;<span class=\"string\">&quot;创建对象&quot;</span>&lt;&lt;no&lt;&lt;<span class=\"string\">&quot;...&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">      ++cout;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(cout&gt;<span class=\"number\">2</span>) <span class=\"keyword\">throw</span>(<span class=\"string\">&quot;对象数量达到上限&quot;</span>);</span><br><span class=\"line\">      cout&lt;&lt;<span class=\"string\">&quot;创建成功！！&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Demo</span>()&#123;</span><br><span class=\"line\">      --cout;</span><br><span class=\"line\">      cout&lt;&lt;<span class=\"string\">&quot;释放对象&quot;</span>&lt;&lt;no&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> no;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Demo::cout = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Demo <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Demo <span class=\"title\">y</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Demo <span class=\"title\">z</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)&#123;</span><br><span class=\"line\">    cout &lt;&lt;<span class=\"string\">&quot;异常：&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>C++在异常处理前释放所有局部对象。释放的顺序与创建的顺序相反。</li>\n<li>但是，栈解旋只能释放栈对象，不能释放堆对象。要在<code>catch</code>中<code>delete</code></li>\n</ul>\n\n        <h2 id=\"6-3-标准异常\"   >\n          <a href=\"#6-3-标准异常\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-3-标准异常\" class=\"headerlink\" title=\"6.3 标准异常\"></a>6.3 标准异常</h2>\n      <ul>\n<li><p>在大多数关于异常的初级文章中，往往会以各种简单类型作为异常类型。</p>\n</li>\n<li><p>C++<exception>提供了一系列标准异常，它们时以父子类层次结构组织起来的。</p>\n</li>\n<li><p>C++<exception>提供了一系列标准异常，它们是以父子类层次结构组织的。我们可以：</p>\n<ol>\n<li>在程序中使用这些标准异常</li>\n<li>通过继承和重载<code>exception</code>类来定义新的异常。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyString</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s = <span class=\"string\">&quot;&quot;</span>)&#123;_s = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(s)+<span class=\"number\">1</span>];<span class=\"built_in\">strcpy</span>(_s,s);&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>()&#123;<span class=\"keyword\">delete</span>[] _s;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> MyString&amp; s);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> index)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(index&lt;<span class=\"number\">0</span> || idnex &gt;= <span class=\"built_in\">strlen</span>(_s)) <span class=\"keyword\">throw</span> <span class=\"built_in\">out_of_range</span>(<span class=\"string\">&quot;下标越界&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _s[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* _s;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">MyString <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;abc&quot;</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt;str &lt;&lt;endl;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    str[<span class=\"number\">3</span>]=<span class=\"string\">&#x27;C&#x27;</span>;</span><br><span class=\"line\">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (exception&amp; e)&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;异常:&quot;</span>&lt;&lt;e.<span class=\"built_in\">what</span>()&lt;&lt;endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>异常规范说明的语法：<ul>\n<li><code>函数返回值类型函数名(形参表) throw(异常类型1,异常类型2,...);</code></li>\n<li><code>函数返回值类型函数名(形参表) throw();</code></li>\n</ul>\n</li>\n<li>C++11有了<code>noexcept</code>，用来不抛出异常</li>\n</ul>\n\n        <h2 id=\"6-4-断言\"   >\n          <a href=\"#6-4-断言\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-4-断言\" class=\"headerlink\" title=\"6.4 断言\"></a>6.4 断言</h2>\n      <ul>\n<li>C++从C语言继承了<code>assert</code>、<code>#error</code>两个方法，用来检查错误的。</li>\n<li><code>assert</code>是运行时的断言，它用来发现运行期间的错误，不能提前到编译期发生错误，也不具有强制性，也谈不上改善编译信息的可读性。既然是运行期检查，对性能肯定是有影响的，所以在发型版本中，<code>assert</code>都会被关掉。</li>\n<li><code>#error</code>仅仅能在预编译时显示一个错误信息，可以配合<code>#ifdef/ifndef</code>参与预编译的条件检查。由于它无法获得编译信息，当然，也就做不了进一步分析了。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;exception&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> age = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(age &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">  cout&lt;&lt;age&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>C++11中引入了<code>static_assert</code>这个关键字，用来做编译期间的断言，因此叫做静态断言。语法：</li>\n<li>static_assert(常量表达式,”提示字符串”)</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">static_assert</span></span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>)==<span class=\"number\">8</span>,<span class=\"string\">&quot;64-bit code generation is not supported&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>断言还是异常？<ul>\n<li>断言表示程序写错了，只要发生断言(准确的说，应该是断言失败)，意味着至少有一个人得修改代码。它的性质如同编译错误。</li>\n<li>如果代码书写完全正确，但因外界环境或用户操作仍然可能发生的事件，都不适合用断言，可以使用异常，或者条件判断处理。</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第7章-IO流\"   >\n          <a href=\"#第7章-IO流\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第7章-IO流\" class=\"headerlink\" title=\"第7章 IO流\"></a>第7章 IO流</h1>\n      \n        <h2 id=\"7-1-IO流类库\"   >\n          <a href=\"#7-1-IO流类库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-1-IO流类库\" class=\"headerlink\" title=\"7.1 IO流类库\"></a>7.1 IO流类库</h2>\n      <ul>\n<li><p>输入/输出 用于完成数据传输。C++支持两种I/O操作：</p>\n<ol>\n<li>C语言的I/O函数</li>\n<li>另一种是面向对象的I/O流类库。流是对数据从一个对象到另一个对象的传送过程的抽象。</li>\n</ol>\n</li>\n<li><p>在针对文本类型的数据，还可以和插入运算符&lt;&lt;和提取运算符&gt;&gt;配合使用。</p>\n</li>\n<li><p>C语言的IO解决方案</p>\n<ul>\n<li>使用<code>scanf()</code>、<code>gets()</code>等函数从键盘读取数据。</li>\n<li>使用<code>printf()</code>、<code>puts()</code>等函数向屏幕上输出数据。</li>\n<li>使用<code>fscanf()</code>、<code>fgets()</code>等函数读取文件中的数据。</li>\n<li>使用<code>fprintf()</code>、<code>fputs()</code>等函数向文件中写入数据。</li>\n</ul>\n</li>\n<li><p>C++的IO解决方案</p>\n<ul>\n<li>标准IO：cin接收从键盘输入的数据，用cout向屏幕上输出数据</li>\n<li>文件IO：通过定义<code>ifstream</code>和<code>ofstream</code>的对象，进行数据的读写操作</li>\n<li>字符串流(stringstream)</li>\n</ul>\n</li>\n<li><p>IO流类库的层次结构</p>\n<ul>\n<li>流类库具有两个独立的基类：streambuf和ios类，所有流类均是其中一个的子类</li>\n<li>最常用的三个类：<ul>\n<li>iostream，<iostream>控制台的输入、输出</li>\n<li>fstream，<fstream>文件的读写</li>\n<li>stringstream，<sstream>字符串流的处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>streambuf类库</p>\n<ul>\n<li>streambuf提供了缓冲区操作的接口，它的子类隐藏了大量操作的细节。</li>\n<li>stringstream包含了一个它的子类stringstreambuf，以提供字符串的格式化读取和输出操作。</li>\n<li>fstream也包含了它的一个子类filebuf，以避免大量的IO操作。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"7-2-标准IO流\"   >\n          <a href=\"#7-2-标准IO流\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-2-标准IO流\" class=\"headerlink\" title=\"7.2 标准IO流\"></a>7.2 标准IO流</h2>\n      <ul>\n<li>预定义流对象</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>对象名</th>\n<th>所属类</th>\n<th>对应设备</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cin</td>\n<td>istream</td>\n<td>键盘</td>\n<td>标准输入，有缓冲</td>\n</tr>\n<tr>\n<td>cout</td>\n<td>ostream</td>\n<td>屏幕</td>\n<td>标准输出，无缓冲</td>\n</tr>\n<tr>\n<td>cerr</td>\n<td>ostream</td>\n<td>屏幕</td>\n<td>标准错误输出，无缓冲</td>\n</tr>\n<tr>\n<td>clog</td>\n<td>ostream</td>\n<td>屏幕</td>\n<td>标准日志输出，有缓冲</td>\n</tr>\n</tbody></table></div>\n<ul>\n<li><p>ostream有19个重载！真他妈的强！</p>\n</li>\n<li><p>同printf类似，也可以进行格式化输出，例如选择进制、对齐方式、精度等等</p>\n</li>\n<li><p>除&lt;&lt;之外，还提供了很多成员函数，包括：</p>\n<ul>\n<li>put，输出字符，例如cout.put(‘A’).put(‘\\n’);</li>\n<li>write，输出字符串</li>\n</ul>\n</li>\n<li><p>输入流对象cin和提取运算符&gt;&gt;结合使用，可以用于各种类型数据的输入。</p>\n</li>\n<li><p>以空白(包括空格、Enter、Tab)为分隔符。</p>\n</li>\n<li><p>流输入运算符的重载</p>\n<ul>\n<li>除&gt;&gt;之外，还提供了很多成员函数，包括：<ul>\n<li>get()函数，用于读取指定长度的字符或者遇到结束标志(可以指定)为止。</li>\n<li>getline()函数，用于读取指定长度的字符或者遇到结束标志(可以指定)为止。</li>\n<li>read()读取指定字符个数的字符串。</li>\n<li>ignore()跳过n个字符。</li>\n<li>gcount()统计上次读取的字符个数。</li>\n<li>peek()检测输入流中读取的字符。</li>\n<li>putback()将上一次读取的字符放回输入流中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何判断输入结束？</p>\n<ul>\n<li>在输入数据的多少不确定，且没有结束标志的情况下，该如何判断输入数据已经读完了呢？<ol>\n<li>读取文件时，到达文件末尾就读取结束。</li>\n<li>在控制台输入特殊的控制字符就表示输入结束。<ul>\n<li>在Windows系统中，按<code>Ctrl+Z</code>组合键后再按回车键，代表输入结束。</li>\n<li>在UNIX/Linux/Mac OS系统中，<code>Ctrl+D</code>代表输入结束。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"7-3-文件流\"   >\n          <a href=\"#7-3-文件流\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-3-文件流\" class=\"headerlink\" title=\"7.3 文件流\"></a>7.3 文件流</h2>\n      <ul>\n<li><p>常见的C++文件操作，包括(但不限于)打开文件、读取和追加数据、插入和删除数据、关闭文件、删除文件等。</p>\n</li>\n<li><p>为了方便用户实现文件操作，C++提供了3个文件流类</p>\n<ul>\n<li>ofstream(实现写文件)</li>\n<li>ifstream(实现读文件)</li>\n<li>fstream(实现读写文件)</li>\n<li>均包含在<fstream></li>\n</ul>\n</li>\n<li><p>关于文件操作，虽然在C++程序中可以继续沿用C语言的那套文件操作方式，但更推荐使用适当的文件流类来读写文件。</p>\n</li>\n<li><p>调用无参构造函数创建文件流对象</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">ifstream ifs; <span class=\"comment\">//定义一个文件输入流对象</span></span><br><span class=\"line\">ofstream ofs; <span class=\"comment\">//定义一个文件输出流对象</span></span><br><span class=\"line\">fstream fs;   <span class=\"comment\">//定义一个文件输入、输出流对象</span></span><br></pre></td></tr></table></div></figure></li>\n<li><p>调用有参构造函数创建文件流对象</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">ifs</span><span class=\"params\">(<span class=\"string\">&quot;filename&quot;</span>,ios::in)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">ofs</span><span class=\"params\">(<span class=\"string\">&quot;filename&quot;</span>,ios::out)</span></span>;</span><br><span class=\"line\"><span class=\"function\">fstream <span class=\"title\">fs</span><span class=\"params\">(<span class=\"string\">&quot;filename&quot;</span>,ios::in|ios::out)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//ifstream类默认文件打开模式为ios::in，ofstream类默认文件打开模式为ios::out，fstream类默认文件打开模式为ios::in|ios::out</span></span><br></pre></td></tr></table></div></figure></li>\n<li><p>打开文件</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename, <span class=\"keyword\">int</span> mode)</span></span>;  <span class=\"comment\">//封装的声明</span></span><br><span class=\"line\"></span><br><span class=\"line\">ofstream ofs; <span class=\"comment\">//创建文件流对象</span></span><br><span class=\"line\">ofs.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;Hellp.txt&quot;</span>,ios::in|ios::out|ios::binary);<span class=\"comment\">//多种打开模式组合使用</span></span><br></pre></td></tr></table></div></figure></li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>文件打开模式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ios::in</td>\n<td>以只读模式打开文件，若文件不存在，则发生错误</td>\n</tr>\n<tr>\n<td>ios::out</td>\n<td>以只写模式打开文件，写入时覆盖写入；若文件不存在，则创建一个新文件</td>\n</tr>\n<tr>\n<td>ios::app</td>\n<td>以追加模式打开文件，若文件不存在，则创建一个新文件</td>\n</tr>\n<tr>\n<td>ios::ate</td>\n<td>打开一个已存在文件，并将文件位置指针移动到文件末尾</td>\n</tr>\n<tr>\n<td>ios::trunc</td>\n<td>打开一个文件，将文件内容删除。若文件不存在，则创建一个新文件</td>\n</tr>\n<tr>\n<td>ios::binary</td>\n<td>以二进制方式打开文件</td>\n</tr>\n</tbody></table></div>\n<ul>\n<li><p>关闭文件</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">ifstream ifs;</span><br><span class=\"line\">ifs.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;Hello.txt&quot;</span>,ios::in);</span><br><span class=\"line\">ifs.<span class=\"built_in\">close</span>();  <span class=\"comment\">//关闭文件</span></span><br></pre></td></tr></table></div></figure></li>\n<li><p>文件读写</p>\n<ul>\n<li>文本文件<ul>\n<li><blockquote>\n<blockquote>\n<p>和&lt;&lt;</p>\n</blockquote>\n</blockquote>\n</li>\n<li>文件流类的成员函数</li>\n</ul>\n</li>\n<li>二进制文件<ul>\n<li>文件流类的成员函数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二进制文件</p>\n<ul>\n<li>节省空间</li>\n<li>方便检索</li>\n<li>还可以进行随机读写</li>\n</ul>\n</li>\n<li><p>小例子</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt; intList;  <span class=\"comment\">//整数线性表</span></span><br><span class=\"line\">  ifstream ifs;</span><br><span class=\"line\">  ifs.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;in.txt&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ifs) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  ofstream ofs;</span><br><span class=\"line\">  ofs.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;out.txt&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ofs) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"comment\">//从in.txt中读取数字，编码需要时ANSI编码，是默认的C++编码</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(ifs&gt;&gt;temp)<span class=\"comment\">//Ctrl+Z</span></span><br><span class=\"line\">  <span class=\"comment\">//while(cin&gt;&gt;temp)</span></span><br><span class=\"line\">    intList.push.<span class=\"built_in\">back</span>(temp);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//排序</span></span><br><span class=\"line\">  intList.<span class=\"built_in\">sort</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//输出结果到屏幕</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x:intList)</span><br><span class=\"line\">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">//基于范围的for循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ifs.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">  ofs.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n\n        <h2 id=\"7-4-字符串流\"   >\n          <a href=\"#7-4-字符串流\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-4-字符串流\" class=\"headerlink\" title=\"7.4 字符串流\"></a>7.4 字符串流</h2>\n      <ul>\n<li>字符串流是以string对象为输入/输出对象的数据流，这些数据流的传输再内存中完成，因此也被称为内存流。<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\">istringstream<span class=\"comment\">//把一个数字字符串转换成对应的数值</span></span><br><span class=\"line\">ostringstream<span class=\"comment\">//构造字符串</span></span><br><span class=\"line\">stringstream</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">stringstream <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">&quot;3.1415926&quot;</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">float</span> f;</span><br><span class=\"line\">  ss &gt;&gt; f;  <span class=\"comment\">//把一个数字字符串转换成对应的数值</span></span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;f=&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">  ss.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">  ss &lt;&lt; <span class=\"string\">&quot;π=&quot;</span> &lt;&lt; f &lt;&lt; endl;  <span class=\"comment\">//构造字符串</span></span><br><span class=\"line\">  string str = ss.<span class=\"built_in\">str</span>();</span><br><span class=\"line\">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n\n        <h1 id=\"第8章-模板\"   >\n          <a href=\"#第8章-模板\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第8章-模板\" class=\"headerlink\" title=\"第8章 模板\"></a>第8章 模板</h1>\n      \n        <h2 id=\"8-1-模板的概念\"   >\n          <a href=\"#8-1-模板的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-1-模板的概念\" class=\"headerlink\" title=\"8.1 模板的概念\"></a>8.1 模板的概念</h2>\n      <ul>\n<li><p>模板是C++支持参数化多态的工具，是<strong>泛型编程</strong>的基础。</p>\n</li>\n<li><p>模板可以实现<strong>类型参数化</strong>，即把类型定义为参数，真正实现了代码的<strong>可重用性</strong>，减小了编程级维护的工作量，降低了编程难度。</p>\n</li>\n<li><p>模板分为<strong>函数模板</strong>和<strong>类模板</strong>。</p>\n</li>\n<li><p>下面三个重载函数</p>\n<ul>\n<li><code>int max(int a,int b)&#123;return a&gt;b?a:b;&#125;</code></li>\n<li><code>float max(float a,float b)&#123;return a&gt;b?a:b;&#125;</code></li>\n<li><code>std::string max(std::string a,std::string b)&#123;return a&gt;b?a:b;&#125;</code></li>\n</ul>\n</li>\n<li><p>这三个函数，除了类型不一致，其他都是一模一样的。</p>\n</li>\n<li><p>C++属于<strong>强类型</strong>的编程语言</p>\n<ul>\n<li>编译器在程序运行前就要进行类型检查并分配内存。</li>\n</ul>\n</li>\n<li><p>导致程序员为逻辑结构相同而具体数据类型不同的对象编写基本一样的代码。</p>\n</li>\n<li><p>C++提供了模板机制，可以把类型参数化。带类型参数的函数称为函数模板，带类型参数的类称为类模板。</p>\n</li>\n<li><p>实例化</p>\n<ul>\n<li>在运行时，编译器会根据实际的数据类型参数生成一段相应的可执行代码，这个过程称为模板实例化。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"8-2-函数模板\"   >\n          <a href=\"#8-2-函数模板\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-2-函数模板\" class=\"headerlink\" title=\"8.2 函数模板\"></a>8.2 函数模板</h2>\n      <ul>\n<li><p>语法格式</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1 [,TYPENAME T2,……]&gt; <span class=\"comment\">//后面没有;</span></span><br><span class=\"line\">返回值类型 函数名(参数列表)&#123;<span class=\"comment\">/**函数体/&#125;</span></span><br></pre></td></tr></table></div></figure></li>\n<li><p>template(模板)和typename(类型名)都是关键字；</p>\n<ul>\n<li>早期的C++使用class表示模板参数，但是不能使用struct</li>\n</ul>\n</li>\n<li><p>T1,T2……表示模板参数(类型形参)</p>\n<ul>\n<li>使用&lt;&gt;括起来，将来在调用函数模板时也需要&lt;&gt;把类型实参括起来</li>\n<li>常用的标识符如T、T1、T2、U、V等。</li>\n</ul>\n</li>\n<li><p>在返回值类型、参数列表、函数体中，均可使用模板参数。</p>\n</li>\n</ul>\n\n        <h3 id=\"8-2-2-模板的实例化\"   >\n          <a href=\"#8-2-2-模板的实例化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-2-2-模板的实例化\" class=\"headerlink\" title=\"8.2.2 模板的实例化\"></a>8.2.2 模板的实例化</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//编译时将 函数模板 转换为 模板函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">Add</span><span class=\"params\">(T a,T b)</span></span>&#123;<span class=\"keyword\">return</span> a + b;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;Add&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>,<span class=\"number\">2</span>)&lt;&lt;endl;</span><br><span class=\"line\">  cout&lt;&lt;Add&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">1.2</span>,<span class=\"number\">3.4</span>)&lt;&lt;endl;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"built_in\">Add</span>(<span class=\"number\">1.2f</span>,<span class=\"number\">3.4f</span>)&lt;&lt;endl; <span class=\"comment\">//隐式实例化</span></span><br><span class=\"line\">  cout&lt;&lt;<span class=\"built_in\">Add</span>(<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"number\">32</span>)&lt;&lt;endl;  <span class=\"comment\">//这个会报错</span></span><br><span class=\"line\">  cout&lt;&lt;Add&lt;<span class=\"keyword\">char</span>&gt;(<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"number\">32</span>)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>编译器会根据具体的调用情况，在目标文件中，把函数模板实例化成若干个函数。</li>\n<li>通过函数模板，可以定义一系列的函数，这些函数都基于同一份代码，但是可以作用在不同类型的数据上。</li>\n</ul>\n\n        <h3 id=\"8-2-3-函数模板重载\"   >\n          <a href=\"#8-2-3-函数模板重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-2-3-函数模板重载\" class=\"headerlink\" title=\"8.2.3 函数模板重载\"></a>8.2.3 函数模板重载</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">Add</span><span class=\"params\">(T a,T b)</span></span>&#123;<span class=\"keyword\">return</span> a+b;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">Add</span><span class=\"params\">(T a,T b,T c)</span></span>&#123;<span class=\"keyword\">return</span> a + b + c;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">double</span> a, <span class=\"keyword\">double</span> b)</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;这是一个非模板函数&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"built_in\">Add</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>)&lt;&lt;endl;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"built_in\">Add</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)&lt;&lt;endl;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"built_in\">Add</span>(<span class=\"number\">1.2</span>,<span class=\"number\">3.4</span>)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>函数模板也可以重载</li>\n<li>非模板函数优先于模板函数</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Complex</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o, <span class=\"keyword\">const</span> Complex&amp; c);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Complex</span>(<span class=\"keyword\">float</span> xx,<span class=\"keyword\">float</span> yy);</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> Comlpex&amp; other)<span class=\"keyword\">const</span>;<span class=\"comment\">//这里得是常函数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">float</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//T对应的类型实参，必须要支持函数模板中所有的操作。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; a,<span class=\"keyword\">const</span> T&amp; b)</span></span>&#123; <span class=\"comment\">//这里是常对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;<span class=\"comment\">//常对象只能调用常函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Complex <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span>,<span class=\"title\">c2</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt;<span class=\"built_in\">Max</span>(c1,c2)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"8-3-类模板\"   >\n          <a href=\"#8-3-类模板\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-3-类模板\" class=\"headerlink\" title=\"8.3 类模板\"></a>8.3 类模板</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1[,<span class=\"keyword\">typename</span> T2,……]&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名&#123;</span>……&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>关键字的含义和函数模板相同。</li>\n<li>类模板实例化的过程与函数模板实例化的过程类似，但是模板函数允许隐式实例化，而类模板的实例化不能省略模板的参数。<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;<span class=\"function\">T <span class=\"title\">max</span><span class=\"params\">(T a,T b)</span></span>&#123;……;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"built_in\">max</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>); <span class=\"comment\">//等价于int a = max&lt;int&gt;(1,2);</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;Array&#123;……&#125;;</span><br><span class=\"line\">Array&lt;<span class=\"keyword\">int</span>&gt;intArray; <span class=\"comment\">//不能省略模板参数</span></span><br></pre></td></tr></table></div></figure></li>\n</ul>\n\n        <h3 id=\"类模板的成员函数的类外实现\"   >\n          <a href=\"#类模板的成员函数的类外实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#类模板的成员函数的类外实现\" class=\"headerlink\" title=\"类模板的成员函数的类外实现\"></a>类模板的成员函数的类外实现</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  函数类型 函数名(参数列表);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">函数类型 类名::函数名(参数列表)&#123;函数体;&#125;</span><br><span class=\"line\"><span class=\"comment\">//模板的声明和实现都必须写在.cpp文件中</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>小例子</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Array.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> Array&lt;T&gt;&amp; a);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Array</span>(T a[],<span class=\"keyword\">int</span> size);</span><br><span class=\"line\">  ~<span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  T* _ptr;  <span class=\"comment\">//用指针指向动态数组</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size;  <span class=\"comment\">//数组的大小</span></span><br><span class=\"line\">&#125;;  <span class=\"comment\">//动态数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> Array&lt;T&gt;&amp; a)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;a._size;++i)</span><br><span class=\"line\">    o&lt;&lt;a._ptr[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Array&lt;T&gt;::<span class=\"built_in\">Array</span>(T a[],<span class=\"keyword\">int</span> size):_size(size)&#123;</span><br><span class=\"line\">  _ptr = <span class=\"keyword\">new</span> T[_size];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;_size;++i)</span><br><span class=\"line\">    _ptr[i] = a[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Array&lt;T&gt;::~<span class=\"built_in\">Array</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] _ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Array.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">  <span class=\"function\">Array&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intArr</span><span class=\"params\">(a,<span class=\"number\">6</span>)</span></span>; <span class=\"comment\">//用普通数组初始化Array对象</span></span><br><span class=\"line\">  cout &lt;&lt; intArr &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">char</span> charA[]=<span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">  <span class=\"function\">Array&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">charArr</span><span class=\"params\">(charA,<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt; charArr &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Array.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> Array&lt;T&gt;&amp; a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt; &lt;&gt;(ostream&amp; o,<span class=\"keyword\">const</span> Array&lt;T&gt;&amp; a);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Array</span>(T a[],<span class=\"keyword\">int</span> size);</span><br><span class=\"line\">  ~<span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  T* _ptr;  <span class=\"comment\">//用指针指向动态数组</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size;  <span class=\"comment\">//数组的大小</span></span><br><span class=\"line\">&#125;;  <span class=\"comment\">//动态数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> Array&lt;T&gt;&amp; a)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;a._size;++i)</span><br><span class=\"line\">    o&lt;&lt;a._ptr[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Array&lt;T&gt;::<span class=\"built_in\">Array</span>(T a[],<span class=\"keyword\">int</span> size):_size(size)&#123;</span><br><span class=\"line\">  _ptr = <span class=\"keyword\">new</span> T[_size];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;_size;++i)</span><br><span class=\"line\">    _ptr[i] = a[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Array&lt;T&gt;::~<span class=\"built_in\">Array</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] _ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Array.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">  <span class=\"function\">Array&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intArr</span><span class=\"params\">(a,<span class=\"number\">6</span>)</span></span>; <span class=\"comment\">//用普通数组初始化Array对象</span></span><br><span class=\"line\">  cout &lt;&lt; intArr &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">char</span> charA[]=<span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">  <span class=\"function\">Array&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">charArr</span><span class=\"params\">(charA,<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt; charArr &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"类模板与友元函数\"   >\n          <a href=\"#类模板与友元函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#类模板与友元函数\" class=\"headerlink\" title=\"类模板与友元函数\"></a>类模板与友元函数</h3>\n      <ol>\n<li>将普通函数声明为友元函数<ul>\n<li>多个全局函数只需要声明一次友元</li>\n</ul>\n</li>\n<li>约束模板友元函数<ul>\n<li>在类模板内部声明模板函数为友元</li>\n</ul>\n</li>\n<li>非约束模板友元函数<ul>\n<li>在类模板内部声明函数模板为友元</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"区别\"   >\n          <a href=\"#区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3>\n      <ul>\n<li>类模板</li>\n<li>模板类</li>\n<li>函数模板</li>\n<li>模板函数</li>\n</ul>\n<p>指定了<T>的类型就会具体化成某一个类或函数，也就成为了模板类或模板函数，否则就是一个通用的模板，就称为类模板或函数模板</p>\n\n        <h1 id=\"第9章-STL\"   >\n          <a href=\"#第9章-STL\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第9章-STL\" class=\"headerlink\" title=\"第9章 STL\"></a>第9章 STL</h1>\n      \n        <h2 id=\"9-1-STL组成\"   >\n          <a href=\"#9-1-STL组成\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-1-STL组成\" class=\"headerlink\" title=\"9.1 STL组成\"></a>9.1 STL组成</h2>\n      <ul>\n<li>六大组件<ul>\n<li>容器Container</li>\n<li>迭代器Iterator</li>\n<li>算法Algorithm</li>\n<li>仿函数Functor</li>\n<li>适配器Adapter</li>\n<li>分配器Allocator</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"容器\"   >\n          <a href=\"#容器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3>\n      <p>容器是存储其他类型对象(类类型、简单类型均可)。这些被存储的对象必须是<strong>同一数据类型</strong>，称为容器的<strong>元素</strong>。容器是通过<strong>类模板</strong>实现的，包含了处理这些数据的常见方式。而且，不同的容器的同一个功能，其函数名也是相同的。这大大降低了使用者的学习成本。</p>\n\n        <h3 id=\"迭代器\"   >\n          <a href=\"#迭代器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3>\n      <ul>\n<li>重复repeat</li>\n<li>迭代iterate</li>\n<li>针对容器进行循环遍历时候的一种工具，扮演着容器和算法之间的胶合剂：对容器中数据的读和写，是通过迭代器完成的。</li>\n<li>迭代器模式(Iterator)，提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。</li>\n<li>数组：下标，链表：指针。迭代器是二者的合体，更像指针。</li>\n<li>STL提供了输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器五种类型的迭代器。</li>\n</ul>\n\n        <h3 id=\"算法\"   >\n          <a href=\"#算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3>\n      <ul>\n<li>算法是STL定义的一系列函数模板</li>\n<li>STL算法不依赖于容器的实现细节，只要容器的迭代器符合算法要求，算法就可以通过迭代器处理容器中的元素。</li>\n</ul>\n\n        <h3 id=\"仿函数\"   >\n          <a href=\"#仿函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#仿函数\" class=\"headerlink\" title=\"仿函数\"></a>仿函数</h3>\n      <ul>\n<li>仿函数也称为<strong>函数对象</strong>，通过重载()运算符实现，使类具有函数一样的行为。</li>\n<li>大多数STL算法可以使用一个仿函数作为参数，以达到某种数据操作的目的，使STL的应用更加灵活方便，增强了算法的通用性。</li>\n<li>例如，在排序算法中，可以使用仿函数less或greater作为参数，以实现数据从大到小或从小到大的排序。</li>\n</ul>\n\n        <h3 id=\"适配器\"   >\n          <a href=\"#适配器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h3>\n      <ul>\n<li><p>仿函数适配</p>\n</li>\n<li><p>迭代器适配</p>\n</li>\n<li><p>容器适配：采用特定的数据管理策略，能够使容器在操作数据时表现出另一种行为。</p>\n</li>\n<li><p>STL的三个容器适配器</p>\n<ul>\n<li>stack(栈)</li>\n<li>queue(队列)</li>\n<li>priority_queue(优先队列)</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"空间配置器\"   >\n          <a href=\"#空间配置器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#空间配置器\" class=\"headerlink\" title=\"空间配置器\"></a>空间配置器</h3>\n      <ul>\n<li>Allocate，分配，C语言中的malloc就是memory allocate的缩写</li>\n<li>C++标准库采用了<strong>分配器</strong>实现对象内存空间的分配和释放，封装了容器在内存管理上的低层细节。默认情况下，程序员也可自行定值分配器以替代之</li>\n</ul>\n\n        <h2 id=\"9-2-序列容器\"   >\n          <a href=\"#9-2-序列容器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-2-序列容器\" class=\"headerlink\" title=\"9.2 序列容器\"></a>9.2 序列容器</h2>\n      <p>也叫作顺序容器，序列容器各元素之间有顺序关系，每个元素都有固定位置，除非使用插入或删除操作改变这个元素的位置。序列容器是一种<strong>线性结构</strong>的有序群集。序列容器有<strong>连续存储</strong>和<strong>链式存储</strong>两种存储方式。</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>容器</th>\n<th>基本功能</th>\n<th>对应头文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>vector</td>\n<td>动态数组</td>\n<td>#include&lt;vector&gt;</td>\n</tr>\n<tr>\n<td>list</td>\n<td>双向链表</td>\n<td>#include&lt;list&gt;</td>\n</tr>\n<tr>\n<td>deque</td>\n<td>Double-ended queue双端队列</td>\n<td>#include&lt;deque&gt;</td>\n</tr>\n<tr>\n<td>array</td>\n<td>C++11，大小固定的数组</td>\n<td>#include&lt;array&gt;</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>C++11，单向(向后)链表</td>\n<td>#include&lt;forward_list&gt;</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"vector向量\"   >\n          <a href=\"#vector向量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#vector向量\" class=\"headerlink\" title=\"vector向量\"></a>vector向量</h3>\n      <ul>\n<li>动态数组，在插入或删除元素时能够<strong>自动调整自身大小</strong>。元素放置在<strong>连续内存空间</strong>中，可以使用迭代器对其进行访问和遍历。</li>\n<li>在<strong>插入/删除</strong>元素时，之后的元素都要被顺序地<strong>向后/向前</strong>移动，因此，vector容器<strong>插入/删除</strong>操作效率并不高。<strong>插入/删除</strong>位置越靠前，执行所需时间就越多，但在vector容器尾部<strong>插入/删除</strong>元素的效率比较高。</li>\n</ul>\n<p>容器的使用，首先要记住它是一个<strong>类模板</strong>，也就是说在STL的源代码中，应该有以下类似的代码<code>template&lt;typename T&gt;class vector&#123;&#125;;</code></p>\n<ol>\n<li>创建vector容器<ul>\n<li>要指定元素类型，还要匹配构造函数<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; v1; <span class=\"comment\">//定义一个整数的动态数组，大小未定。</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;string&gt; <span class=\"title\">v2</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;<span class=\"comment\">//定义一个大小为5的字符串数组。</span></span><br></pre></td></tr></table></div></figure></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>vector对象在定义后所有元素都会被初始化，如果是基本数据类型的容器，则都会被初始化为0；如果是其他类型容器，则由类的默认构造函数初始化。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v3</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">1</span>)</span></span>;<span class=\"comment\">//定一个整数动态数组，包含10个1.</span></span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; v4&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;<span class=\"comment\">//列表初始化。</span></span><br><span class=\"line\">vector&lt;string&gt; v5 = &#123;<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;efg&quot;</span>,<span class=\"string\">&quot;xyz&quot;</span>&#125;;<span class=\"comment\">//有没有=均可。</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v6</span><span class=\"params\">(v4)</span></span>; <span class=\"comment\">//等价于vector&lt;int&gt; v6 = v4；拷贝构造函数</span></span><br><span class=\"line\">vector&lt;Enemy*&gt;allEnemies; <span class=\"comment\">//父类指针数组，所有敌人。</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>容量和个数</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  vector&lt;<span class=\"keyword\">int</span>&gt; vi;</span><br><span class=\"line\">  cout&lt;&lt;vi.<span class=\"built_in\">capacity</span>()&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;vi.<span class=\"built_in\">size</span>()&lt;&lt;endl;  <span class=\"comment\">//0,0</span></span><br><span class=\"line\">  vi.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  cout&lt;&lt;vi.<span class=\"built_in\">capacity</span>()&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;vi.<span class=\"built_in\">size</span>()&lt;&lt;endl;  <span class=\"comment\">//1,1</span></span><br><span class=\"line\">  vi.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">  cout&lt;&lt;vi.<span class=\"built_in\">capacity</span>()&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;vi.<span class=\"built_in\">size</span>()&lt;&lt;endl;  <span class=\"comment\">//1,0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>访问容器中的元素</p>\n<ul>\n<li>vector重载了下标运算符[]，用来对元素进行读/写。<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; vi = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;++i) cout&lt;&lt;vi[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure></li>\n<li>同样会有下标越界的问题。</li>\n<li>vector还提供了at函数<code>vi.at(1)</code>等价于<code>vi[1];</code></li>\n</ul>\n</li>\n<li><p>获取头部和尾部</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; vi&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">cout&lt;&lt;vi.<span class=\"built_in\">front</span>()&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;vi.<span class=\"built_in\">back</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>从尾部插入和删除元素</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; vi;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;++i)vi.<span class=\"built_in\">push_back</span>(i+<span class=\"number\">1</span>);  <span class=\"comment\">//尾部插入1……5</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x:vi)cout&lt;&lt;x&lt;&lt;<span class=\"string\">&quot; &quot;</span>;  <span class=\"comment\">//输出：1 2 3 4 5</span></span><br><span class=\"line\">cout&lt;&lt;endl;</span><br><span class=\"line\">vi.<span class=\"built_in\">pop_back</span>();  <span class=\"comment\">//删除尾部的5</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x:vi)cout&lt;&lt;x&lt;&lt;<span class=\"string\">&quot; &quot;</span>;  <span class=\"comment\">//输出：1 2 3 4</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"迭代器的基本概念\"   >\n          <a href=\"#迭代器的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#迭代器的基本概念\" class=\"headerlink\" title=\"迭代器的基本概念\"></a>迭代器的基本概念</h3>\n      <ul>\n<li>迭代器：迭代的工具</li>\n<li>数据结构<ul>\n<li>连续<ul>\n<li><code>for(int i=0;i!=size;++i)a[i]……</code></li>\n<li><code>for(int *p=a;p!=a+size;++p)*p……</code></li>\n</ul>\n</li>\n<li>不连续<ul>\n<li><code>for(Node* p=head;p!=nullptr;p=p-&gt;next)p-&gt;data……</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>STL使用迭代器统一了循环变量和指针，来表示容器中元素的位置，并提供了对外访问的接口。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; vi;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; ::iterator itr; <span class=\"comment\">//不同的容器，迭代器实现的方式不一样。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(itr = vi.<span class=\"built_in\">begin</span>();itr!=itr.<span class=\"built_in\">end</span>();++itr)*itr……;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>循环变量或指针<ul>\n<li>定义</li>\n<li>初始值</li>\n<li>结束条件</li>\n<li>指向下一个元素</li>\n<li>操作元素</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"迭代器的基本运算\"   >\n          <a href=\"#迭代器的基本运算\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#迭代器的基本运算\" class=\"headerlink\" title=\"迭代器的基本运算\"></a>迭代器的基本运算</h3>\n      <ul>\n<li><p>通常，我们把迭代器对象就称之为迭代器。</p>\n</li>\n<li><p>迭代器可以执行++、–、与整数相加减的操作</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; vi&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt;::iterator itr = vi.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">cout&lt;&lt;*itr++&lt;&lt;endl; <span class=\"comment\">//1</span></span><br><span class=\"line\">cout&lt;&lt;*--itr&lt;&lt;endl; <span class=\"comment\">//1</span></span><br><span class=\"line\">cout&lt;&lt;*(itr+<span class=\"number\">3</span>)&lt;&lt;endl; <span class=\"comment\">//4</span></span><br></pre></td></tr></table></div></figure></li>\n<li><p>原因</p>\n<ul>\n<li>指向数组元素的指针、下标，都能够++、–、与整数相加减。</li>\n<li>指向双向链表的指针，可以++、–，但是不能一次性跳过几个结点。</li>\n</ul>\n</li>\n<li><p>vector获取迭代器的函数</p>\n</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>begin()</td>\n<td>首元素的位置</td>\n</tr>\n<tr>\n<td>end()</td>\n<td>最后一个元素的下一个位置</td>\n</tr>\n<tr>\n<td>rbegin()</td>\n<td>返回容器结束位置作为起始位置的反向迭代器</td>\n</tr>\n<tr>\n<td>rend()</td>\n<td>返回反向迭代的最后一个元素之后的位置的反向迭代器</td>\n</tr>\n<tr>\n<td>cbegin()</td>\n<td>返回容器中起始位置的常量迭代器，不能修改迭代器指向的内容</td>\n</tr>\n<tr>\n<td>cend()</td>\n<td>返回迭代器的结束位置的常量迭代器</td>\n</tr>\n<tr>\n<td>crbegin()</td>\n<td>返回容器结束位置作为起始位置的迭代器</td>\n</tr>\n<tr>\n<td>crend()</td>\n<td>返回第一个元素之前位置的常量迭代器</td>\n</tr>\n</tbody></table></div>\n<ul>\n<li>使用迭代器遍历容器<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">容器类型&lt;元素类型&gt;container;  <span class=\"comment\">//  定义容器container</span></span><br><span class=\"line\">……; <span class=\"comment\">//各种操作，比较常见的是container.push_back(……);</span></span><br><span class=\"line\">容器类型&lt;元素类型&gt;::iterator itr; <span class=\"comment\">//定义**某容器**的迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(itr=container.<span class=\"built_in\">begin</span>();itr!=container.<span class=\"built_in\">end</span>();++itr)</span><br><span class=\"line\">  *itr……; <span class=\"comment\">//迭代器重载了取值运算符*，使用*itr表示元素</span></span><br></pre></td></tr></table></div></figure></li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">list&lt;<span class=\"keyword\">int</span>&gt; li;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;++i)li.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">rand</span>()%<span class=\"number\">100</span>);</span><br><span class=\"line\">list&lt;<span class=\"keyword\">int</span>&gt;::iterator itr = li.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;itr!=li.<span class=\"built_in\">end</span>();++itr)cout&lt;&lt;*itr&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; vi&#123;<span class=\"number\">21</span>,<span class=\"number\">32</span>,<span class=\"number\">3</span>,<span class=\"number\">54</span>,<span class=\"number\">25</span>&#125;;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt;::iterator itr = vi.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;itr!=vi.<span class=\"built_in\">end</span>();++itr)cout&lt;&lt;*itr&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i!=vi.<span class=\"built_in\">size</span>();++i)cout&lt;&lt;vi[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"comment\">//取出首元素和尾元素</span></span><br><span class=\"line\">cout&lt;&lt;*vi.<span class=\"built_in\">begin</span>()&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;*vi.<span class=\"built_in\">end</span>();  <span class=\"comment\">//错误</span></span><br><span class=\"line\">cout&lt;&lt;*vi.<span class=\"built_in\">begin</span>()&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;*<span class=\"built_in\">prev</span>(vi.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(vi.<span class=\"built_in\">begin</span>(),vi.<span class=\"built_in\">end</span>());  <span class=\"comment\">//排序</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>vector的赋值函数</p>\n<ul>\n<li>vector重载了assign()，用于完成赋值操作<ul>\n<li>将n个elem赋值给vi，原有数据会被覆盖<ul>\n<li><code>vector&lt;int&gt;vi; vi.assign(n,elem);</code></li>\n</ul>\n</li>\n<li>将[begin,end)的元素赋值给容器<ul>\n<li><code>vector&lt;int&gt;vi; vi.assign(begin,end);</code></li>\n<li><code>int arr[]=&#123;1,2,3,4,5&#125;; vi.assign(arr,arr+3);</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在STL的函数语法中，往往用begin和end表示一个区间</p>\n</li>\n<li><p>[begin,end)指左闭右开区间</p>\n</li>\n<li><p>指向数组的指针，也可以当做迭代器。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//STL中算法的头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">4</span>]=&#123;……&#125;;</span><br><span class=\"line\">sort&#123;arr,arr+<span class=\"number\">4</span>&#125;;</span><br></pre></td></tr></table></div></figure></li>\n<li><p>迭代器的主要功能</p>\n<ul>\n<li>指定容器中元素的范围<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; vi&#123;<span class=\"number\">32</span>,<span class=\"number\">23</span>,<span class=\"number\">44</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">list&lt;<span class=\"keyword\">int</span>&gt;li;</span><br><span class=\"line\">li.<span class=\"built_in\">assign</span>(vi.<span class=\"built_in\">begin</span>(),vi.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(vi.<span class=\"built_in\">begin</span>(),vi.<span class=\"built_in\">end</span>());  <span class=\"comment\">//li.sort();正确，sort(li.begin(),li.end());错误</span></span><br></pre></td></tr></table></div></figure></li>\n<li>遍历容器</li>\n<li>对元素进行读写<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">list&lt;<span class=\"keyword\">int</span>&gt;::letrator itr = li.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;itr!=li.<span class=\"built_in\">end</span>();++itr)*itr*=<span class=\"number\">2</span>;</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"list\"   >\n          <a href=\"#list\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3>\n      <ul>\n<li>list容器以双向链表形式实现，list容器通过指针将前面的元素和后边的元素链接到一起</li>\n<li>同vector相比，list容器只能通过迭代器访问元素，不能通过索引方式访问元素。</li>\n<li>同为序列容器，list容器的接口大部分与vector都相同，所以读者学习起来也比较容易。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建list容器对象</span></span><br><span class=\"line\">list&lt;T&gt;lt;      <span class=\"comment\">//创建空list容器，元素类型为T</span></span><br><span class=\"line\">list&lt;T&gt;<span class=\"built_in\">lt</span>(n);   <span class=\"comment\">//创建list容器，大小为n</span></span><br><span class=\"line\">list&lt;T&gt;<span class=\"built_in\">lt</span>(n,elem);<span class=\"comment\">//包含n个elem</span></span><br><span class=\"line\">list&lt;T&gt;<span class=\"built_in\">lt</span>(begin,end);<span class=\"comment\">//用[begin,end)区间的元素初始化</span></span><br><span class=\"line\">list&lt;T&gt;<span class=\"built_in\">lt</span>(lt1); <span class=\"comment\">//使用lt1进行初始化</span></span><br><span class=\"line\"><span class=\"comment\">//赋值</span></span><br><span class=\"line\">lt.<span class=\"built_in\">assign</span>(n.elem);  <span class=\"comment\">//将n和elem赋值给lt</span></span><br><span class=\"line\">lt.<span class=\"built_in\">assign</span>(begin,end);<span class=\"comment\">//将[begin,end)区间的元素赋值给lt</span></span><br><span class=\"line\"><span class=\"comment\">//元素访问</span></span><br><span class=\"line\">list&lt;<span class=\"keyword\">int</span>&gt;li&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">cout&lt;&lt;li.<span class=\"built_in\">front</span>()&lt;&lt;<span class=\"string\">&quot;,&quot;</span>&lt;&lt;li.<span class=\"built_in\">back</span>()&lt;&lt;endl; <span class=\"comment\">//1,5</span></span><br><span class=\"line\">list&lt;<span class=\"keyword\">int</span>&gt;::iterator itr = li.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;itr!=li.<span class=\"built_in\">end</span>();++itr)*itr *= <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(itr=li.<span class=\"built_in\">begin</span>();itr!=li.<span class=\"built_in\">end</span>();++itr) <span class=\"comment\">//2 4 6 8 10</span></span><br><span class=\"line\">  cout&lt;&lt;*itr&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>list容器提供了以下四种迭代器，以及获取这些迭代器的成员函数。<ul>\n<li><code>iterator</code>、<code>const_iterator</code>、<code>reverse_iterator</code>、<code>const_reverse_iterator</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">push_back</span>(); <span class=\"comment\">//在尾部插入元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">push_front</span>();  <span class=\"comment\">//在头部插入元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">insert</span>(pos,elem);  <span class=\"comment\">//在pos位置插入元素elem</span></span><br><span class=\"line\">lt.<span class=\"built_in\">insert</span>(pos,n,elem);  <span class=\"comment\">//在pos位置插入n个元素elem</span></span><br><span class=\"line\">lt.<span class=\"built_in\">insert</span>(pos,begin,end); <span class=\"comment\">//在pos位置插入[begin,end)区间的值作为元素</span></span><br><span class=\"line\"><span class=\"comment\">//删除元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">pop_back</span>();  <span class=\"comment\">//从尾部删除元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">pop_front</span>(); <span class=\"comment\">//从头部删除元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">erase</span>(pos);  <span class=\"comment\">//从中间删除元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">erase</span>(begin,end);  <span class=\"comment\">//删除[begin,end)区间的元素</span></span><br><span class=\"line\">lt.<span class=\"built_in\">remove</span>(elem);  <span class=\"comment\">//从容器中删除所有与elem匹配的元素</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>小例子</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"keyword\">const</span> list&lt;<span class=\"keyword\">int</span>&gt;&amp; l)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x:l) out &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;lt;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) lt.<span class=\"built_in\">push_back</span>(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">  cout &lt;&lt; lt &lt;&lt; endl; <span class=\"comment\">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class=\"line\">  lt.<span class=\"built_in\">push_front</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">  cout &lt;&lt; lt &lt;&lt; endl; <span class=\"comment\">//5 1 2 3 4 5 6 7 8 9 10</span></span><br><span class=\"line\">  lt.<span class=\"built_in\">remove</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">  cout &lt;&lt; lt &lt;&lt; endl; <span class=\"comment\">//1 2 3 4 6 7 8 9 10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这段代码会生成无效迭代器，类似野指针，会导致程序崩溃</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;lt;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;++i)lt.<span class=\"built_in\">push_back</span>(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">  cout &lt;&lt; lt &lt;&lt; endl; <span class=\"comment\">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;::iterator itr;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(itr = lt.<span class=\"built_in\">begin</span>();itr!=lt.<span class=\"built_in\">end</span>();++itr)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*itr)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">      lt.<span class=\"built_in\">erase</span>(itr);  <span class=\"comment\">//无效迭代器,会导致崩溃</span></span><br><span class=\"line\">  cout&lt;&lt;lt&lt;&lt;endl; <span class=\"comment\">//1 3 5 7 9</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//解决上一个问题的稍微复杂的形式，用了中间变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;lt;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;++i) lt.<span class=\"built_in\">push_back</span>(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">  cout&lt;&lt;lt&lt;&lt;endl; <span class=\"comment\">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;::iterator itr,temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(itr = lt.<span class=\"built_in\">begin</span>();itr!=lt.<span class=\"built_in\">end</span>();<span class=\"comment\">/*++itr*/</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*itr)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//temp指向要删除的元素，itr指向下一个</span></span><br><span class=\"line\">      temp = itr++;</span><br><span class=\"line\">      lt.<span class=\"built_in\">erase</span>(temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      ++itr;</span><br><span class=\"line\">    cout&lt;&lt;lt&lt;&lt;endl; <span class=\"comment\">//1 3 5 7 9</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//解决上一个问题的标准形式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;lt;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;++i) lt.<span class=\"built_in\">push_back</span>(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">  cout&lt;&lt;lt&lt;&lt;endl; <span class=\"comment\">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;::iterator itr;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(itr = lt.<span class=\"built_in\">begin</span>();itr!=lt.<span class=\"built_in\">end</span>();<span class=\"comment\">/*++itr*/</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*itr)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//temp指向要删除的元素，让itr指向下一个，erase会返回下一个位置</span></span><br><span class=\"line\">      itr = lt.<span class=\"built_in\">erase</span>(itr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      ++itr;</span><br><span class=\"line\">    cout&lt;&lt;lt&lt;&lt;endl; <span class=\"comment\">//1 3 5 7 9</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"综合项目（多态、文件、容器）\"   >\n          <a href=\"#综合项目（多态、文件、容器）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#综合项目（多态、文件、容器）\" class=\"headerlink\" title=\"综合项目（多态、文件、容器）\"></a>综合项目（多态、文件、容器）</h3>\n      \n        <h4 id=\"文件流和容器\"   >\n          <a href=\"#文件流和容器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#文件流和容器\" class=\"headerlink\" title=\"文件流和容器\"></a>文件流和容器</h4>\n      <ul>\n<li>从文件中读入数据放进容器的一般步骤<ol>\n<li>打开文件；</li>\n<li>while(文件不为空)<ol>\n<li>文件对象&gt;&gt;容器;</li>\n</ol>\n</li>\n<li>关闭文件</li>\n</ol>\n</li>\n<li>定义list<int>li;把in.txt中的数据导入li中并遍历输出。</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>&gt;&gt;(ifstream&amp; file, list&lt;<span class=\"keyword\">int</span>&gt;&amp; l)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">  file&gt;&gt;temp;</span><br><span class=\"line\">  l.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  ifstream ifs;</span><br><span class=\"line\">  ifs.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;in.txt&quot;</span>,ios::in); <span class=\"comment\">//打开文件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ifs)&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;文件打开失败&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;li;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!ifs.<span class=\"built_in\">eof</span>()) <span class=\"comment\">//文件不为空</span></span><br><span class=\"line\">    ifs&gt;&gt;li;  <span class=\"comment\">//文件对象中的数据&gt;&gt;容器</span></span><br><span class=\"line\">  ifs.<span class=\"built_in\">close</span>();  <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x : li)cout&lt;&lt;x&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">  cout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"项目：所有学生\"   >\n          <a href=\"#项目：所有学生\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#项目：所有学生\" class=\"headerlink\" title=\"项目：所有学生\"></a>项目：所有学生</h4>\n      <ul>\n<li>功能需求：<ol>\n<li>所有学生Student都有名字name，都要学习Study；</li>\n<li>所有同学都要上体育课PE，但是男生打篮球play basketball，女生打排球play volleyball</li>\n<li>放学以后，男生打游戏PlayGame，女生去购物Shopping</li>\n</ol>\n</li>\n<li>基本数据来自于student.txt</li>\n<li>容器采用list或vector</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;Student.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; in,list&lt;student*&gt;&amp; allStus)&#123;</span><br><span class=\"line\">  string type,name;</span><br><span class=\"line\">  in&gt;&gt;type&gt;&gt;name;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(type==<span class=\"string\">&quot;男生&quot;</span>)</span><br><span class=\"line\">    allStus.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Boy</span>(name));</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    allStus.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Girl</span>(name));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  list&lt;Student*&gt; allStudents;</span><br><span class=\"line\">  ifstream ifs;</span><br><span class=\"line\">  ifs.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;student.txt&quot;</span>,ios::in);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ifs) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!ifs.<span class=\"built_in\">eof</span>())</span><br><span class=\"line\">    ifs&gt;&gt;allStudents;</span><br><span class=\"line\">  ifs.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(Student* ps:allStudents)&#123;</span><br><span class=\"line\">    ps-&gt;<span class=\"built_in\">Study</span>();</span><br><span class=\"line\">    ps-&gt;<span class=\"built_in\">PE</span>();</span><br><span class=\"line\">    <span class=\"comment\">//RTTI,运行时类型识别</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(*ps)==<span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(Boy))&#123;</span><br><span class=\"line\">      Boy* pb = <span class=\"keyword\">dynamic_cast</span>&lt;Boy*&gt;(ps);<span class=\"comment\">//向下类型转换</span></span><br><span class=\"line\">      pb-&gt;<span class=\"built_in\">PlayGame</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      Girl* pg=<span class=\"keyword\">dynamic_cast</span>&lt;Girl*&gt;(ps);</span><br><span class=\"line\">      pg-&gt;<span class=\"built_in\">Shopping</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Student.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Student</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Study</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">PE</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Boy</span>:</span><span class=\"keyword\">public</span> Student&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Boy</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PE</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PlayGame</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Girl</span>:</span><span class=\"keyword\">public</span> Student&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Girl</span>(string name);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PE</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Shopping</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Student.cpp</span></span><br><span class=\"line\">Student::<span class=\"built_in\">Student</span>(string str):<span class=\"built_in\">name</span>(str)&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Student::Study</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;name&lt;&lt;<span class=\"string\">&quot;在学习...&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Boy::<span class=\"built_in\">Boy</span>(string str):<span class=\"built_in\">Student</span>(str)&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Boy::PE</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;name&lt;&lt;<span class=\"string\">&quot;在打篮球...&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PlayGame</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;name&lt;&lt;<span class=\"string\">&quot;在打游戏...&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Girl::<span class=\"built_in\">Girl</span>(string str):<span class=\"built_in\">Student</span>(str)&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Girl::PE</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;name&lt;&lt;<span class=\"string\">&quot;在打排球...&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Girl::Shopping</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  cout&lt;&lt;name&lt;&lt;<span class=\"string\">&quot;在购物...&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"第10章-设计模式\"   >\n          <a href=\"#第10章-设计模式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第10章-设计模式\" class=\"headerlink\" title=\"第10章 设计模式\"></a>第10章 设计模式</h1>\n      \n        <h2 id=\"策略模式\"   >\n          <a href=\"#策略模式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Strategy.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Strategy</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Strategy</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">string</span> <span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">GetMoney</span><span class=\"params\">(<span class=\"keyword\">float</span> price, <span class=\"keyword\">float</span> count)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string describe;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Discount</span> :</span> <span class=\"keyword\">public</span> Strategy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Discount</span>(string str,<span class=\"keyword\">float</span> d);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GetMoney</span><span class=\"params\">(<span class=\"keyword\">float</span> price, <span class=\"keyword\">float</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> discount;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GiveGoods</span> :</span> <span class=\"keyword\">public</span> Strategy&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">GiveGoods</span>(string str,<span class=\"keyword\">float</span> m,<span class=\"keyword\">float</span> give);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GetMoney</span><span class=\"params\">(<span class=\"keyword\">float</span> price, <span class=\"keyword\">float</span> count)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> total;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> give;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GiveMoney</span> :</span> <span class=\"keyword\">public</span> Strategy&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Strategy.cpp</span></span><br><span class=\"line\">Strategy::<span class=\"built_in\">Strategy</span>(string str): <span class=\"built_in\">describe</span>(str)&#123;&#125;</span><br><span class=\"line\"><span class=\"function\">Strategy::<span class=\"keyword\">operator</span> <span class=\"title\">string</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> describe;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Discount::<span class=\"built_in\">Discount</span>(string str,flaot d):<span class=\"built_in\">Strategy</span>(str),<span class=\"built_in\">discount</span>(d)&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">Discount::GetMoney</span><span class=\"params\">(<span class=\"keyword\">float</span> price, <span class=\"keyword\">float</span> count)</span></span>&#123;<span class=\"keyword\">return</span> discount* price*count;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">GiveGoods::(string str,<span class=\"keyword\">float</span> m,<span class=\"keyword\">float</span> give): <span class=\"built_in\">Strategy</span>(str),<span class=\"built_in\">total</span>(m+give),<span class=\"built_in\">give</span>(g)&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GiveGoods::GetMoney</span><span class=\"params\">(<span class=\"keyword\">float</span> price, <span class=\"keyword\">float</span> count)</span></span>&#123;<span class=\"keyword\">return</span> price * (count - give * (<span class=\"keyword\">int</span>) (count/total));&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Strategy.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goods</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; out,<span class=\"keyword\">const</span> Goods&amp; g);</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Goods</span>(string s,<span class=\"keyword\">float</span> p,<span class=\"keyword\">float</span> c,Strategy* ss = <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GetMoney</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> price;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> count;</span><br><span class=\"line\">    Strategy* s;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Strategy* s1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Discount</span>(<span class=\"string\">&quot;打八折&quot;</span>,<span class=\"number\">0.8</span>);</span><br><span class=\"line\">  Strategy* s2 = <span class=\"keyword\">new</span> <span class=\"built_in\">GiveGoods</span>(<span class=\"string\">&quot;买二送一&quot;</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">  list&lt;Goods*&gt; cart;</span><br><span class=\"line\">  cart.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Goods</span>(<span class=\"string\">&quot;铅笔&quot;</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>));</span><br><span class=\"line\">  cart.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Goods</span>(<span class=\"string\">&quot;橡皮&quot;</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,s1));</span><br><span class=\"line\">  cart.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Goods</span>(<span class=\"string\">&quot;本子&quot;</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,s2));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">float</span> money = <span class=\"number\">0.0f</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(Goods* pg:cart)&#123;</span><br><span class=\"line\">    money +=pg-&gt;<span class=\"built_in\">GetMoney</span>();</span><br><span class=\"line\">    cout&lt;&lt;*pg&lt;&lt;endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;总金额:&quot;</span>&lt;&lt;money&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Goods::<span class=\"built_in\">Goods</span>(string s, <span class=\"keyword\">float</span> p, <span class=\"keyword\">float</span> c,<span class=\"keyword\">float</span> d,Strategy* ss): <span class=\"built_in\">name</span>(s),<span class=\"built_in\">price</span>(p),<span class=\"built_in\">count</span>(c),<span class=\"built_in\">discount</span>(d)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">Goods::GetMoney</span><span class=\"params\">()</span><span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s-&gt;<span class=\"built_in\">GetMoney</span>(price,count);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price*count;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; out,<span class=\"keyword\">const</span> Goods&amp; g)&#123;</span><br><span class=\"line\">  out&lt;&lt;g.name&lt;&lt;<span class=\"string\">&quot;:&quot;</span>&lt;&lt;g.price&lt;&lt;<span class=\"string\">&quot;*&quot;</span>&lt;&lt;g.count;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(g.s)</span><br><span class=\"line\">    out&lt;&lt;<span class=\"string\">&quot;(&quot;</span>&lt;&lt;(string)(*(g.s))&lt;&lt;<span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">  cout&lt;&lt;<span class=\"string\">&quot;=&quot;</span>&lt;&lt;g.<span class=\"built_in\">GetMoney</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"第11章-复习\"   >\n          <a href=\"#第11章-复习\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第11章-复习\" class=\"headerlink\" title=\"第11章 复习\"></a>第11章 复习</h1>\n      \n        <h2 id=\"初识C\"   >\n          <a href=\"#初识C\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#初识C\" class=\"headerlink\" title=\"初识C++\"></a>初识C++</h2>\n      \n        <h3 id=\"一些基本知识\"   >\n          <a href=\"#一些基本知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一些基本知识\" class=\"headerlink\" title=\"一些基本知识\"></a>一些基本知识</h3>\n      <ul>\n<li>集成开发环境<ul>\n<li>编辑器</li>\n<li>编译器</li>\n<li>连接器</li>\n<li>调试器</li>\n</ul>\n</li>\n<li>程序的运行从main函数开始而开始，结束而结束</li>\n<li>编译器是从上到下逐行编译</li>\n<li>在语法描述中，[]表示可选的</li>\n<li>C++语言集<strong>结构化编程</strong>、<strong>面向对象编程</strong>、<strong>泛型编程</strong>和<strong>函数式编程</strong>于一身，特别适合<strong>大型应用程序</strong>开发。</li>\n<li>C++的头文件是不带.h扩展名的</li>\n<li>C++的所有关键字都是小写的</li>\n<li>C++11，空指针nullstr</li>\n</ul>\n\n        <h3 id=\"new-delete内存管理\"   >\n          <a href=\"#new-delete内存管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#new-delete内存管理\" class=\"headerlink\" title=\"new/delete内存管理\"></a>new/delete内存管理</h3>\n      <ul>\n<li>栈：局部变量位于栈中，每个函数每一次运行，都会自动的分配/释放栈；形参(引用类型除外)也是局部变量</li>\n<li>堆：每个进程只有一个堆。只能手动分配和释放。只能通过指针指向堆，不能通过变量名使用堆。</li>\n<li>new/delete和malloc/free不能混用</li>\n<li><code>new[]</code>和<code>new</code>、<code>delete[]</code>和<code>delete</code>是不同的运算符</li>\n<li><code>new[]</code>只要用于创建动态数组</li>\n</ul>\n<p>例如</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[变量];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span>……&#125;;</span><br><span class=\"line\">Demo* pd = <span class=\"keyword\">new</span> Demo[变量];  <span class=\"comment\">//此时调用Demo类的无参构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;; <span class=\"comment\">//  静态数组的定义和初始化</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"参数默认值\"   >\n          <a href=\"#参数默认值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3>\n      <ul>\n<li>只能按照<strong>从右往左</strong>的顺序给出默认值。</li>\n<li>如果既有声明、又有实现，则只需要声明中给出默认值。</li>\n<li>特别地，成员函数的类外实现不应该有参数默认值。</li>\n</ul>\n\n        <h3 id=\"重载\"   >\n          <a href=\"#重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h3>\n      <ul>\n<li>所谓重载函数就是指在<strong>同一作用域内</strong>、<strong>函数名相同</strong>但<strong>参数列表不同</strong>的函数。</li>\n<li>目的：使得<strong>代码简洁</strong>。</li>\n<li>参数列表不同的含义<ul>\n<li>类型不同</li>\n<li>个数不同</li>\n<li>类型个数都不同</li>\n<li>不包括变量名不同</li>\n</ul>\n</li>\n<li>不以函数类型作为重载的依据</li>\n<li>当使用具有默认参数的函数重载时，需注意防止调用的<strong>二义性</strong>。</li>\n</ul>\n\n        <h3 id=\"内联函数\"   >\n          <a href=\"#内联函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h3>\n      <p>之前是为了提高效率，后来被编译器替代了，这里老师没讲，就说知道关键字就行了。</p>\n<ul>\n<li>inline</li>\n</ul>\n\n        <h3 id=\"引用\"   >\n          <a href=\"#引用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3>\n      <ul>\n<li>概念：别名。</li>\n<li>本质：指针</li>\n<li>用途：函数参数、函数返回值（可以让函数作为左值）、成员变量、父类引用指向子类对象。</li>\n<li>一个函数内部不会给变量定义相同类型的引用。</li>\n</ul>\n\n        <h2 id=\"类与对象（封装）\"   >\n          <a href=\"#类与对象（封装）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#类与对象（封装）\" class=\"headerlink\" title=\"类与对象（封装）\"></a>类与对象（封装）</h2>\n      \n        <h3 id=\"面向对象的三大特征-1\"   >\n          <a href=\"#面向对象的三大特征-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#面向对象的三大特征-1\" class=\"headerlink\" title=\"面向对象的三大特征\"></a>面向对象的三大特征</h3>\n      <ul>\n<li>封装，隐藏内部实现</li>\n<li>继承，复用现有代码</li>\n<li>多态，改写对象行为</li>\n</ul>\n\n        <h3 id=\"成员\"   >\n          <a href=\"#成员\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h3>\n      <ul>\n<li>成员可以是自身类型的指针、自身类型的引用、其他类型的对象（不能循环定义），但不能是自身类型的对象（造成错误的递归）。</li>\n<li>三类成员函数<ul>\n<li>构造/析构函数</li>\n<li>Get/Set函数</li>\n<li>其他功性能函数</li>\n</ul>\n</li>\n<li>针对某一个成员变量，往往有一对Set/Get函数。</li>\n<li><figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> Set <span class=\"title\">XXX</span><span class=\"params\">(类型 形参)</span></span>&#123;</span><br><span class=\"line\">      参数有效性检查；</span><br><span class=\"line\">      XXX = 形参;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    类型 XXX;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure></li>\n<li>成员访问运算符<ul>\n<li><code>对象.成员变量</code></li>\n<li><code>对象.成员函数(参数);</code></li>\n<li><code>指针-&gt;成员变量</code></li>\n<li><code>指针-&gt;成员函数(参数);  //前提是指针指向对象</code></li>\n<li></li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"访问权限\"   >\n          <a href=\"#访问权限\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h3>\n      <ul>\n<li>private<ul>\n<li>默认访问权限</li>\n<li>个人财产。类内访问，子类、类外均不能访问。</li>\n<li>如果没有派生类，则成员变量一般设置为private，然后设置公有的set/get函数。</li>\n</ul>\n</li>\n<li>protected<ul>\n<li>家族财产。类内访问，子类可以访问，类外不能访问。</li>\n<li>一般基类的成员变量设为protected，方便派生类访问</li>\n</ul>\n</li>\n<li>public<ul>\n<li>公共财产。类内、派生类、类外均可访问</li>\n</ul>\n</li>\n<li>C++中的struct<ul>\n<li>其默认访问权限是public。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"构造函数与析构函数\"   >\n          <a href=\"#构造函数与析构函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#构造函数与析构函数\" class=\"headerlink\" title=\"构造函数与析构函数\"></a>构造函数与析构函数</h3>\n      <ul>\n<li><p>每创建一个对象，就必然要调用一次构造函数。</p>\n</li>\n<li><p>注意：<code>Demo* pd[4];//指针数组只是定义了四个指针，还没有创建对象</code></p>\n</li>\n<li><p>作用</p>\n<ul>\n<li>构造函数用来创建和初始化对象，析构函数用于释放对象</li>\n</ul>\n</li>\n<li><p>四个特点</p>\n</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th></th>\n<th>构造函数</th>\n<th>析构函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>与类同名</td>\n<td>与类同名，前面加~</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不能有类型，void、return都不要</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>可以带参数，能够重载</td>\n<td>没有参数，不能重载</td>\n</tr>\n<tr>\n<td>4</td>\n<td>一般为公有函数</td>\n<td>基类一般采用虚析构函数</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"无参构造函数\"   >\n          <a href=\"#无参构造函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#无参构造函数\" class=\"headerlink\" title=\"无参构造函数\"></a>无参构造函数</h3>\n      <ul>\n<li>默认构造函数，是无参构造函数</li>\n<li>这四行代码都调用无参构造函数</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">A x;</span><br><span class=\"line\">A* pa = <span class=\"keyword\">new</span> A;</span><br><span class=\"line\">A* pArr = <span class=\"keyword\">new</span> A[size];</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>通过<code>new[]</code>创建对象的动态数组时，只能调用该类的无参构造函数。</p>\n</li>\n<li><p>通过参数的默认值，也能达到无参构造函数的作用。</p>\n</li>\n<li><p>默认函数</p>\n<ul>\n<li>一个空类class Demo{};</li>\n<li>如果程序员没有提供构造函数，则编译器会自动提供默认构造函数。</li>\n<li>类似的还有：默认析构函数、默认构造函数、默认赋值运算符</li>\n<li>默认拷贝构造函数、默认赋值运算符按照“<strong>按位复制</strong>”，如果类中又封装了指针类型的成员变量，则会造成<strong>指针悬挂</strong>。也就是新的对象的指针变量和上一个对象的指针变量指向的可能是同一段内存，这样其中一个指针释放了内存，另一个对象也就用不了了。是一种浅拷贝</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"常成员函数，不修改对象的数据成员\"   >\n          <a href=\"#常成员函数，不修改对象的数据成员\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常成员函数，不修改对象的数据成员\" class=\"headerlink\" title=\"常成员函数，不修改对象的数据成员\"></a>常成员函数，不修改对象的数据成员</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>; <span class=\"comment\">//常成员函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Demo::fun</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;……;&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>常对象只能调用常函数</li>\n</ul>\n\n        <h3 id=\"静态成员函数\"   >\n          <a href=\"#静态成员函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h3>\n      <ul>\n<li>关键字：static</li>\n<li>普通成员函数，编译器会为其加上默认的this指针，但是静态成员函数除外。参数列表中没有默认的this指针</li>\n<li>属于类，不属于对象。也就是说，该类的所有对象拥有同一个静态成员。静态成员类似于一个类范围内的全局变量。</li>\n<li>既可以通过对象调用，也可以通过类调用<code>类名::静态成员</code></li>\n<li>静态成员变量必须类外初始化</li>\n<li>典型应用：单例模式</li>\n</ul>\n\n        <h3 id=\"友元friend\"   >\n          <a href=\"#友元friend\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#友元friend\" class=\"headerlink\" title=\"友元friend\"></a>友元friend</h3>\n      <ul>\n<li>友元函数<ul>\n<li>声明全局函数为友元，则该函数可以访问<strong>所有</strong>成员变量。</li>\n<li>开后门，破坏了封装。</li>\n<li>友元函数不是成员函数，和访问权限没有关系。</li>\n</ul>\n</li>\n<li>友元类<ul>\n<li>没讲</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"运算符重载\"   >\n          <a href=\"#运算符重载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2>\n      <ul>\n<li>运算符的本质是函数重载<ul>\n<li>主要目的是代码简洁，而不是代码复用；</li>\n<li>但是不能说运算符就是函数(算数运算是铜鼓CPU的指令直接实现的)。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"两种重载形式\"   >\n          <a href=\"#两种重载形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#两种重载形式\" class=\"headerlink\" title=\"两种重载形式\"></a>两种重载形式</h3>\n      <ul>\n<li>成员函数</li>\n<li>全局函数，**往往(不是必须)**声明为友元。</li>\n</ul>\n\n        <h3 id=\"重载为成员函数\"   >\n          <a href=\"#重载为成员函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重载为成员函数\" class=\"headerlink\" title=\"重载为成员函数\"></a>重载为成员函数</h3>\n      <ul>\n<li>左操作数必须是自身类型</li>\n<li>=、)、[]、-&gt;，这四个符号只能重载为成员函数</li>\n</ul>\n\n        <h3 id=\"重载为全局函数\"   >\n          <a href=\"#重载为全局函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重载为全局函数\" class=\"headerlink\" title=\"重载为全局函数\"></a>重载为全局函数</h3>\n      <ul>\n<li>流输出运算符只能重载为全局函数</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> ostream&amp; &lt;&lt;(ostream&amp; out, <span class=\"keyword\">const</span> Demo&amp; d);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o,<span class=\"keyword\">const</span> Demo&amp; d)&#123;</span><br><span class=\"line\">  ……;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>三处引用的作用</p>\n<ul>\n<li>两处<code>ostream&amp;</code>是为了确保设备的<strong>唯一性</strong>和<strong>连续使用</strong>。</li>\n<li>右操作数采用常引用，是为了避免形参到实参拷贝，避免修改实参。</li>\n</ul>\n</li>\n<li><p>流入运算符只能重载为全局函数</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; in, 引用类型)<span class=\"comment\">//需要写数据，不能是常引用</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"继承与派生\"   >\n          <a href=\"#继承与派生\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#继承与派生\" class=\"headerlink\" title=\"继承与派生\"></a>继承与派生</h2>\n      <ul>\n<li>基类和派生类，父类和子类</li>\n<li>C++支持单继承（只有一个基类）和多继承（多个基类）</li>\n<li>UML类图中，由派生类指向基类（由下而上）</li>\n</ul>\n\n        <h3 id=\"继承方式\"   >\n          <a href=\"#继承方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3>\n      <ul>\n<li>针对基类的公有和保护成员，继承方式决定其最高访问权限</li>\n<li>针对基类的私有和不可访问成员(继承自基类的基类)，都是不可访问成员</li>\n<li>默认的继承方式是私有继承，是最常见的继承方式是公有继承。</li>\n</ul>\n\n        <h3 id=\"派生类对象\"   >\n          <a href=\"#派生类对象\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#派生类对象\" class=\"headerlink\" title=\"派生类对象\"></a>派生类对象</h3>\n      <ul>\n<li>派生类对象拥有基类的所有成员(但是不一定能够使用)</li>\n<li>构造函数的调用顺序：基类-&gt;成员对象-&gt;派生类</li>\n<li>析构函数的调用顺序：派生类-&gt;成员对象-&gt;基类</li>\n</ul>\n\n        <h2 id=\"多态与虚函数\"   >\n          <a href=\"#多态与虚函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多态与虚函数\" class=\"headerlink\" title=\"多态与虚函数\"></a>多态与虚函数</h2>\n      \n        <h3 id=\"虚函数\"   >\n          <a href=\"#虚函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h3>\n      <ul>\n<li>关键字：virtual</li>\n<li>实现虚函数的核心数据结构是<strong>虚函数表</strong>。</li>\n</ul>\n\n        <h4 id=\"成员函数，区分三个概念：重载、隐藏、覆盖\"   >\n          <a href=\"#成员函数，区分三个概念：重载、隐藏、覆盖\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#成员函数，区分三个概念：重载、隐藏、覆盖\" class=\"headerlink\" title=\"成员函数，区分三个概念：重载、隐藏、覆盖\"></a>成员函数，区分三个概念：重载、隐藏、覆盖</h4>\n      <ul>\n<li>同一类中：重载</li>\n<li>分别在基类、派生类中<ul>\n<li>同时满足<ol>\n<li>原型相同</li>\n<li>virtual，即为覆盖</li>\n</ol>\n</li>\n<li>否则（两个条件有一个不满足），即为隐藏</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"同名函数的调用原则\"   >\n          <a href=\"#同名函数的调用原则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#同名函数的调用原则\" class=\"headerlink\" title=\"同名函数的调用原则\"></a>同名函数的调用原则</h4>\n      <ul>\n<li>在<strong>隐藏</strong>的情况下，通过指针调用函数，取决于左侧变量的类型</li>\n<li>在<strong>覆盖</strong>的情况下，通过指针调用函数，取决于对象的类型</li>\n</ul>\n\n        <h3 id=\"多态的概念\"   >\n          <a href=\"#多态的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多态的概念\" class=\"headerlink\" title=\"多态的概念\"></a>多态的概念</h3>\n      <p>多态是一种：调用<strong>同名函数</strong>却因<strong>上下文不同</strong>会有<strong>不同实现</strong>的一种机制。</p>\n<p>多态是指：<strong>不同的对象</strong>调用<strong>同名函数</strong>，会有<strong>不同的实现</strong>。</p>\n<ul>\n<li><strong>静态多态</strong>，通过<strong>重载</strong>在<strong>编译阶段</strong>完成</li>\n<li><strong>动态多态</strong>，通过<strong>继承和虚函数</strong>在<strong>运行阶段</strong>完成。</li>\n</ul>\n\n        <h3 id=\"纯虚函数与抽象类\"   >\n          <a href=\"#纯虚函数与抽象类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#纯虚函数与抽象类\" class=\"headerlink\" title=\"纯虚函数与抽象类\"></a>纯虚函数与抽象类</h3>\n      <ul>\n<li>虚函数没有函数体(=0)称之为纯虚函数</li>\n<li>拥有纯虚函数的类，称之为抽象类</li>\n<li>抽象类不能实例化对象</li>\n</ul>\n\n        <h3 id=\"RTTI，运行时类型识别\"   >\n          <a href=\"#RTTI，运行时类型识别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RTTI，运行时类型识别\" class=\"headerlink\" title=\"RTTI，运行时类型识别\"></a>RTTI，运行时类型识别</h3>\n      <ul>\n<li>typeid</li>\n<li>dynamic_cast&lt;目标类型&gt;(表达式);</li>\n</ul>\n\n        <h2 id=\"异常处理\"   >\n          <a href=\"#异常处理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2>\n      <ul>\n<li>try…catch…throw</li>\n<li>throw用于(通常在子函数中)<strong>抛出</strong>异常</li>\n<li>try用于<strong>检测</strong>异常，把可能出现异常的语句放在try块中(只能有一个)</li>\n<li>多个catch块依次对异常按照<strong>类型</strong>进行匹配，用于<strong>捕获</strong>并<strong>处理</strong>异常。</li>\n</ul>\n\n        <h2 id=\"IO流\"   >\n          <a href=\"#IO流\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2>\n      \n        <h3 id=\"四个预定义流对象\"   >\n          <a href=\"#四个预定义流对象\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#四个预定义流对象\" class=\"headerlink\" title=\"四个预定义流对象\"></a>四个预定义流对象</h3>\n      <ul>\n<li>包括cin、cout、cerr和clog</li>\n<li><code>&gt;&gt;</code>提取运算符、<code>&lt;&lt;</code>插入运算符</li>\n</ul>\n\n        <h3 id=\"文件读写\"   >\n          <a href=\"#文件读写\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h3>\n      <ul>\n<li>文本文件，既可以通过&gt;&gt;、&lt;&lt;进行读写，也可以通过成员函数进行读写。</li>\n<li>二进制文件，只能通过成员函数进行读写。</li>\n</ul>\n<p>典型应用，把文本文件中的数据读入到某一个STL的容器中。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; in, 容器引用)&#123;...;<span class=\"keyword\">return</span> in&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">main</span>()&#123;</span><br><span class=\"line\">  ifstream ifs;</span><br><span class=\"line\">  ifs.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;文件名&quot;</span>,ios::in);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!ifs)<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!ifs.<span class=\"built_in\">eof</span>()) ifs&gt;&gt;容器</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"模板编程\"   >\n          <a href=\"#模板编程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#模板编程\" class=\"headerlink\" title=\"模板编程\"></a>模板编程</h2>\n      <ul>\n<li>模板编程也称为泛型编程。</li>\n<li>模板编程的主要目的是代码复用</li>\n</ul>\n\n        <h3 id=\"函数模板实例化为函数\"   >\n          <a href=\"#函数模板实例化为函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#函数模板实例化为函数\" class=\"headerlink\" title=\"函数模板实例化为函数\"></a>函数模板实例化为函数</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">temple&lt;<span class=\"keyword\">typename</span>&gt;T</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"类模板实例化为类\"   >\n          <a href=\"#类模板实例化为类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#类模板实例化为类\" class=\"headerlink\" title=\"类模板实例化为类\"></a>类模板实例化为类</h3>\n      <p>必须显式实例化</p>\n\n        <h2 id=\"STL\"   >\n          <a href=\"#STL\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h2>\n      \n        <h3 id=\"基本概念\"   >\n          <a href=\"#基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3>\n      <ul>\n<li>Standard Template Library，标准模板库</li>\n<li>三大核心组件：容器、迭代器、算法</li>\n<li>六大组件，再加上：适配器、仿函数（函数对象）、分配器</li>\n<li>内部实现</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">模板</th>\n<th align=\"center\">结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">vector</td>\n<td align=\"center\">动态数组</td>\n</tr>\n<tr>\n<td align=\"center\">list</td>\n<td align=\"center\">双向链表</td>\n</tr>\n<tr>\n<td align=\"center\">map</td>\n<td align=\"center\">红黑树</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"vector\"   >\n          <a href=\"#vector\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3>\n      <ul>\n<li>遍历vector的方法：迭代器、下标、基于范围的for循环、for each函数</li>\n<li>连续的动态数组，可以在尾部快速插入和删除</li>\n</ul>\n\n        <h3 id=\"list-1\"   >\n          <a href=\"#list-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#list-1\" class=\"headerlink\" title=\"list\"></a>list</h3>\n      <ul>\n<li>遍历list的方法：迭代器、基于范围的for循环、for each函数</li>\n<li>双向链表，可以在任意位置插入和删除</li>\n</ul>\n\n        <h3 id=\"迭代器-1\"   >\n          <a href=\"#迭代器-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#迭代器-1\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3>\n      <ul>\n<li>定义迭代器时，必须要指定容器类型和元素类型</li>\n<li>在调用一些特殊的迭代器时，需要包含<iterator>。比如说，插入迭代器、IO流迭代器</li>\n</ul>\n\n        <h3 id=\"算法-1\"   >\n          <a href=\"#算法-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h3>\n      <ul>\n<li>需要包含<algorithm></li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  list&lt;<span class=\"keyword\">int</span>&gt;li;  <span class=\"comment\">//整数链表</span></span><br><span class=\"line\">  <span class=\"comment\">//不使用循环。而是通过STL::algorithm实现插入10个随机数，遍历输出</span></span><br><span class=\"line\">  <span class=\"built_in\">generate_n</span>(<span class=\"built_in\">back_inserter</span>(li),</span><br><span class=\"line\">  <span class=\"number\">10</span>,</span><br><span class=\"line\">  []()&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">rand</span>()%<span class=\"number\">100</span>;&#125;<span class=\"comment\">//0~99的随机数</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"built_in\">copy</span>(li.<span class=\"built_in\">begin</span>(),li.<span class=\"built_in\">end</span>(),ostream_iterator&lt;<span class=\"keyword\">int</span>&gt;(cout,<span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"设计模式\"   >\n          <a href=\"#设计模式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2>\n      \n        <h3 id=\"面对对象程序设计的思想\"   >\n          <a href=\"#面对对象程序设计的思想\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#面对对象程序设计的思想\" class=\"headerlink\" title=\"面对对象程序设计的思想\"></a>面对对象程序设计的思想</h3>\n      <p>应用程序是对现实“花花世界”的仿真，主要特征是：种类很多、数量很多。</p>\n<ul>\n<li><p>在软件开发过程中唯一不变的是<strong>变化</strong></p>\n</li>\n<li><p>在基类指针指向派生类对象时，基类指针代表<strong>抽象</strong>和<strong>稳定</strong>的，派生类对象代表<strong>具体</strong>和<strong>变化</strong>的。只有针对稳定的抽象进行编程，才能达到“以不变应万变”的效果。</p>\n</li>\n<li><p>三大设计原则：</p>\n<ol>\n<li>封装变化点</li>\n<li>针对抽象进行编程</li>\n<li>优先使用组合</li>\n</ol>\n<ul>\n<li>继承被称为“is-a”关系，组合被称为“has-a”关系</li>\n<li>继承和组合均能实现代码复用，优先使用组合。</li>\n<li>针对抽象（稳定）的接口进行编程，才能做到以不变应万变。</li>\n</ul>\n</li>\n<li><p>开闭原则：对扩展开放，对修改关闭。（五大设计原则之一）</p>\n</li>\n</ul>\n\n        <h3 id=\"基本概念-1\"   >\n          <a href=\"#基本概念-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3>\n      <ul>\n<li>最早提出这个概念的人是，建筑设计领域的亚历山大·克里斯托弗</li>\n<li>三种设计模式：创造型模式（如：单例模式）、行为型模式（如：策略模式）、结构型模式。</li>\n</ul>\n","categories":["编程语言","C++","课堂笔记"],"tags":["C++","课堂笔记"]},{"title":"数据库原理与应用随堂笔记","url":"/notebooks-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","content":"\n        <h1 id=\"第1课-介绍\"   >\n          <a href=\"#第1课-介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第1课-介绍\" class=\"headerlink\" title=\"第1课 介绍\"></a>第1课 介绍</h1>\n      \n        <h2 id=\"1-1-数据库结构\"   >\n          <a href=\"#1-1-数据库结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-数据库结构\" class=\"headerlink\" title=\"1.1 数据库结构\"></a>1.1 数据库结构</h2>\n      <p>DBMS-&gt;DB-&gt;Table-&gt;Column-&gt;Data   </p>\n<p>数据库管理系统-&gt;数据库-&gt;表-&gt;列-&gt;字段    </p>\n\n        <h2 id=\"1-2-课程设计\"   >\n          <a href=\"#1-2-课程设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-2-课程设计\" class=\"headerlink\" title=\"1.2 课程设计\"></a>1.2 课程设计</h2>\n      <ol>\n<li>认识数据库及概述</li>\n<li>数据库的创建与管理</li>\n<li>创建与管理数据表<ul>\n<li>掌握表结构的创建、修改和查询，掌握添加、修改和删除表中的数据和完整性约束的实现。</li>\n</ul>\n</li>\n<li>数据查询<ul>\n<li>掌握基本查询、连接查询、数据汇总的使用，熟悉嵌套查询的使用。</li>\n</ul>\n</li>\n<li>视图的创建与使用</li>\n<li>MySQL编程</li>\n<li>数据库规划与设计<ul>\n<li>掌握数据库设计的步骤，并了解范式对数据库设计进行判定并规范</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"1-3-SQL-server体验\"   >\n          <a href=\"#1-3-SQL-server体验\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-SQL-server体验\" class=\"headerlink\" title=\"1.3 SQL server体验\"></a>1.3 SQL server体验</h2>\n      \n        <h3 id=\"1-3-1-使用工具登录SQL-server\"   >\n          <a href=\"#1-3-1-使用工具登录SQL-server\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-1-使用工具登录SQL-server\" class=\"headerlink\" title=\"1.3.1 使用工具登录SQL server\"></a>1.3.1 使用工具登录SQL server</h3>\n      <p>服务器名就是电脑设备名</p>\n<ul>\n<li>Windows身份验证<ul>\n<li>直接连接就可以</li>\n</ul>\n</li>\n<li>SQL server身份验证<ul>\n<li>通常都是用户名是<code>sa</code>,密码是<code>123456</code>。     </li>\n</ul>\n</li>\n</ul>\n<p>忘记了密码可以通过Windows身份登录，双击<code>安全性下登录名下的sa</code>就可以修改密码</p>\n\n        <h3 id=\"1-3-2-使用脚本\"   >\n          <a href=\"#1-3-2-使用脚本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-2-使用脚本\" class=\"headerlink\" title=\"1.3.2 使用脚本\"></a>1.3.2 使用脚本</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/****** 对象:  Database [xkgl]   </span></span><br><span class=\"line\"><span class=\"comment\"> 脚本日期: 04/05/2012 14:43:32 ******/</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE xkgl     </span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"comment\">/*创建xkgl数据库*/</span></span><br><span class=\"line\">use xkgl        </span><br><span class=\"line\">GO </span><br><span class=\"line\"><span class=\"comment\">/*使用xkgl数据库*/</span></span><br><span class=\"line\">if <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dbo.sysobjects <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> object_id(N<span class=\"string\">&#x27;[dbo].[Department]&#x27;</span>) <span class=\"keyword\">and</span> OBJECTPROPERTY(id, N<span class=\"string\">&#x27;IsUserTable&#x27;</span>) <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> [dbo].[Department]</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Department 的结构</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Department(</span><br><span class=\"line\">DepartmentID <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">primary</span> key,</span><br><span class=\"line\"><span class=\"comment\">/*创立DepartmentID为主键，主键是唯一的*/</span></span><br><span class=\"line\">DepartmentName <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">unique</span>,</span><br><span class=\"line\">DepartmentHeader <span class=\"type\">varchar</span>(<span class=\"number\">8</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">TeacherNum <span class=\"type\">int</span> </span><br><span class=\"line\">)</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Department 的数据</span></span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Department([DepartmentID],[DepartmentName],[DepartmentHeader],[TeacherNum]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp01&#x27;</span>,<span class=\"string\">&#x27;计算机系&#x27;</span>,<span class=\"string\">&#x27;罗浩然&#x27;</span>,<span class=\"number\">120</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Department([DepartmentID],[DepartmentName],[DepartmentHeader],[TeacherNum]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp02&#x27;</span>,<span class=\"string\">&#x27;信管系&#x27;</span>,<span class=\"string\">&#x27;李伶俐&#x27;</span>,<span class=\"keyword\">null</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Department([DepartmentID],[DepartmentName],[DepartmentHeader],[TeacherNum]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp03&#x27;</span>,<span class=\"string\">&#x27;英语系&#x27;</span>,<span class=\"string\">&#x27;李宏伟&#x27;</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dbo.sysobjects <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> object_id(N<span class=\"string\">&#x27;[dbo].[Class]&#x27;</span>) <span class=\"keyword\">and</span> OBJECTPROPERTY(id, N<span class=\"string\">&#x27;IsUserTable&#x27;</span>) <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> [dbo].[Class]</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Class 的结构</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Class(</span><br><span class=\"line\">ClassID   <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">primary</span> key,</span><br><span class=\"line\">ClassName <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">Monitor  <span class=\"type\">char</span>(<span class=\"number\">8</span>),</span><br><span class=\"line\">StudentNum <span class=\"type\">int</span> <span class=\"keyword\">check</span>(StudentNum<span class=\"operator\">&gt;</span><span class=\"number\">0</span>),</span><br><span class=\"line\">DepartmentID <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">references</span> Department(DepartmentID)</span><br><span class=\"line\">)</span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"comment\">--表 Class 的数据</span></span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Class([ClassID],[ClassName],[Monitor],[StudentNum],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Cs010901&#x27;</span>,<span class=\"string\">&#x27;09软件技术1班&#x27;</span>,<span class=\"string\">&#x27;方凯&#x27;</span>,<span class=\"number\">34</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Class([ClassID],[ClassName],[Monitor],[StudentNum],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Cs010902&#x27;</span>,<span class=\"string\">&#x27;09软件测试1班&#x27;</span>,<span class=\"string\">&#x27;林静&#x27;</span>,<span class=\"number\">10</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Class([ClassID],[ClassName],[Monitor],[StudentNum],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Cs010903&#x27;</span>,<span class=\"string\">&#x27;09数据库班&#x27;</span>,<span class=\"string\">&#x27;黄勇&#x27;</span>,<span class=\"number\">28</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Class([ClassID],[ClassName],[Monitor],[StudentNum],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Cs011104&#x27;</span>,<span class=\"string\">&#x27;11网络工程&#x27;</span>,<span class=\"keyword\">null</span>,<span class=\"number\">23</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Class([ClassID],[ClassName],[Monitor],[StudentNum],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Cs021001&#x27;</span>,<span class=\"string\">&#x27;10电子商务1班&#x27;</span>,<span class=\"string\">&#x27;李米&#x27;</span>,<span class=\"number\">33</span>,<span class=\"string\">&#x27;Dp02&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Class([ClassID],[ClassName],[Monitor],[StudentNum],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Cs021002&#x27;</span>,<span class=\"string\">&#x27;10电子商务2班&#x27;</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"string\">&#x27;Dp02&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dbo.sysobjects <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> object_id(N<span class=\"string\">&#x27;[dbo].[Student]&#x27;</span>) <span class=\"keyword\">and</span> OBJECTPROPERTY(id, N<span class=\"string\">&#x27;IsUserTable&#x27;</span>) <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> [dbo].[Student]</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Student 的结构</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Student(</span><br><span class=\"line\">StudentID   <span class=\"type\">char</span>(<span class=\"number\">12</span>) <span class=\"keyword\">primary</span> key,</span><br><span class=\"line\">StudentName <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">Sex  <span class=\"type\">char</span>(<span class=\"number\">2</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">check</span>(sex <span class=\"keyword\">in</span>(<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>)),</span><br><span class=\"line\">Birth  datetime <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">HomeAddr <span class=\"type\">varchar</span>(<span class=\"number\">80</span>),</span><br><span class=\"line\">EntranceTime datetime <span class=\"keyword\">default</span> getdate(),</span><br><span class=\"line\">ClassID <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">references</span> Class(ClassID)</span><br><span class=\"line\">)</span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"comment\">--表 Student 的数据</span></span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010001&#x27;</span>,<span class=\"string\">&#x27;张宏    &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1998-4-4&#x27;</span>,<span class=\"string\">&#x27;广州市天河区常保阁东 80 号&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010002&#x27;</span>,<span class=\"string\">&#x27;姜明凡  &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1997-12-7&#x27;</span>,<span class=\"string\">&#x27;汕头市天源路34号&#x27;</span>,<span class=\"string\">&#x27;2016-9-19&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010003&#x27;</span>,<span class=\"string\">&#x27;张丽    &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1997-9-30&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;2016-9-19&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010004&#x27;</span>,<span class=\"string\">&#x27;赵新宇  &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1998-5-9&#x27;</span>,<span class=\"string\">&#x27;大连市沙河区承德西路 80 号&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010005&#x27;</span>,<span class=\"string\">&#x27;李宇凯  &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1996-11-27&#x27;</span>,<span class=\"string\">&#x27;大连市沙河区花园东街 90 号&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010006&#x27;</span>,<span class=\"string\">&#x27;黄丽莉  &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1997-8-15&#x27;</span>,<span class=\"string\">&#x27;佛山市南海区南海大道120号&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010007&#x27;</span>,<span class=\"string\">&#x27;胡雨樱  &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1997-6-23&#x27;</span>,<span class=\"string\">&#x27;佛山市南海区狮山20号&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010008&#x27;</span>,<span class=\"string\">&#x27;曹海华  &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1999-7-12&#x27;</span>,<span class=\"string\">&#x27;上海市黄石路 50 号&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109010009&#x27;</span>,<span class=\"string\">&#x27;许田    &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1998-2-21&#x27;</span>,<span class=\"string\">&#x27;深圳市福田区福华路29号京海大厦18c&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109020001&#x27;</span>,<span class=\"string\">&#x27;李平    &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1998-4-30&#x27;</span>,<span class=\"string\">&#x27;成都市都江堰红石路321号&#x27;</span>,<span class=\"string\">&#x27;2016-9-10&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109020002&#x27;</span>,<span class=\"string\">&#x27;王虎    &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1997-10-19&#x27;</span>,<span class=\"string\">&#x27;宜宾市宜宾大道231号&#x27;</span>,<span class=\"string\">&#x27;2016-9-19&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109020003&#x27;</span>,<span class=\"string\">&#x27;黄微    &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1997-7-18&#x27;</span>,<span class=\"string\">&#x27;鞍山市中山大道786号&#x27;</span>,<span class=\"string\">&#x27;2016-9-19&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0109020004&#x27;</span>,<span class=\"string\">&#x27;张凯芝  &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1996-5-19&#x27;</span>,<span class=\"string\">&#x27;广州市东山区34号&#x27;</span>,<span class=\"string\">&#x27;2016-9-19&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0111040001&#x27;</span>,<span class=\"string\">&#x27;立号    &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;2000-11-4&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;2017-9-13&#x27;</span>,<span class=\"string\">&#x27;Cs011104&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0111040002&#x27;</span>,<span class=\"string\">&#x27;姚钱    &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;2000-4-2&#x27;</span>,<span class=\"string\">&#x27;成都市武侯区中山大道12号&#x27;</span>,<span class=\"string\">&#x27;2011-9-13&#x27;</span>,<span class=\"string\">&#x27;Cs011104&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0111040003&#x27;</span>,<span class=\"string\">&#x27;方雨丽  &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;2000-10-4&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;2017-9-13&#x27;</span>,<span class=\"string\">&#x27;Cs011104&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0210010001&#x27;</span>,<span class=\"string\">&#x27;李平    &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1999-12-3&#x27;</span>,<span class=\"string\">&#x27;广州市萝岗区32号&#x27;</span>,<span class=\"string\">&#x27;2017-9-12&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0210010002&#x27;</span>,<span class=\"string\">&#x27;周雅云  &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1998-4-23&#x27;</span>,<span class=\"string\">&#x27;大连市沙河区花园东街 91 号&#x27;</span>,<span class=\"string\">&#x27;2017-9-12&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0210010003&#x27;</span>,<span class=\"string\">&#x27;王建伟  &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1997-10-10&#x27;</span>,<span class=\"string\">&#x27;成都市中山路321号&#x27;</span>,<span class=\"string\">&#x27;2017-9-12&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0210010004&#x27;</span>,<span class=\"string\">&#x27;梁冬云  &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1998-5-4&#x27;</span>,<span class=\"string\">&#x27;成都市中山路322号&#x27;</span>,<span class=\"string\">&#x27;2010-9-12&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0210010005&#x27;</span>,<span class=\"string\">&#x27;黄树军  &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;2000-4-8&#x27;</span>,<span class=\"string\">&#x27;佛山市顺德区五一大道120号&#x27;</span>,<span class=\"string\">&#x27;2017-9-12&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student([StudentID],[StudentName],[Sex],[Birth],[HomeAddr],[EntranceTime],[ClassID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;St0210010006&#x27;</span>,<span class=\"string\">&#x27;雷立    &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1999-9-2&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;2017-9-12&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dbo.sysobjects <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> object_id(N<span class=\"string\">&#x27;[dbo].[Course]&#x27;</span>) <span class=\"keyword\">and</span> OBJECTPROPERTY(id, N<span class=\"string\">&#x27;IsUserTable&#x27;</span>) <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> [dbo].[Course]</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Course 的结构</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Course(</span><br><span class=\"line\">CourseID   <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">primary</span> key,</span><br><span class=\"line\">CourseName <span class=\"type\">varchar</span>(<span class=\"number\">60</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">BookNmae  <span class=\"type\">varchar</span>(<span class=\"number\">80</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\"><span class=\"keyword\">period</span> <span class=\"type\">int</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">credit <span class=\"type\">int</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span></span><br><span class=\"line\">)</span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"comment\">--表 Course 的数据</span></span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Course([CourseID],[CourseName],[BookNmae],[<span class=\"keyword\">period</span>],[credit]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;JAVA程序设计&#x27;</span>,<span class=\"string\">&#x27;Java高级程序设计&#x27;</span>,<span class=\"number\">60</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Course([CourseID],[CourseName],[BookNmae],[<span class=\"keyword\">period</span>],[credit]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010002&#x27;</span>,<span class=\"string\">&#x27;计算机网络&#x27;</span>,<span class=\"string\">&#x27;计算机网络&#x27;</span>,<span class=\"number\">90</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Course([CourseID],[CourseName],[BookNmae],[<span class=\"keyword\">period</span>],[credit]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;数据库原理与应用&#x27;</span>,<span class=\"string\">&#x27;数据库技术与应用-SQL Server 2005&#x27;</span>,<span class=\"number\">60</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Course([CourseID],[CourseName],[BookNmae],[<span class=\"keyword\">period</span>],[credit]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;计算机应用基础&#x27;</span>,<span class=\"string\">&#x27;计算机应用基础&#x27;</span>,<span class=\"number\">30</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Course([CourseID],[CourseName],[BookNmae],[<span class=\"keyword\">period</span>],[credit]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp020001&#x27;</span>,<span class=\"string\">&#x27;国际贸易实务&#x27;</span>,<span class=\"string\">&#x27;国际贸易实务&#x27;</span>,<span class=\"number\">60</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Course([CourseID],[CourseName],[BookNmae],[<span class=\"keyword\">period</span>],[credit]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp020002&#x27;</span>,<span class=\"string\">&#x27;电子商务物流管理&#x27;</span>,<span class=\"string\">&#x27;物流学概论&#x27;</span>,<span class=\"number\">60</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Course([CourseID],[CourseName],[BookNmae],[<span class=\"keyword\">period</span>],[credit]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;大学英语(一)&#x27;</span>,<span class=\"string\">&#x27;大学英语综合一&#x27;</span>,<span class=\"number\">90</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">if <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dbo.sysobjects <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> object_id(N<span class=\"string\">&#x27;[dbo].[Grade]&#x27;</span>) <span class=\"keyword\">and</span> OBJECTPROPERTY(id, N<span class=\"string\">&#x27;IsUserTable&#x27;</span>) <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> [dbo].[Grade]</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Grade 的结构</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Grade(</span><br><span class=\"line\">CourseID   <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">references</span> Course(CourseID),</span><br><span class=\"line\">StudentID <span class=\"type\">char</span>(<span class=\"number\">12</span>) <span class=\"keyword\">references</span> Student(StudentID),</span><br><span class=\"line\">Semester  <span class=\"type\">int</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">SchoolYear <span class=\"type\">int</span> ,</span><br><span class=\"line\">Grade <span class=\"type\">numeric</span>(<span class=\"number\">5</span>,<span class=\"number\">1</span>) <span class=\"keyword\">check</span>(grade<span class=\"operator\">&gt;=</span><span class=\"number\">0</span>),</span><br><span class=\"line\"><span class=\"keyword\">primary</span> key(CourseID,StudentID)</span><br><span class=\"line\">)</span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"comment\">--表 Grade 的数据</span></span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;87&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;68&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;92&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;91&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010005&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;72&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010006&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;87&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010007&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;97&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109010009&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;69&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109020001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;56&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109020002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;89&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109020003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;98&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0109020004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;76&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0210010001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;88&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0210010002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;72&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;St0210010003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;71&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010002&#x27;</span>,<span class=\"string\">&#x27;St0111040001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;54&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010002&#x27;</span>,<span class=\"string\">&#x27;St0111040002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;92&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010002&#x27;</span>,<span class=\"string\">&#x27;St0111040003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;95&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;50&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;67&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;61&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;91&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010005&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;55&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010006&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;68&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010007&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;69&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109010009&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;55&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109020001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;93&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109020002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;70&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109020003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;73&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;St0109020004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;81&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109010001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;80&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109010002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;63&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109010004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;57&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109010005&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;94&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109010006&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;89&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109010007&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;83&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109010009&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;82&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109020001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;72&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109020002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;57&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109020003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;53&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0109020004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;51&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0111040001&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2012</span>,<span class=\"string\">&#x27;55&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0111040002&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2012</span>,<span class=\"string\">&#x27;63&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0111040003&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2012</span>,<span class=\"string\">&#x27;61&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0210010001&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;99&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0210010002&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;71&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;St0210010003&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;56&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp020001&#x27;</span>,<span class=\"string\">&#x27;St0210010002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;64&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp020001&#x27;</span>,<span class=\"string\">&#x27;St0210010003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;82&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp020001&#x27;</span>,<span class=\"string\">&#x27;St0210010004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;95&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp020001&#x27;</span>,<span class=\"string\">&#x27;St0210010005&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;86&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;75&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;53&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;64&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;84&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010005&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;72&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010006&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;93&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010007&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;98&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109010009&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;64&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109020001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;77&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109020002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;61&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109020003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;63&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0109020004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>,<span class=\"string\">&#x27;51&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0111040001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;96&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0111040002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;63&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0111040003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>,<span class=\"string\">&#x27;71&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0210010001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;77&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0210010002&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;67&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0210010003&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;91&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0210010004&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;68&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Grade([CourseID],[StudentID],[Semester],[SchoolYear],[Grade]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;St0210010005&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>,<span class=\"string\">&#x27;73&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dbo.sysobjects <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> object_id(N<span class=\"string\">&#x27;[dbo].[Teacher]&#x27;</span>) <span class=\"keyword\">and</span> OBJECTPROPERTY(id, N<span class=\"string\">&#x27;IsUserTable&#x27;</span>) <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> [dbo].[Teacher]</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Teacher 的结构</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Teacher(</span><br><span class=\"line\">TeacherID   <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">primary</span> key,</span><br><span class=\"line\">Teachername <span class=\"type\">char</span>(<span class=\"number\">12</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">Sex  <span class=\"type\">char</span>(<span class=\"number\">2</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">check</span>(sex <span class=\"keyword\">in</span>(<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>)),</span><br><span class=\"line\">Brith datetime ,</span><br><span class=\"line\">Profession <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">check</span>(profession <span class=\"keyword\">in</span>(<span class=\"string\">&#x27;教授&#x27;</span>,<span class=\"string\">&#x27;副教授&#x27;</span>,<span class=\"string\">&#x27;讲师&#x27;</span>,<span class=\"string\">&#x27;助教&#x27;</span>)),</span><br><span class=\"line\">Telephone <span class=\"type\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">HomeAddr <span class=\"type\">varchar</span>(<span class=\"number\">50</span>),</span><br><span class=\"line\">DepartmentID <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">references</span> Department(DepartmentID)</span><br><span class=\"line\">)</span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"comment\">--表 Teacher 的数据</span></span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01001&#x27;</span>,<span class=\"string\">&#x27;王一平      &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1968-4-5&#x27;</span>,<span class=\"string\">&#x27;副教授  &#x27;</span>,<span class=\"string\">&#x27;86684567&#x27;</span>,<span class=\"string\">&#x27;东软宿舍29栋309&#x27;</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01002&#x27;</span>,<span class=\"string\">&#x27;潘清菊      &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1976-9-3&#x27;</span>,<span class=\"string\">&#x27;讲师    &#x27;</span>,<span class=\"string\">&#x27;86685633&#x27;</span>,<span class=\"string\">&#x27;东软宿舍21栋109&#x27;</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01003&#x27;</span>,<span class=\"string\">&#x27;陈鹤        &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1959-12-5&#x27;</span>,<span class=\"string\">&#x27;教授    &#x27;</span>,<span class=\"string\">&#x27;86687656&#x27;</span>,<span class=\"string\">&#x27;东软宿舍12栋306&#x27;</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01004&#x27;</span>,<span class=\"string\">&#x27;周江瑞      &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1984-6-5&#x27;</span>,<span class=\"string\">&#x27;助教    &#x27;</span>,<span class=\"string\">&#x27;86684332&#x27;</span>,<span class=\"string\">&#x27;东软宿舍3栋306&#x27;</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01005&#x27;</span>,<span class=\"string\">&#x27;朱于龙      &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1978-5-6&#x27;</span>,<span class=\"string\">&#x27;讲师    &#x27;</span>,<span class=\"string\">&#x27;86687653&#x27;</span>,<span class=\"string\">&#x27;东软宿舍1栋206&#x27;</span>,<span class=\"string\">&#x27;Dp01&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep02001&#x27;</span>,<span class=\"string\">&#x27;雷燕        &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1973-3-2&#x27;</span>,<span class=\"string\">&#x27;副教授  &#x27;</span>,<span class=\"string\">&#x27;86687651&#x27;</span>,<span class=\"string\">&#x27;东软宿舍1栋106&#x27;</span>,<span class=\"string\">&#x27;Dp02&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep02002&#x27;</span>,<span class=\"string\">&#x27;郭菊        &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1985-6-7&#x27;</span>,<span class=\"string\">&#x27;助教    &#x27;</span>,<span class=\"string\">&#x27;86680975&#x27;</span>,<span class=\"string\">&#x27;东软宿舍1栋406&#x27;</span>,<span class=\"string\">&#x27;Dp02&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep02003&#x27;</span>,<span class=\"string\">&#x27;刘悠然      &#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;1969-12-9&#x27;</span>,<span class=\"string\">&#x27;教授    &#x27;</span>,<span class=\"string\">&#x27;86685645&#x27;</span>,<span class=\"string\">&#x27;东软宿舍1栋306&#x27;</span>,<span class=\"string\">&#x27;Dp02&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep03001&#x27;</span>,<span class=\"string\">&#x27;胡丽        &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1968-6-7&#x27;</span>,<span class=\"string\">&#x27;副教授  &#x27;</span>,<span class=\"string\">&#x27;86687904&#x27;</span>,<span class=\"string\">&#x27;东软宿舍21栋108&#x27;</span>,<span class=\"string\">&#x27;Dp03&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep03002&#x27;</span>,<span class=\"string\">&#x27;刘芳        &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1976-8-6&#x27;</span>,<span class=\"string\">&#x27;讲师    &#x27;</span>,<span class=\"string\">&#x27;86684312&#x27;</span>,<span class=\"string\">&#x27;东软宿舍21栋208&#x27;</span>,<span class=\"string\">&#x27;Dp03&#x27;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Teacher([TeacherID],[Teachername],[Sex],[Brith],[Profession],[Telephone],[HomeAddr],[DepartmentID]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep03003&#x27;</span>,<span class=\"string\">&#x27;雷珍锦      &#x27;</span>,<span class=\"string\">&#x27;女&#x27;</span>,<span class=\"string\">&#x27;1978-5-6&#x27;</span>,<span class=\"string\">&#x27;讲师    &#x27;</span>,<span class=\"string\">&#x27;86687954&#x27;</span>,<span class=\"string\">&#x27;东软宿舍3栋206&#x27;</span>,<span class=\"string\">&#x27;Dp03&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dbo.sysobjects <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> object_id(N<span class=\"string\">&#x27;[dbo].[Schedule]&#x27;</span>) <span class=\"keyword\">and</span> OBJECTPROPERTY(id, N<span class=\"string\">&#x27;IsUserTable&#x27;</span>) <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> [dbo].[Schedule]</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"comment\">--表 Schedule 的结构</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Schedule(</span><br><span class=\"line\">TeacherID <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">references</span> Teacher(TeacherID),</span><br><span class=\"line\">CourseID <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">references</span> Course(CourseID),</span><br><span class=\"line\">ClassID <span class=\"type\">char</span>(<span class=\"number\">8</span>)  <span class=\"keyword\">references</span> Class(ClassID),</span><br><span class=\"line\">Semester <span class=\"type\">int</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">SchoolYear <span class=\"type\">int</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\"><span class=\"keyword\">primary</span> key(TeacherID,CourseID,ClassID)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">--表 Schedule 的数据</span></span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01001&#x27;</span>,<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01001&#x27;</span>,<span class=\"string\">&#x27;Dp010003&#x27;</span>,<span class=\"string\">&#x27;Cs010903&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01001&#x27;</span>,<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01001&#x27;</span>,<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01002&#x27;</span>,<span class=\"string\">&#x27;Dp010002&#x27;</span>,<span class=\"string\">&#x27;Cs011104&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01003&#x27;</span>,<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;Cs011104&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2012</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01003&#x27;</span>,<span class=\"string\">&#x27;Dp010004&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">2011</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01005&#x27;</span>,<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01005&#x27;</span>,<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep01005&#x27;</span>,<span class=\"string\">&#x27;Dp010001&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep02001&#x27;</span>,<span class=\"string\">&#x27;Dp020001&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep03001&#x27;</span>,<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;Cs010901&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep03001&#x27;</span>,<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;Cs010902&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2009</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep03001&#x27;</span>,<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;Cs011104&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2011</span>)</span><br><span class=\"line\"> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Schedule([TeacherID],[CourseID],[ClassID],[Semester],[SchoolYear]) <span class=\"keyword\">Values</span>(<span class=\"string\">&#x27;dep03003&#x27;</span>,<span class=\"string\">&#x27;Dp030001&#x27;</span>,<span class=\"string\">&#x27;Cs021001&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2010</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"1-3-3-单表查询和多表查询\"   >\n          <a href=\"#1-3-3-单表查询和多表查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-3-3-单表查询和多表查询\" class=\"headerlink\" title=\"1.3.3 单表查询和多表查询\"></a>1.3.3 单表查询和多表查询</h3>\n      <p>书上p42</p>\n<ul>\n<li>单表查询<ul>\n<li>只从一张表中获取数据</li>\n</ul>\n</li>\n<li>多表查询<ul>\n<li>从多张表中获取数据</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"1-4-数据查询\"   >\n          <a href=\"#1-4-数据查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-4-数据查询\" class=\"headerlink\" title=\"1.4 数据查询\"></a>1.4 数据查询</h2>\n      <p>这里是基本查询语句，例子都是单表查询的语句</p>\n\n        <h3 id=\"1-4-1-SELECT语句\"   >\n          <a href=\"#1-4-1-SELECT语句\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-4-1-SELECT语句\" class=\"headerlink\" title=\"1.4.1 SELECT语句\"></a>1.4.1 SELECT语句</h3>\n      <p>通过<strong>SELECT</strong>语句查询是检索数据库信息的唯一方式，是SQL语句中使用频率最高的语句。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> [<span class=\"keyword\">ALL</span><span class=\"operator\">|</span><span class=\"keyword\">DISTINCT</span>]   [TOP n[<span class=\"keyword\">percent</span>]]<span class=\"operator\">&lt;</span>目标列表达式<span class=\"operator\">&gt;</span>   [，<span class=\"operator\">&lt;</span>目标列表达式<span class=\"operator\">&gt;</span>] …</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"operator\">&lt;</span>表名或视图名<span class=\"operator\">&gt;</span>[， <span class=\"operator\">&lt;</span>表名或视图名<span class=\"operator\">&gt;</span> ] …</span><br><span class=\"line\">[ <span class=\"keyword\">WHERE</span> <span class=\"operator\">&lt;</span>条件表达式<span class=\"operator\">&gt;</span> ]<span class=\"comment\">/*有条件的*/</span></span><br><span class=\"line\">[ <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> <span class=\"operator\">&lt;</span>列名<span class=\"number\">1</span><span class=\"operator\">&gt;</span> [ <span class=\"keyword\">HAVING</span> <span class=\"operator\">&lt;</span>条件表达式<span class=\"operator\">&gt;</span> ] ]</span><br><span class=\"line\"><span class=\"comment\">/*对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚合函数。*/</span></span><br><span class=\"line\">[ <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"operator\">&lt;</span>列名<span class=\"number\">2</span><span class=\"operator\">&gt;</span> [ <span class=\"keyword\">ASC</span><span class=\"operator\">|</span><span class=\"keyword\">DESC</span> ] ]；</span><br><span class=\"line\"><span class=\"comment\">/*对查询结果表按指定列值进行升序或降序排序 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student</span><br><span class=\"line\"><span class=\"comment\">--查询student表中所有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> student <span class=\"keyword\">as</span> 姓名,sex <span class=\"keyword\">as</span> 性别,studentid <span class=\"keyword\">from</span> student</span><br><span class=\"line\"><span class=\"keyword\">where</span> sex<span class=\"operator\">=</span><span class=\"string\">&#x27;女&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">--从student表中查找student,studentid以及sex列为&#x27;女&#x27;的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">可以在<span class=\"keyword\">select</span>后加top <span class=\"number\">5</span>来查询前<span class=\"number\">5</span>个数据，或top <span class=\"number\">5</span> <span class=\"keyword\">percent</span>来查询前<span class=\"number\">5</span><span class=\"operator\">%</span>的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">组后加<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">desc</span>可以降序排序。</span><br><span class=\"line\"></span><br><span class=\"line\">在条件中可以使用<span class=\"keyword\">AND</span>连接条件语句实现多重判断。</span><br><span class=\"line\"><span class=\"keyword\">where</span> sex<span class=\"operator\">=</span><span class=\"string\">&#x27;女&#x27;</span> <span class=\"keyword\">or</span> studentname <span class=\"keyword\">like</span> <span class=\"string\">&#x27;李%&#x27;</span></span><br><span class=\"line\"><span class=\"operator\">%</span>通配任意位数，_通配一位。</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"1-4-2-条件表达式中常用运算符号\"   >\n          <a href=\"#1-4-2-条件表达式中常用运算符号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-4-2-条件表达式中常用运算符号\" class=\"headerlink\" title=\"1.4.2 条件表达式中常用运算符号\"></a>1.4.2 条件表达式中常用运算符号</h3>\n      <ol>\n<li>比较：<code>&gt;,&gt;=,&lt;,&lt;=,=,!=,&lt;&gt;(,!&gt;,!&lt;)</code></li>\n<li>范围：<code>between …… and …… </code>包含边界的</li>\n<li>集合：<code>in, NOT IN</code></li>\n<li>匹配：<code>like (%:任意个字符，_:单个字符，[]:匹配[]中的任意一个字符，[^ ]不匹配[]中的全部字符)  NOT LIKE</code></li>\n<li>空值：<code>is null；is not null</code></li>\n<li>逻辑：<code>and，or，not</code></li>\n<li>取查询结果某几行<code>(top n[percent])</code></li>\n<li>去重结果重复项<code>(distinct)</code></li>\n<li>排序：<code>ORDER BY (ASC升序（默认）、DESC降序）</code></li>\n</ol>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student</span><br><span class=\"line\"><span class=\"keyword\">where</span> studentname <span class=\"keyword\">not</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;王%&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">and</span> sex<span class=\"operator\">=</span><span class=\"string\">&#x27;男&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">/*查询所有不姓王的男生*/</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"1-4-3-小实践\"   >\n          <a href=\"#1-4-3-小实践\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-4-3-小实践\" class=\"headerlink\" title=\"1.4.3 小实践\"></a>1.4.3 小实践</h3>\n      <p>查询所有学生的学号、姓名和年龄</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> StudentID,StudentName,<span class=\"built_in\">floor</span>(DATEDIFF(<span class=\"keyword\">YEAR</span>,Student.Brith,GETDATE())) <span class=\"keyword\">from</span> Student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">floor</span>()<span class=\"comment\">/*向下取整*/</span></span><br><span class=\"line\">GetDate()<span class=\"comment\">/*获取当前时间*/</span></span><br><span class=\"line\">datediff(datepart,startdate,enddate)</span><br><span class=\"line\"><span class=\"comment\">/*返回两个日期之间相差的时间*/</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"课后整理\"   >\n          <a href=\"#课后整理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#课后整理\" class=\"headerlink\" title=\"课后整理\"></a>课后整理</h2>\n      \n        <h3 id=\"1-取消取值重复的行\"   >\n          <a href=\"#1-取消取值重复的行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-取消取值重复的行\" class=\"headerlink\" title=\"1. 取消取值重复的行\"></a>1. 取消取值重复的行</h3>\n      <p>在<code>SELECT</code>子句中使用<code>DISTINCT</code>短语</p>\n<ul>\n<li><code>DISTINCT</code>关键字可以去掉查询结果中的重复行（所有字段相同才为重复），放在select的后面，目标列的前面</li>\n</ul>\n\n        <h3 id=\"2-BETWENN-……-AND-……\"   >\n          <a href=\"#2-BETWENN-……-AND-……\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-BETWENN-……-AND-……\" class=\"headerlink\" title=\"2.BETWENN …… AND ……\"></a>2.BETWENN …… AND ……</h3>\n      <p><code>BETWEEN</code>包含边界值、<code>NOT BETWEEN</code>不包含边界值！</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"keyword\">BETWEEN</span> <span class=\"number\">2000</span> <span class=\"keyword\">AND</span> <span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"comment\">--工资在2000和3000之间，包括2000和3000的人</span></span><br></pre></td></tr></table></div></figure>\n\n<p>除了使用<code>BETWEEN AND</code>外，还可以使用<code>&gt;= &lt;=</code>的方法来进行范围筛选。</p>\n\n        <h3 id=\"3-确定集合IN\"   >\n          <a href=\"#3-确定集合IN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-确定集合IN\" class=\"headerlink\" title=\"3. 确定集合IN\"></a>3. 确定集合IN</h3>\n      <p>可以指定一个表，表中列出所有可能的值，当表达式与表中的任一个值匹配时，就返回TRUE，否则返回FALSE</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"keyword\">IN</span> (<span class=\"number\">2000</span>,<span class=\"number\">1800</span>,<span class=\"number\">4000</span>)</span><br><span class=\"line\"><span class=\"comment\">--工资是2000或1800或4000</span></span><br></pre></td></tr></table></div></figure>\n\n<p>除了使用<code>IN</code>外，还可以使用<code>=</code>来进行判断。</p>\n\n        <h3 id=\"4-模糊查询：字符匹配LIKE\"   >\n          <a href=\"#4-模糊查询：字符匹配LIKE\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-模糊查询：字符匹配LIKE\" class=\"headerlink\" title=\"4. 模糊查询：字符匹配LIKE\"></a>4. 模糊查询：字符匹配LIKE</h3>\n      <p>如果条件不确定，必须使用<code>LIKE</code>关键字进行模糊查询：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHERE</span> name <span class=\"keyword\">LIKE</span> 李<span class=\"operator\">%</span></span><br><span class=\"line\"><span class=\"comment\">--定位姓李的</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>用<code>LIKE</code>进行字符串匹配，将该字符串叫<code>匹配串</code>。用它与<code>属性值</code>进行比较。</li>\n<li>匹配串中的通配符包括：<code>%</code>、<code>_</code></li>\n</ul>\n\n        <h3 id=\"5-通配符\"   >\n          <a href=\"#5-通配符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-通配符\" class=\"headerlink\" title=\"5.通配符\"></a>5.通配符</h3>\n      <ul>\n<li>%：零个或多个任意字符串</li>\n<li>_：任意单个字符</li>\n<li>[ ]：在指定范围内的单个字符<ul>\n<li><code>LIKE &#39;[AB]%&#39;</code>以A或B开头的字符串</li>\n</ul>\n</li>\n<li>[^ ]：不在指定范围内的单个字符<ul>\n<li> <code>LIKE &#39;[^AB]%&#39;</code>表示不以A或B开头的字符串</li>\n</ul>\n</li>\n</ul>\n<p>由于通配符的存在，在不使用通配符的情况下要加上转义字符<code>\\</code>。</p>\n\n        <h3 id=\"6-空值查询：IS-NULL-IS-NOT-NULL\"   >\n          <a href=\"#6-空值查询：IS-NULL-IS-NOT-NULL\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-空值查询：IS-NULL-IS-NOT-NULL\" class=\"headerlink\" title=\"6. 空值查询：IS NULL/IS NOT NULL\"></a>6. 空值查询：IS NULL/IS NOT NULL</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br></pre></td></tr></table></div></figure>\n\n<p><code>NULL</code>不是数值，它的含义是没有，因此不能用<code>=</code>等运算符进行判断。</p>\n\n        <h3 id=\"7-WHERE子句中的逻辑运算符\"   >\n          <a href=\"#7-WHERE子句中的逻辑运算符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-WHERE子句中的逻辑运算符\" class=\"headerlink\" title=\"7. WHERE子句中的逻辑运算符\"></a>7. WHERE子句中的逻辑运算符</h3>\n      <ul>\n<li>AND： 连接两个条件，仅当条件都为真才返回</li>\n<li>OR：  连接两个条件，只要其中一个为真就返回</li>\n<li>NOT： 否定一个条件，只有条件不成立才返回</li>\n</ul>\n<p>当一条语句中使用了多个逻辑运算符时，首先求<code>NOT</code>的值，然后求<code>AND</code>的值，最后再求<code>OR</code>的值。</p>\n\n        <h3 id=\"8-查询语句中的排序\"   >\n          <a href=\"#8-查询语句中的排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-查询语句中的排序\" class=\"headerlink\" title=\"8. 查询语句中的排序\"></a>8. 查询语句中的排序</h3>\n      <p>在SQL语句中，通过<code>ORDER BY</code>子句，可以将查询结果进行排序显示</p>\n<p>排序默认升序，即使用<code>ASC</code>关键字，如果想要降序排序可以使用<code>DES</code>。</p>\n<p>当<code>ORDER BY</code>子句指定了多个排序列时，系统先按照第一个参数进行排列，当出现相同值时，在按照第二个参数进行排序，以此类推。</p>\n\n        <h3 id=\"9-统计操作\"   >\n          <a href=\"#9-统计操作\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-统计操作\" class=\"headerlink\" title=\"9. 统计操作\"></a>9. 统计操作</h3>\n      <p>在&lt;目标列表达式&gt;中常使用的<code>聚合函数</code>:</p>\n<ul>\n<li>Count([distinct|all]*)<ul>\n<li>统计元组个数</li>\n</ul>\n</li>\n<li>Count([distinct|all]&lt;列名&gt;)<ul>\n<li>统计一列中值的个数</li>\n</ul>\n</li>\n<li>sum([distinct|all]&lt;列名&gt;)<ul>\n<li>求一列值的总和</li>\n</ul>\n</li>\n<li>avg([distinct|all]&lt;列名&gt;)<ul>\n<li>求一列值的平均值</li>\n</ul>\n</li>\n<li>max([distinct|all]&lt;列名&gt;)<ul>\n<li>求一列值中的最大值</li>\n</ul>\n</li>\n<li>min([distinct|all]&lt;列名&gt;)<ul>\n<li>求一列值中的最小值</li>\n</ul>\n</li>\n</ul>\n<p>上述函数，除count(*)外，其他函数均忽略null值。</p>\n<p>但是count()指定了字段，就会忽略null值。</p>\n<p>例子：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> 系别<span class=\"operator\">=</span><span class=\"string\">&#x27;计科系&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">--查询计算机系的学生人数</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span>(学号)) <span class=\"keyword\">as</span> 人数 <span class=\"keyword\">from</span> choice</span><br><span class=\"line\"><span class=\"comment\">--查询选修了课程的学生人数</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">max</span>(成绩),<span class=\"built_in\">min</span>(成绩),<span class=\"built_in\">avg</span>(成绩) <span class=\"keyword\">from</span> choice <span class=\"keyword\">where</span> 课程号<span class=\"operator\">=</span> <span class=\"string\">&#x27;Dp0101001&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">--查询Dp0101001课程的最高分、最低分和平均成绩</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"10-对查询结果进行分组\"   >\n          <a href=\"#10-对查询结果进行分组\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#10-对查询结果进行分组\" class=\"headerlink\" title=\"10. 对查询结果进行分组\"></a>10. 对查询结果进行分组</h3>\n      <p>带有<code>GROUP BY</code>子句的查询语句中，SELECT子句后面的结果集只能包含分组依据(GROUP BY子句后面的列)和聚合函数。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> …… <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"operator\">&lt;</span>分组依据<span class=\"operator\">&gt;</span></span><br><span class=\"line\">[<span class=\"keyword\">HAVING</span> <span class=\"operator\">&lt;</span>组提取条件表达式<span class=\"operator\">&gt;</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--having的作用对象时组，即表示对分组后的记录进行筛选。</span></span><br></pre></td></tr></table></div></figure>\n\n<p>例子：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> 学号 <span class=\"keyword\">from</span> choice <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> 学号 <span class=\"keyword\">having</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">--查询选修了3门以上课程的学生学号</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> 课程号,<span class=\"built_in\">COUNT</span>(学号) <span class=\"keyword\">AS</span> 考试人数, <span class=\"built_in\">MAX</span>(成绩), <span class=\"built_in\">MIN</span>(成绩),<span class=\"built_in\">AVG</span>(成绩),<span class=\"built_in\">SUM</span>(成绩)</span><br><span class=\"line\"><span class=\"keyword\">from</span> Choice</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span>  <span class=\"keyword\">by</span> 课程号</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span>(<span class=\"built_in\">AVG</span>(成绩)<span class=\"operator\">&gt;</span><span class=\"number\">75</span>)</span><br><span class=\"line\"><span class=\"comment\">--统计出平均分在75分以上每门课程的课程号、考试人数、最高成绩、最低成绩、平均成绩及总成绩。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"11-group-by子句与with-rollup选项\"   >\n          <a href=\"#11-group-by子句与with-rollup选项\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#11-group-by子句与with-rollup选项\" class=\"headerlink\" title=\"11. group by子句与with rollup选项\"></a>11. group by子句与with rollup选项</h3>\n      <p><code>group by</code>子句将结果集分为若干个组，使用聚合函数可以对每个组内的数据进行信息统计，有时需要对各个组进行汇总运算，则需要在每个分组后加上一条汇总记录，这个任务可以通过<code>with rollup</code>选项实现</p>\n <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> classid,<span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)   <span class=\"keyword\">from</span> student</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span>  classid <span class=\"keyword\">with</span> <span class=\"keyword\">ROLLUP</span></span><br><span class=\"line\"><span class=\"comment\">--在同一张表中各班有若干名学生，按照班级号分类并进行统计显示</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"网课内容\"   >\n          <a href=\"#网课内容\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课内容\" class=\"headerlink\" title=\"网课内容\"></a>网课内容</h2>\n      <ul>\n<li><p>逻辑结构</p>\n<ul>\n<li>表：用于存放数据，由行和列组成</li>\n<li>视图：可以看成是虚拟表或存储查询</li>\n<li>索引：用于快速查找所需信息</li>\n<li>存储过程：用于完成特定功能的SQL语句集</li>\n<li>触发器：一种特殊类型的存储过程</li>\n</ul>\n</li>\n<li><p>物理结构</p>\n<ul>\n<li>主数据库文件(.mdf)：存放DB的启动信息、部分或全部数据和数据库对象<ul>\n<li>必须要有</li>\n</ul>\n</li>\n<li>辅助数据库文件(.ndf)：存放除数据库文件外的数据和数据库对象<ul>\n<li>可以根据需要设置一个或多个</li>\n</ul>\n</li>\n<li>事务日志文件(.ldf)：用来存放恢复数据库所需的事物日志信息，记录数据库更新情况<ul>\n<li>至少一个</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>系统数据库</p>\n<ul>\n<li>master<ul>\n<li>对用户数据库和SQL Server的操作进行总体控制。</li>\n<li>主要记录与sql server相关的所有系统级信息，包括登录账号、系统配置、数据库位置及实例的初始化信息等。</li>\n</ul>\n</li>\n<li>model<ul>\n<li>提供创建新用户数据库所需的模板和原型</li>\n</ul>\n</li>\n<li>tempdb<ul>\n<li>保存临时表盒其他临时存储过程，是sql server上所有数据库共享的工作空间。</li>\n<li>每次sql server启动时，都会重新创建一个<code>tempdb</code>数据库以保证该数据库总是空的；当用户断开数据库连接时，系统会自动删除临时表和存储过程。</li>\n</ul>\n</li>\n<li>msdb<ul>\n<li>提供调度信息和作业历史记录所需的存储区，用于代理程序调度警报和作业等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第2课\"   >\n          <a href=\"#第2课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第2课\" class=\"headerlink\" title=\"第2课\"></a>第2课</h1>\n      \n        <h2 id=\"数据库检索顺序\"   >\n          <a href=\"#数据库检索顺序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据库检索顺序\" class=\"headerlink\" title=\"数据库检索顺序\"></a>数据库检索顺序</h2>\n      <p>首先检索表名，其次检索<code>WHERE</code>，再检索字段，最后的最后<code>ORDER BY</code></p>\n\n        <h2 id=\"查询指定的列或全部列\"   >\n          <a href=\"#查询指定的列或全部列\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#查询指定的列或全部列\" class=\"headerlink\" title=\"查询指定的列或全部列\"></a>查询指定的列或全部列</h2>\n      <p>使用以下的几种方式指定字段列表：</p>\n<p>字段列表：</p>\n<ul>\n<li>*：字段列表为数据源的全部字段</li>\n<li>表明.*：多表查询时，指定某个表的全部字段。</li>\n<li>字段列表：指定所需要显示的列</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> sex,<span class=\"built_in\">count</span>(HomeAddr)</span><br><span class=\"line\"><span class=\"comment\">--指定了HomeAddr会直接过滤掉NULL</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> student</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--等价于</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> sex,<span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)</span><br><span class=\"line\"><span class=\"comment\">--指定了HomeAddr会直接过滤掉NULL</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> student</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> HomeAddr <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex</span><br></pre></td></tr></table></div></figure>\n\n <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(StudentID) 选修人数,<span class=\"built_in\">COUNT</span>(StudentID)<span class=\"operator\">-</span><span class=\"built_in\">COUNT</span>(Grade) 缺考人数,(<span class=\"built_in\">COUNT</span>(StudentID)<span class=\"operator\">-</span><span class=\"built_in\">COUNT</span>(Grade))<span class=\"operator\">/</span><span class=\"built_in\">COUNT</span>(StudentID) 百分比 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Grade</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> CourseID <span class=\"operator\">=</span> <span class=\"string\">&#x27;Dp010001&#x27;</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"网课\"   >\n          <a href=\"#网课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课\" class=\"headerlink\" title=\"网课\"></a>网课</h2>\n      \n        <h3 id=\"用T-SQL语句创建数据库\"   >\n          <a href=\"#用T-SQL语句创建数据库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#用T-SQL语句创建数据库\" class=\"headerlink\" title=\"用T-SQL语句创建数据库\"></a>用T-SQL语句创建数据库</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">数据库主体代码：</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE 数据库名</span><br><span class=\"line\"><span class=\"keyword\">ON</span> [<span class=\"keyword\">PRIMARY</span>](……</span><br><span class=\"line\">……)</span><br><span class=\"line\">LOG <span class=\"keyword\">ON</span></span><br><span class=\"line\">(……</span><br><span class=\"line\">……)</span><br></pre></td></tr></table></div></figure>\n\n<p>数据库参数：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">NAME <span class=\"operator\">=</span> xkgl_data1,<span class=\"comment\">--指定数据文件或日志文件的逻辑名称</span></span><br><span class=\"line\">FILENAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;d:\\db\\xkgl_data1.mdf&#x27;</span>,<span class=\"comment\">--指定物理文件或日志文件的物理名称，包括路径和含后缀的文件名。</span></span><br><span class=\"line\">SIZE <span class=\"operator\">=</span> <span class=\"number\">6</span>MB,<span class=\"comment\">--指定数据文件或日志文件的初始大小，默认单位是MB，主文件必须至少是5MB</span></span><br><span class=\"line\">MAXSIZE <span class=\"operator\">=</span> <span class=\"number\">30</span>MB,<span class=\"comment\">--指定数据文件或日志文件可以增长到最大容量，默认单位为MB</span></span><br><span class=\"line\">FILEGROWTH <span class=\"operator\">=</span> <span class=\"number\">2</span>MB<span class=\"comment\">--指定数据文件或日志文件的增长幅度，默认单位为MB,也可以按百分比增长。</span></span><br></pre></td></tr></table></div></figure>\n\n<p>数据库分为3步：</p>\n<ol>\n<li>定义<strong>数据库的名字</strong></li>\n<li>定义<strong>数据文件</strong></li>\n<li>定义<strong>日志文件</strong></li>\n</ol>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE teacher</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">PRIMARY</span>    <span class=\"comment\">/*创建主要数据文件*/</span></span><br><span class=\"line\">(</span><br><span class=\"line\">  NAME <span class=\"operator\">=</span> teacher_data,</span><br><span class=\"line\">  FILENAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;D:\\db\\teacher_data.mdf&#x27;</span>,</span><br><span class=\"line\">  SIZE <span class=\"operator\">=</span> <span class=\"number\">5</span>MB,<span class=\"comment\">--默认字节单位MB可以省略</span></span><br><span class=\"line\">  MAXSIZE <span class=\"operator\">=</span> <span class=\"number\">10</span>,<span class=\"comment\">-- 文件最大容量10MB</span></span><br><span class=\"line\">  FILEGROWTH <span class=\"operator\">=</span> <span class=\"number\">15</span><span class=\"operator\">%</span><span class=\"comment\">-- 增长量为文件容量15%</span></span><br><span class=\"line\">)</span><br><span class=\"line\">LOG <span class=\"keyword\">ON</span>    <span class=\"comment\">/*创建日志文件*/</span></span><br><span class=\"line\">(</span><br><span class=\"line\">  NAME <span class=\"operator\">=</span> teacher_log,</span><br><span class=\"line\">  FILENAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;D:\\db\\teacher_log.LDF&#x27;</span>,</span><br><span class=\"line\">  SIZE <span class=\"operator\">=</span> <span class=\"number\">500</span>KB,       <span class=\"comment\">/*初始容量，KB单位不能省略*/</span></span><br><span class=\"line\">  MAXSIZE <span class=\"operator\">=</span> UNLIMITED,  <span class=\"comment\">/*日志文件最大容量不受限制*/</span></span><br><span class=\"line\">  FILEGROWTH <span class=\"operator\">=</span> <span class=\"number\">500</span>KB  <span class=\"comment\">/*增长量KB不能省略*/</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"删除数据库\"   >\n          <a href=\"#删除数据库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3>\n      <ol>\n<li>使用SSMS工具删除，直接右键数据库，选择删除进行删除。</li>\n<li>使用T-SQL语句进行删除</li>\n</ol>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> DATABASE <span class=\"operator\">&lt;</span>数据库名<span class=\"operator\">&gt;</span> [[,<span class=\"operator\">&lt;</span>数据库名<span class=\"operator\">&gt;</span>]…]</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"数据库的相关操作\"   >\n          <a href=\"#数据库的相关操作\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据库的相关操作\" class=\"headerlink\" title=\"数据库的相关操作\"></a>数据库的相关操作</h3>\n      <ol>\n<li>分离数据库<ul>\n<li>分离数据库就是将某个数据库从SQL Server数据库列表中删除，使其不再被SQL Server管理和使用，但该数据库的<strong>数据文件和对应的日志文件完好无损。</strong>分离成功后，我们就可以吧数据文件和对应的日志文件拷贝到其他磁盘中作为备份保存。</li>\n<li>使用SSMS工具分离：<ul>\n<li>右键数据库选择<code>任务</code>下的<code>分离</code>命令进行分离</li>\n<li>只有在<strong>“使用本数据库的连接”数为0</strong>时，该数据库才能分离。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>附加数据库<ul>\n<li>附加数据库就是将一个备份磁盘中的<strong>数据文件和对应的日志文件</strong>拷贝到需要的计算机，并将其添加到某个SQL Server数据库服务器中，由该服务器来管理和使用这个数据库。</li>\n<li>使用SSMS工具附加数据库：<ul>\n<li>右键数据库结点，选择<code>附加</code>命令。</li>\n<li>出现<code>附加数据库</code>对话框，单机<code>添加</code>按钮，出现<code>定位数据库文件</code>对话框，在这个对话框里，默认只显示数据库的主要文件，即<code>mdf</code>文件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>改变数据库状态(脱机、联机)<ul>\n<li>数据库有<code>脱机</code>与<code>联网</code>两种状态，当一个数据库处于<strong>可操作、可查询</strong>的状态时就是<strong>联机状态</strong>，而一个数据库尽管可以看到其名字出现在数据库节点中，但对其<strong>不能执行任何有效的数据库操作</strong>时就是<strong>脱机状态</strong>。</li>\n<li>用SSMS工具脱机：<ul>\n<li>右键数据库，选择<code>任务</code>下的<code>脱机</code>命令。</li>\n<li>弹出<code>使数据库脱机</code>对话框，单击<code>关闭</code>即可完成。</li>\n</ul>\n</li>\n<li>用SSMS工具联机：<ul>\n<li>右键数据库，选择<code>任务</code>下的<code>联机</code>命令。</li>\n<li>弹出<code>使数据库脱机</code>对话框，单击<code>关闭</code>即可完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"完整性约束\"   >\n          <a href=\"#完整性约束\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#完整性约束\" class=\"headerlink\" title=\"完整性约束\"></a>完整性约束</h3>\n      <p>完整性约束是为保证数据库中数据的<strong>正确性和相容性</strong>，而对关系模型提出的某种<strong>约束条件或规则</strong>。</p>\n<ol>\n<li>取值为空或者非空的约束<ul>\n<li>取值为空或者非空的约束是对<strong>表中某个字段的取值进行限制</strong>。</li>\n<li>取值为空表示字段可以<strong>取空值</strong>。</li>\n<li>取值为空表示字段<strong>不可以取空值</strong>。</li>\n<li>空值表示不知道不确定的意思，不同于0。</li>\n</ul>\n</li>\n<li>唯一性约束<ul>\n<li>唯一性约束是指<strong>基本表在一个字段或者多个字段的组合上的取值唯一。</strong></li>\n<li>定义了唯一性约束的字段称为唯一键，唯一键可为空，<strong>最多只能取一个空值</strong>。</li>\n</ul>\n</li>\n<li>主码约束<ul>\n<li>主码约束是指<strong>将表中一个字段或者多个字段的组合定义为该表的主码</strong>，<strong>主码的取值不能为空</strong>，且表中任意两行在主码上的<strong>取值不能相同</strong>。(<strong>唯一且非空</strong>)</li>\n</ul>\n</li>\n<li>外码约束<ul>\n<li>外码约束是指将表中的一个字段定义为<strong>外码</strong>，外码的取值可以<strong>为空</strong>或者<strong>等于另外一张表中某个元组的主码值</strong>。</li>\n<li>含外码的这张表叫子表，另一张表叫父表。</li>\n</ul>\n</li>\n<li>默认值约束<ul>\n<li>默认值约束是指<strong>为某个字段指定默认值</strong>，当为某个字段指定默认值后，想表中输入数据时如果不为该字段指定其它值，系统将取默认值。</li>\n</ul>\n</li>\n<li>列值约束<ul>\n<li>列值约束是用来指定某个字段的<strong>取值范围</strong>。</li>\n</ul>\n</li>\n</ol>\n<p>主码约束和唯一性约束的区别：</p>\n<ol>\n<li>在一个基本表中只能定义一个主码约束，但可定义多个唯一性约束。</li>\n<li>被指定为主码的字段，<strong>不能出现空值</strong>，而被定义为唯一键的字段，则<strong>允许为空，但最多只能取一个空值</strong>。</li>\n</ol>\n\n        <h3 id=\"创建表\"   >\n          <a href=\"#创建表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3>\n      <p>表是数据库中最重要的对象，用于存储用户数据，</p>\n<p>创建新标的实质是定义新表的结构，其中有三大要素需要确定，分别是：</p>\n<ul>\n<li>列名(易于理解，不可重名，长度合适)</li>\n<li>数据类型</li>\n<li>约束条件</li>\n</ul>\n<p>数据类型：</p>\n<ul>\n<li>数值型<ul>\n<li>整形<ul>\n<li>tinyint</li>\n<li>smallint</li>\n<li>int</li>\n<li>bigint</li>\n</ul>\n</li>\n<li>定点型<ul>\n<li>decimal</li>\n<li>numeric</li>\n</ul>\n</li>\n<li>浮点型<ul>\n<li>float</li>\n<li>real</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>字符型<ul>\n<li>普通字符型<ul>\n<li>char</li>\n<li>varchar</li>\n<li>text</li>\n</ul>\n</li>\n<li>Unicode字符型<ul>\n<li>nchar</li>\n<li>nvarchar</li>\n<li>ntext</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>日期时间型<ul>\n<li>datatime</li>\n<li>smalldatetime</li>\n</ul>\n</li>\n<li>货币型<ul>\n<li>money</li>\n<li>smallmoney</li>\n</ul>\n</li>\n<li>二进制字符型<ul>\n<li>binary</li>\n<li>varbinary</li>\n<li>image</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>用SSMS工具来创建表</li>\n</ol>\n<ul>\n<li>右键<code>数据库</code>后选择<code>表</code>中的<code>表</code>命令后，定义列名、数据类型以及设定是否允许Null值。</li>\n<li>右键<code>列名</code>可以选择设置主键。</li>\n<li>所有的特殊操作都右键操作。</li>\n</ul>\n<ol start=\"2\">\n<li>用T-SQL语句创建表<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"operator\">&lt;</span>表名<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">  <span class=\"operator\">&lt;</span>列名<span class=\"operator\">&gt;</span><span class=\"operator\">&lt;</span>数据类型<span class=\"operator\">&gt;</span>[列级完整性约束的定义]</span><br><span class=\"line\">  [,<span class=\"operator\">&lt;</span>列名<span class=\"operator\">&gt;</span><span class=\"operator\">&lt;</span>数据类型<span class=\"operator\">&gt;</span>[列级完整性约束的定义]……]</span><br><span class=\"line\">  [,表级完整性约束的定义]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure></li>\n</ol>\n\n        <h3 id=\"完整性约束名\"   >\n          <a href=\"#完整性约束名\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#完整性约束名\" class=\"headerlink\" title=\"完整性约束名\"></a>完整性约束名</h3>\n      <ol>\n<li>取值为空或者非空约束<ul>\n<li>NULL/NOT NULL</li>\n<li>只能定义为“列级完整性约束”</li>\n<li><code>sname char(10) NOT NULL</code></li>\n<li>默认是允许为空</li>\n</ul>\n</li>\n<li>唯一性约束<ul>\n<li>UNIQUE</li>\n<li>可以定义为“列级完整性约束”，也可以定义为“表级完整性约束”。<ul>\n<li>列级约束：在定义列时定义唯一约束<ul>\n<li><code>&lt;列名&gt;&lt;数据类型&gt;unique</code></li>\n</ul>\n</li>\n<li>表级约束：在定义完列之后定义唯一约束<ul>\n<li><code>unique(&lt;列名序列&gt;)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主码约束<ul>\n<li>PRIMARY KEY</li>\n<li>可以定义为“列级完整性约束”，也可以定义为“表级完整性约束”。<ul>\n<li>列级约束：在定义列时定义主码(仅用于主码由一个字段构成)<ul>\n<li><code>&lt;列名&gt;&lt;数据类型&gt;PRIMARY KEY</code></li>\n</ul>\n</li>\n<li>表级约束：在定义完列时定义主码(用于主码由一个字段或者多个字段构成)<ul>\n<li><code>PRIMARY KEY(&lt;列名序列&gt;)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主码由一个字段或者多个字段构成时，只能定义为“表级完整性约束”。</li>\n</ul>\n</li>\n<li>外码约束<ul>\n<li>参照完整性</li>\n<li>FOREIGN KEY</li>\n<li>可以定义为“列级完整性约束”，也可定义为“表级完整性约束”。<ul>\n<li>列级约束：在定义列时定义外码<ul>\n<li><code>&lt;列名&gt; &lt;数据类型&gt; REFERENCES &lt;父表名&gt;(&lt;父表的主码列名&gt;)</code></li>\n</ul>\n</li>\n<li>表级约束：在定义完列时定义外码<ul>\n<li><code>FOREIGN KEY (&lt;列名&gt;) REFERENCES</code> &lt;父表名&gt; (&lt;父表的主码列名&gt;)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>默认值约束<ul>\n<li>DEFAULT</li>\n<li>只能定义为“列级完整性约束”</li>\n<li><code>sex char(2) DEFAULT &#39;女&#39;</code></li>\n</ul>\n</li>\n<li>列值约束：限制列的取值范围的约束<ul>\n<li>CHECK</li>\n<li>可以定义为“列级完整性约束”，也可以为“表级完整性约束”<ul>\n<li>列级约束：在定义列时定义约束<ul>\n<li><code>&lt;列名&gt; &lt;数据类型&gt; CHECK &lt;表达式&gt;</code></li>\n</ul>\n</li>\n<li>表级约束：在定义完列时定义约束<ul>\n<li><code>CHECK &lt;表达式&gt;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> Class(</span><br><span class=\"line\">  ClassID <span class=\"type\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">primary</span> key,</span><br><span class=\"line\">  ClassName <span class=\"type\">varchar</span>(<span class=\"number\">80</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">  Monitor <span class=\"type\">char</span>(<span class=\"number\">8</span>),</span><br><span class=\"line\">  StudentNum <span class=\"type\">int</span> <span class=\"keyword\">check</span>(StudentNum<span class=\"operator\">&gt;</span><span class=\"number\">0</span>),</span><br><span class=\"line\">  DepartmentID <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">references</span></span><br><span class=\"line\">  Department(DepartmentID)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n\n\n\n\n        <h1 id=\"第3课\"   >\n          <a href=\"#第3课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第3课\" class=\"headerlink\" title=\"第3课\"></a>第3课</h1>\n      \n        <h2 id=\"JOIN\"   >\n          <a href=\"#JOIN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#JOIN\" class=\"headerlink\" title=\"JOIN\"></a>JOIN</h2>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Course.CourseID,Course.CourseName,Student.StudentName,Grade.StudentID</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Course </span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Grade </span><br><span class=\"line\"><span class=\"keyword\">ON</span> Course.CourseID <span class=\"operator\">=</span> Grade.CourseID</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Student</span><br><span class=\"line\"><span class=\"keyword\">ON</span> Student.StudentID<span class=\"operator\">=</span>Grade.StudentID</span><br></pre></td></tr></table></div></figure>\n\n<p><code>JOIN</code>多表连到一起要分开<code>JOIN ON</code></p>\n<p>指定的列名前面要加表明避免产生二义性，为了化简可以简写表明</p>\n\n        <h2 id=\"网课-1\"   >\n          <a href=\"#网课-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课-1\" class=\"headerlink\" title=\"网课\"></a>网课</h2>\n      \n        <h3 id=\"用T-SQL语句修改表结构\"   >\n          <a href=\"#用T-SQL语句修改表结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#用T-SQL语句修改表结构\" class=\"headerlink\" title=\"用T-SQL语句修改表结构\"></a>用T-SQL语句修改表结构</h3>\n      <p>在T-SQL中采用<code>ALTER TABLE</code>语句修改表结构，通过ALTER TABLE语句可以对表添加列、删除列、修改列的定义，也可以添加和删除约束。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"operator\">&lt;</span>表名<span class=\"operator\">&gt;</span></span><br><span class=\"line\">[<span class=\"keyword\">ALTER</span> <span class=\"keyword\">COLUMN</span> <span class=\"operator\">&lt;</span>列名<span class=\"operator\">&gt;</span> <span class=\"operator\">&lt;</span>新数据类型<span class=\"operator\">&gt;</span>] <span class=\"comment\">--修改列定义</span></span><br><span class=\"line\"><span class=\"operator\">|</span>[<span class=\"keyword\">ADD</span> <span class=\"operator\">&lt;</span>列名<span class=\"operator\">&gt;</span> <span class=\"operator\">&lt;</span>数据类型<span class=\"operator\">&gt;</span> [列级完整性约束定义]]  <span class=\"comment\">--添加新列</span></span><br><span class=\"line\"><span class=\"operator\">|</span>[<span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> <span class=\"operator\">&lt;</span>列名<span class=\"operator\">&gt;</span>] <span class=\"comment\">--删除列</span></span><br><span class=\"line\"><span class=\"operator\">|</span>[<span class=\"keyword\">ADD</span> [<span class=\"keyword\">CONSTRAINT</span> <span class=\"operator\">&lt;</span>约束名<span class=\"operator\">&gt;</span>]约束定义]  <span class=\"comment\">--增加约束</span></span><br><span class=\"line\"><span class=\"operator\">|</span>[<span class=\"keyword\">DROP</span> <span class=\"operator\">&lt;</span>约束名<span class=\"operator\">&gt;</span>]  <span class=\"comment\">--删除约束</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"删除数据表\"   >\n          <a href=\"#删除数据表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#删除数据表\" class=\"headerlink\" title=\"删除数据表\"></a>删除数据表</h3>\n      <ol>\n<li>用SSMS工具删除数据表<ul>\n<li>右键表，选择删除命令，点击确定即可删除</li>\n</ul>\n</li>\n<li>用T-SQL语句删除数据表<ul>\n<li><code>DROP TABLE &lt;表名&gt;[[,&lt;表名&gt;]……]</code></li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"数据库关系图\"   >\n          <a href=\"#数据库关系图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据库关系图\" class=\"headerlink\" title=\"数据库关系图\"></a>数据库关系图</h3>\n      <p>在SQL Server中，可以<strong>使用数据库关系图来创建和管理一个数据库中表之间的关系</strong>。数据库关系图作为数据库的一部分，存储在数据库中。关系图的建立可以使表间的关系以图形的方式加以显示，更加清晰的表现出表之间的关联。</p>\n<ol>\n<li>使用ssms工具创建关系图<ul>\n<li>右击数据库下数据库关系图，选择新建数据库关系图命令后添加表即可。</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"数据的导入与导出\"   >\n          <a href=\"#数据的导入与导出\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据的导入与导出\" class=\"headerlink\" title=\"数据的导入与导出\"></a>数据的导入与导出</h3>\n      <p>右键数据库选择导入数据导入就行了</p>\n\n        <h3 id=\"常用字符串函数\"   >\n          <a href=\"#常用字符串函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常用字符串函数\" class=\"headerlink\" title=\"常用字符串函数\"></a>常用字符串函数</h3>\n      <ul>\n<li>LTRIM()<ul>\n<li>函数把字符串头部(左边)的空格去掉</li>\n</ul>\n</li>\n<li>RTRIM()<ul>\n<li>函数把字符串尾部(右边)的空格去掉</li>\n</ul>\n</li>\n<li>LEFT()、RIGHT()、SUBSTRING()<ul>\n<li>函数返回部分字符串</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> RTRIM(StundentName)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">SUBSTRING</span>(<span class=\"string\">&#x27;abc&#x27;</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>) <span class=\"comment\">--取abc中第二个开始后的两个字符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">RIGHT</span>(<span class=\"string\">&#x27;abc&#x27;</span>,<span class=\"number\">2</span>) <span class=\"comment\">-- 与上同</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"UPDATAE-lt-表名-gt-SET-lt-列名-gt\"   >\n          <a href=\"#UPDATAE-lt-表名-gt-SET-lt-列名-gt\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#UPDATAE-lt-表名-gt-SET-lt-列名-gt\" class=\"headerlink\" title=\"UPDATAE &lt;表名&gt; SET &lt;列名&gt;\"></a>UPDATAE &lt;表名&gt; SET &lt;列名&gt;</h3>\n      \n        <h3 id=\"内连接\"   >\n          <a href=\"#内连接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3>\n      <ul>\n<li>自连接是一种特殊的内连接，相互连接两张表在物理上的是同一张表，但必须用别名将其在逻辑上划分为两张表。</li>\n<li>由于所有属性名都是同名属性，因此必须使用别名前缀。</li>\n</ul>\n\n        <h3 id=\"外连接\"   >\n          <a href=\"#外连接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3>\n      <ul>\n<li>内连接要求满足条件的记录才会显示，<strong>外连接是只限制一张表中的数据必须满足连接条件，而另一张表中的数据可以不满足连接条件的连接方式，</strong>外连接中的两张表的关系是不平等的。</li>\n</ul>\n<p>外连接的三中类型：</p>\n<ol>\n<li>左外连接(LEFT OUTER JOIN)<ul>\n<li>左外连接即在连接两表时，不管右表中是否有匹配数据，结果将保留左表中所有行。左表是主表，右边满足条件的记录才显示。</li>\n</ul>\n</li>\n<li>右外连接(RIGHT OUTER JOIN)<ul>\n<li>右连接原理同上</li>\n</ul>\n</li>\n<li>全外连接(FULL OUTER JOIN)<ul>\n<li>原理一样，没有数据的时候用NULL来代理</li>\n</ul>\n</li>\n</ol>\n\n        <h1 id=\"第4课\"   >\n          <a href=\"#第4课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第4课\" class=\"headerlink\" title=\"第4课\"></a>第4课</h1>\n      \n        <h2 id=\"课程回顾\"   >\n          <a href=\"#课程回顾\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#课程回顾\" class=\"headerlink\" title=\"课程回顾\"></a>课程回顾</h2>\n      \n        <h3 id=\"查询计算机系的教师所有信息\"   >\n          <a href=\"#查询计算机系的教师所有信息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#查询计算机系的教师所有信息\" class=\"headerlink\" title=\"查询计算机系的教师所有信息\"></a>查询计算机系的教师所有信息</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> t.<span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Teacher t</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Department d</span><br><span class=\"line\"><span class=\"keyword\">on</span> t.DepartmentID <span class=\"operator\">=</span> d.DepartmentID</span><br><span class=\"line\"><span class=\"keyword\">where</span> DepartmentName<span class=\"operator\">=</span><span class=\"string\">&#x27;计算机系&#x27;</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"查询信管系的所有学生信息\"   >\n          <a href=\"#查询信管系的所有学生信息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#查询信管系的所有学生信息\" class=\"headerlink\" title=\"查询信管系的所有学生信息\"></a>查询信管系的所有学生信息</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> s.<span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Student s</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Class c</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.ClassID <span class=\"operator\">=</span> s.ClassID</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Department d</span><br><span class=\"line\"><span class=\"keyword\">ON</span> d.DepartmentID <span class=\"operator\">=</span> c.DepartmentID</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> DepartmentName<span class=\"operator\">=</span><span class=\"string\">&#x27;信管系&#x27;</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"左外查询\"   >\n          <a href=\"#左外查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#左外查询\" class=\"headerlink\" title=\"左外查询\"></a>左外查询</h3>\n      <p>左外连接确保左边的数据都会出现在表中，右外连接同理</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"number\">1</span> <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> <span class=\"number\">2</span> <span class=\"keyword\">ON</span> XXXX</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"查询所有学生的学号，姓名，课程编号，成绩\"   >\n          <a href=\"#查询所有学生的学号，姓名，课程编号，成绩\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#查询所有学生的学号，姓名，课程编号，成绩\" class=\"headerlink\" title=\"查询所有学生的学号，姓名，课程编号，成绩\"></a>查询所有学生的学号，姓名，课程编号，成绩</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> s.StudentID,StudentName,CourseID,Grade</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Student s</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> Class c</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.ClassID <span class=\"operator\">=</span> s.ClassID</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> Grade g</span><br><span class=\"line\"><span class=\"keyword\">ON</span> g.StudentID <span class=\"operator\">=</span> s.StudentID</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"条件转换\"   >\n          <a href=\"#条件转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#条件转换\" class=\"headerlink\" title=\"条件转换\"></a>条件转换</h2>\n      <p>有时在查询中需要<strong>将结果以另外一种形式显示出来</strong>可以使用<code>CASE</code>子句指定数据的转换</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Teachername,Profession,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span> </span><br><span class=\"line\">  <span class=\"keyword\">WHEN</span> Profession <span class=\"operator\">=</span> <span class=\"string\">&#x27;助教&#x27;</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;初级&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">WHEN</span> Profession <span class=\"operator\">=</span> <span class=\"string\">&#x27;讲师&#x27;</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;中级&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;高级&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> 等级</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Teacher</span><br></pre></td></tr></table></div></figure>\n\n<p>用<code>CASE</code>时候，<code>SELECT</code>结尾一定要加<code>,</code>！</p>\n<p>上面是搜索型<code>CASE</code>函数，可以使用逻辑运算符。</p>\n<p>下面一种是简单型<code>CASE</code>！<strong>无法使用逻辑运算符</strong>！</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> StudentID,Sex,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span> Sex</span><br><span class=\"line\">\t<span class=\"keyword\">WHEN</span> <span class=\"string\">&#x27;男&#x27;</span> <span class=\"keyword\">THEN</span>  <span class=\"string\">&#x27;先生&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">WHEN</span> <span class=\"string\">&#x27;女&#x27;</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;女士&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;不详&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> 称呼</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Student</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>区别就是简单型<code>CASE</code>指定了列，可以每一个<code>WHEN</code>指定。</strong></p>\n<p><strong><code>WHEN</code>具有逻辑优先的！如果按类似分数分类，一定要分高的先<code>WHEN</code>！</strong></p>\n\n        <h2 id=\"子查询\"   >\n          <a href=\"#子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2>\n      \n        <h3 id=\"不相关子查询\"   >\n          <a href=\"#不相关子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#不相关子查询\" class=\"headerlink\" title=\"不相关子查询\"></a>不相关子查询</h3>\n      <p>没有内层查询，外层依然能查询出数据，只是不够精确而已。</p>\n<p>查询与张宏同日生的同学：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> StudentID,StudentName,Birth</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Student</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> Birth <span class=\"operator\">=</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> Birth</span><br><span class=\"line\">\t<span class=\"keyword\">FROM</span> Student</span><br><span class=\"line\">\t<span class=\"keyword\">WHERE</span> StudentName <span class=\"operator\">=</span> <span class=\"string\">&#x27;张宏&#x27;</span>)</span><br></pre></td></tr></table></div></figure>\n\n<p>子查询部分不能使用<code>ORDER BY</code>排序。</p>\n\n        <h2 id=\"交集-intersect\"   >\n          <a href=\"#交集-intersect\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#交集-intersect\" class=\"headerlink\" title=\"交集 intersect\"></a>交集 intersect</h2>\n      \n        <h2 id=\"子查询的谓词\"   >\n          <a href=\"#子查询的谓词\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#子查询的谓词\" class=\"headerlink\" title=\"子查询的谓词\"></a>子查询的谓词</h2>\n      <p>子查询的结果可以是<strong>单个属性值</strong>，也可以是一个<strong>集合</strong></p>\n<p>子查询只<strong>返回一个值</strong>时：用<strong>比较符或IN/NOT IN</strong></p>\n<p>子查询<strong>返回多个值</strong>时：</p>\n<ul>\n<li>(IN或NOT)：是或不是集合中的一个值</li>\n<li>(&lt;&gt;,&lt;,&gt;)ALL</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>没记完</p>\n</blockquote>\n</blockquote>\n\n        <h2 id=\"带有EXISIT\"   >\n          <a href=\"#带有EXISIT\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#带有EXISIT\" class=\"headerlink\" title=\"带有EXISIT\"></a>带有EXISIT</h2>\n      <blockquote>\n<blockquote>\n<p>依然没记完</p>\n</blockquote>\n</blockquote>\n\n        <h2 id=\"网课-2\"   >\n          <a href=\"#网课-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课-2\" class=\"headerlink\" title=\"网课\"></a>网课</h2>\n      \n        <h3 id=\"嵌套查询\"   >\n          <a href=\"#嵌套查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#嵌套查询\" class=\"headerlink\" title=\"嵌套查询\"></a>嵌套查询</h3>\n      <ul>\n<li><p>子查询可以被用于：</p>\n<ul>\n<li>集合测试</li>\n<li>比较测试</li>\n<li>存在性测试</li>\n</ul>\n</li>\n<li><p>使用子查询需要注意</p>\n<ul>\n<li>子查询可以嵌套多层</li>\n<li>子查询需要圆括号<code>()</code>括起来</li>\n<li>子查询不能使用<code>ORDER BY</code>语句</li>\n</ul>\n</li>\n<li><p>ANY</p>\n</li>\n<li><p>ALL</p>\n</li>\n</ul>\n<p>带有EXISTS的子查询只返回布尔值</p>\n<p>存在性子查询先进行父查询，然后进行子查询</p>\n\n        <h2 id=\"网课-3\"   >\n          <a href=\"#网课-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课-3\" class=\"headerlink\" title=\"网课\"></a>网课</h2>\n      \n        <h3 id=\"视图\"   >\n          <a href=\"#视图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> 名称</span><br><span class=\"line\"><span class=\"keyword\">WITH</span> ENCRYPTION <span class=\"comment\">--加密</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ……</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ……</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span> OPTION</span><br><span class=\"line\"><span class=\"comment\">--通过视图进行的修改，必须也能通过该视图看到修改后的结果。</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"索引\"   >\n          <a href=\"#索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3>\n      \n        <h4 id=\"聚集索引\"   >\n          <a href=\"#聚集索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#聚集索引\" class=\"headerlink\" title=\"聚集索引\"></a>聚集索引</h4>\n      <p>物理空间上连续</p>\n\n        <h4 id=\"非聚集索引\"   >\n          <a href=\"#非聚集索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#非聚集索引\" class=\"headerlink\" title=\"非聚集索引\"></a>非聚集索引</h4>\n      \n        <h3 id=\"变量及打印\"   >\n          <a href=\"#变量及打印\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#变量及打印\" class=\"headerlink\" title=\"变量及打印\"></a>变量及打印</h3>\n      \n        <h4 id=\"变量类型\"   >\n          <a href=\"#变量类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h4>\n      <ul>\n<li>局部变量<ul>\n<li>局部变量前加<code>@</code>，如<code>@mystr</code></li>\n<li>局部变量由用户定义，使用时先声明，再赋值</li>\n</ul>\n</li>\n<li>全局变量<ul>\n<li>全局变量前加<code>@@</code>，如<code>@@error</code></li>\n<li>全局变量由系统应以和维护，我们只能读取，不能修改全局变量的值。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"声明局部变量\"   >\n          <a href=\"#声明局部变量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#声明局部变量\" class=\"headerlink\" title=\"声明局部变量\"></a>声明局部变量</h4>\n      <ul>\n<li>基本格式</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> @变量名 数据类型 [,……n]</span><br></pre></td></tr></table></div></figure>\n\n<p>注：一次可以声明多个变量，变量用逗号隔开，所有局部变量在声明后均初始化为NULL</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> <span class=\"variable\">@stuName</span> <span class=\"type\">CHAR</span>(<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> <span class=\"variable\">@stuBirthday</span> DATETIME</span><br><span class=\"line\"><span class=\"comment\">--等价于</span></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> <span class=\"variable\">@stuName</span> <span class=\"type\">CHAR</span>(<span class=\"number\">8</span>),<span class=\"variable\">@stuBirthday</span> DATETIME</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>局部变量赋值<ul>\n<li>局部变量赋值的方法有<code>SET</code>和<code>SELECT</code>两种，<code>SET</code>语句<strong>一次只能给一个变量赋值</strong>，<code>SELECT</code>语句<strong>可同时为多个变量赋值</strong>，语法如下：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> @变量名 <span class=\"operator\">=</span> 值</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> @变量名 <span class=\"operator\">=</span> 值</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"variable\">@stuName</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;张三&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"variable\">@stuBirthday</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;1998-10-12&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">--等价于</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"variable\">@stuName</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;张三&#x27;</span>,<span class=\"variable\">@stuBirthday</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;1998-10-12&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">PRINT <span class=\"variable\">@stuName</span></span><br><span class=\"line\">PRINT <span class=\"variable\">@stuBirthday</span></span><br></pre></td></tr></table></div></figure>\n\n<p>查询结果有多条时，只能接收一条！</p>\n\n        <h3 id=\"全局变量\"   >\n          <a href=\"#全局变量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3>\n      <ul>\n<li><p>由系统提供且预先声明的变量</p>\n</li>\n<li><p>用户只能引用</p>\n</li>\n<li><p>使用<code>@@</code></p>\n</li>\n<li><p>用户不能定义和全局变量同名的局部变量，否则报错</p>\n</li>\n<li><p>常用全局变量</p>\n<ul>\n<li>@@ERROR<ul>\n<li>最后一个T-SQL错误的错误号</li>\n</ul>\n</li>\n<li>@@IDENTITY<ul>\n<li>最后一次插入的标识值</li>\n</ul>\n</li>\n<li>@@LANGUAGE<ul>\n<li>当前使用的语言的名称</li>\n</ul>\n</li>\n<li>@@MAX_CONNECTIONS<ul>\n<li>可以创建的同时连接的最大数目</li>\n</ul>\n</li>\n<li>@@ROWCOUNT<ul>\n<li>受上一个SQL语句影响的行数</li>\n</ul>\n</li>\n<li>@@SERVERNAME<ul>\n<li>本地服务器的名称</li>\n</ul>\n</li>\n<li>@@TRANSCONUNT<ul>\n<li>当前连接打开的事务数</li>\n</ul>\n</li>\n<li>@@VERSION<ul>\n<li>SQL Server的版本信息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"流程控制-IF\"   >\n          <a href=\"#流程控制-IF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流程控制-IF\" class=\"headerlink\" title=\"流程控制-IF\"></a>流程控制-IF</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">IF 布尔表达式</span><br><span class=\"line\">  <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    语句<span class=\"number\">1</span></span><br><span class=\"line\">    语句<span class=\"number\">2</span></span><br><span class=\"line\">    ……</span><br><span class=\"line\">  <span class=\"keyword\">END</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span></span><br><span class=\"line\">  <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    语句<span class=\"number\">1</span></span><br><span class=\"line\">    语句<span class=\"number\">2</span></span><br><span class=\"line\">    ……</span><br><span class=\"line\">  <span class=\"keyword\">END</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>允许嵌套</li>\n<li>如果<code>BEGIN……END</code>中间只有一行程序，则可以省略<code>BEGIN</code>与<code>ENDS</code></li>\n</ul>\n\n        <h4 id=\"IF-EXISTS\"   >\n          <a href=\"#IF-EXISTS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IF-EXISTS\" class=\"headerlink\" title=\"IF EXISTS\"></a>IF EXISTS</h4>\n      <p>存在数据时执行，加上<code>NOT</code>则相反：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">IF [<span class=\"keyword\">NOT</span>] <span class=\"keyword\">EXISTS</span> (<span class=\"keyword\">SELECT</span>查询语句)</span><br><span class=\"line\">  T<span class=\"operator\">-</span><span class=\"keyword\">SQL</span>语句<span class=\"operator\">|</span>语句块</span><br><span class=\"line\">[<span class=\"keyword\">ELSE</span>]</span><br><span class=\"line\">  T<span class=\"operator\">-</span><span class=\"keyword\">SQL</span>语句<span class=\"operator\">|</span>语句块</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"流程控制-CASE\"   >\n          <a href=\"#流程控制-CASE\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流程控制-CASE\" class=\"headerlink\" title=\"流程控制-CASE\"></a>流程控制-CASE</h3>\n      <ul>\n<li>简单型</li>\n<li>查找型</li>\n</ul>\n<p>前面记过了==、</p>\n\n        <h3 id=\"流程控制-WHILE\"   >\n          <a href=\"#流程控制-WHILE\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流程控制-WHILE\" class=\"headerlink\" title=\"流程控制-WHILE\"></a>流程控制-WHILE</h3>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">WHILE <span class=\"operator\">&lt;</span>布尔表达式<span class=\"operator\">&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">  <span class=\"operator\">&lt;</span>T<span class=\"operator\">-</span><span class=\"keyword\">SQL</span>语句<span class=\"operator\">|</span>语句块<span class=\"operator\">&gt;</span></span><br><span class=\"line\">  [BREAK]</span><br><span class=\"line\">  [CONTINUE]</span><br><span class=\"line\">  <span class=\"operator\">&lt;</span>T<span class=\"operator\">-</span><span class=\"keyword\">SQL</span>语句<span class=\"operator\">|</span>语句块<span class=\"operator\">&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"存储过程概述\"   >\n          <a href=\"#存储过程概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#存储过程概述\" class=\"headerlink\" title=\"存储过程概述\"></a>存储过程概述</h3>\n      <ul>\n<li><p>优点</p>\n<ul>\n<li>执行速度更快——在数据库中保存的存储过程收拾编译过的</li>\n<li>允许模块化程序设计——类的方法的复用</li>\n<li>提高系统安全性——防止SQL注入</li>\n<li>减少网络流量——只需传输存储过程的名称</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>增大了数据库压力</li>\n</ul>\n</li>\n<li><p>存储过程分类</p>\n<ul>\n<li>系统存储过程<ul>\n<li>由系统定义，存放在master数据库中</li>\n<li>系统存储过程的名称都以<code>sp_</code>开头或<code>xp_</code>开头</li>\n</ul>\n</li>\n<li>用户自定义存储过程<ul>\n<li>由用户在自己的数据库中创建的存储过程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>常用系统存储过程</p>\n<ul>\n<li>sp_databases<ul>\n<li>列出服务器上的所有数据库</li>\n</ul>\n</li>\n<li>sp_helpdb<ul>\n<li>报告有关指定数据库或所有数据库的信息</li>\n</ul>\n</li>\n<li>sp_renamedb<ul>\n<li>更改数据库的名称</li>\n</ul>\n</li>\n<li>sp_rename<ul>\n<li>更改数据库的名称</li>\n</ul>\n</li>\n<li>sp_tables<ul>\n<li>返回当前环境下课查询的对象的列表</li>\n</ul>\n</li>\n<li>sp_columns<ul>\n<li>返回某个列的信息</li>\n</ul>\n</li>\n<li>sp_help<ul>\n<li>查看某个表的所有信息</li>\n</ul>\n</li>\n<li>sp_helpconstraint<ul>\n<li>查看某个表的约束</li>\n</ul>\n</li>\n<li>sp_helpindex<ul>\n<li>查看某个表的索引</li>\n</ul>\n</li>\n<li>sp_stored_procedures<ul>\n<li>列出当前环境中的所有存储过程</li>\n</ul>\n</li>\n<li>sp_passwd<ul>\n<li>添加或修改登录账户的密码</li>\n</ul>\n</li>\n<li>sp_helptext<ul>\n<li>显示默认值、未加密的存储过程、用户定义的存储过程、触发器或视图的实际文本</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>举个栗子：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> sp_help student</span><br><span class=\"line\"><span class=\"comment\">--查看某个表的所有信息</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"存储过程的创建和执行方法\"   >\n          <a href=\"#存储过程的创建和执行方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#存储过程的创建和执行方法\" class=\"headerlink\" title=\"存储过程的创建和执行方法\"></a>存储过程的创建和执行方法</h3>\n      \n        <h4 id=\"创建存储过程语法\"   >\n          <a href=\"#创建存储过程语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创建存储过程语法\" class=\"headerlink\" title=\"创建存储过程语法\"></a>创建存储过程语法</h4>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> PROC <span class=\"operator\">|</span> <span class=\"keyword\">PROCEDURE</span> 存储过程名</span><br><span class=\"line\">[@参数名 数据类型 [<span class=\"operator\">=</span><span class=\"keyword\">default</span>] [OUTPUT]] [,……]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> ENCRYPTION]</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">  <span class=\"operator\">&lt;</span><span class=\"keyword\">SQL</span>语句<span class=\"operator\">&gt;</span>[,……]</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>参数分为输入参数、输出参数两种，OUTPUT指示参数是输出参数</li>\n<li>输入参数允许有默认值，DEFAULT设置参数的默认值</li>\n<li><code>ENCRYPTION</code>：将<code>CREATE PROCEDURE</code>语句的原始文本加密</li>\n<li>AS：指明该存储过程将要执行的动作</li>\n</ul>\n\n        <h4 id=\"执行存储过程\"   >\n          <a href=\"#执行存储过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#执行存储过程\" class=\"headerlink\" title=\"执行存储过程\"></a>执行存储过程</h4>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> 存储过程名 [参数<span class=\"number\">1</span>] [,参数<span class=\"number\">2</span>] [,……]</span><br></pre></td></tr></table></div></figure>\n\n<p>带有默认值的存储过程同C++语法</p>\n<ul>\n<li>带有输出参数的存储过程<ul>\n<li><code>EXEC 存储过程名 变量名 OUTPUT</code></li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"第五课\"   >\n          <a href=\"#第五课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第五课\" class=\"headerlink\" title=\"第五课\"></a>第五课</h1>\n      <blockquote>\n<p>放假休息</p>\n</blockquote>\n\n        <h1 id=\"第六课\"   >\n          <a href=\"#第六课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第六课\" class=\"headerlink\" title=\"第六课\"></a>第六课</h1>\n      \n        <h2 id=\"复习\"   >\n          <a href=\"#复习\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#复习\" class=\"headerlink\" title=\"复习\"></a>复习</h2>\n      \n        <h3 id=\"带有EXISTS谓词的子查询\"   >\n          <a href=\"#带有EXISTS谓词的子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#带有EXISTS谓词的子查询\" class=\"headerlink\" title=\"带有EXISTS谓词的子查询\"></a>带有EXISTS谓词的子查询</h3>\n      <p>查询所有选修了Dp010001号课的学生姓名</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> StudentName</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Student</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span>(</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> GRADE</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> Student.StudentID <span class=\"operator\">=</span> Grade.StudentID</span><br><span class=\"line\">  <span class=\"keyword\">AND</span> CourseID <span class=\"operator\">=</span> <span class=\"string\">&#x27;Dp010001&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"数据类型\"   >\n          <a href=\"#数据类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2>\n      <ul>\n<li><p>char类型指定了长度不够会自动补全</p>\n</li>\n<li><p>varchar类型指定了长度不够会释放内存</p>\n</li>\n<li><p>date</p>\n<ul>\n<li>日期</li>\n</ul>\n</li>\n<li><p>time</p>\n<ul>\n<li>时间</li>\n</ul>\n</li>\n<li><p>datetime</p>\n<ul>\n<li>日期和时间</li>\n</ul>\n</li>\n<li><p>unique允许一行为null</p>\n</li>\n</ul>\n\n        <h2 id=\"网课-4\"   >\n          <a href=\"#网课-4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课-4\" class=\"headerlink\" title=\"网课\"></a>网课</h2>\n      \n        <h3 id=\"自定义函数-标量函数\"   >\n          <a href=\"#自定义函数-标量函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#自定义函数-标量函数\" class=\"headerlink\" title=\"自定义函数-标量函数\"></a>自定义函数-标量函数</h3>\n      <ul>\n<li>内置系统函数<ul>\n<li>聚合函数</li>\n<li>日期和时间函数</li>\n<li>数学函数</li>\n<li>字符串函数</li>\n</ul>\n</li>\n<li>用户自定义函数<ul>\n<li>标量函数<ul>\n<li>返回的是一个单值，可以在select和where子句进行函数调用</li>\n</ul>\n</li>\n<li>表值函数<ul>\n<li>返回table数据类型，只能在select子句的from子句中调用</li>\n<li>内嵌表值函数</li>\n<li>多语句表值函数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"标量函数创建的语法\"   >\n          <a href=\"#标量函数创建的语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#标量函数创建的语法\" class=\"headerlink\" title=\"标量函数创建的语法\"></a>标量函数创建的语法</h4>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> 函数名</span><br><span class=\"line\">  (@参数名 参数数据类型[<span class=\"operator\">=</span><span class=\"keyword\">default</span>][,……n])</span><br><span class=\"line\">  <span class=\"keyword\">RETURNS</span> 返回值数据类型</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\">  <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    T<span class=\"operator\">-</span><span class=\"keyword\">SQL</span>语句</span><br><span class=\"line\">    <span class=\"keyword\">RETURN</span> 表达式</span><br><span class=\"line\">  <span class=\"keyword\">END</span></span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li>只能是输入参数，不能有输出参数，所有的输入参数前都必须加<code>@</code></li>\n<li><code>create</code>后的返回，单词是<code>returns</code>，而不是<code>return</code></li>\n<li><code>returns</code>后面跟的不是变量，而是返回值的类型，如：<code>int</code>,<code>char</code>等</li>\n<li>在<code>begin/end</code>语句块中，是<code>return</code></li>\n</ol>\n<ul>\n<li>创建函数<code>get_sname()</code>,通过学号返回姓名，并利用该函数查询选修成绩不及格学生的姓名。</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> get_sname(<span class=\"variable\">@stuNO</span> <span class=\"type\">char</span>(<span class=\"number\">12</span>))</span><br><span class=\"line\"><span class=\"keyword\">RETURNS</span> <span class=\"type\">char</span>(<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    <span class=\"keyword\">DECLARE</span> <span class=\"variable\">@sname</span> <span class=\"type\">char</span>(<span class=\"number\">8</span>)</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"variable\">@sname</span><span class=\"operator\">=</span>StudentName <span class=\"keyword\">from</span> student</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> StudentID<span class=\"operator\">=</span><span class=\"variable\">@stuNo</span></span><br><span class=\"line\">  <span class=\"keyword\">RETURN</span> <span class=\"variable\">@sname</span></span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--调用函数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> dbo.get_sname(StudentID) <span class=\"keyword\">AS</span> 姓名 <span class=\"keyword\">FROM</span> Grade <span class=\"keyword\">WHERE</span> Grade<span class=\"operator\">&lt;</span><span class=\"number\">60</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"创建内嵌表值函数\"   >\n          <a href=\"#创建内嵌表值函数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创建内嵌表值函数\" class=\"headerlink\" title=\"创建内嵌表值函数\"></a>创建内嵌表值函数</h4>\n      <ul>\n<li>内嵌表值函数创建的语法</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> 函数名(@参数名 参数数据类型[,……n])</span><br><span class=\"line\"><span class=\"keyword\">RETURNS</span> <span class=\"keyword\">TABLE</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\">  <span class=\"keyword\">RETURN</span>(T<span class=\"operator\">-</span><span class=\"keyword\">SQL</span>语句)</span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li>只能返回<code>table</code>，所以<code>returns</code>后面一定是<code>TABLE</code></li>\n<li><code>AS</code>后没有<code>begin/end</code>，只有一个<code>return</code>语句来返回特定的记录。</li>\n</ol>\n<ul>\n<li>创建一个自定义内嵌表值函数<code>getStuInfo</code>，返回指定班级的学生的学号，姓名，性别，班级名称。</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> getStuInfo(<span class=\"variable\">@classNo</span> <span class=\"type\">CHAR</span>(<span class=\"number\">8</span>))</span><br><span class=\"line\"><span class=\"keyword\">RETURNS</span> <span class=\"keyword\">TABLE</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">RETURN</span>(<span class=\"keyword\">SELECT</span> StudentID,StudentName,Sex,ClassName</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> Student,Class</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> Class.ClassID<span class=\"operator\">=</span><span class=\"variable\">@classNo</span></span><br><span class=\"line\">  <span class=\"keyword\">AND</span> Student.ClassID<span class=\"operator\">=</span>Class.ClassID</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--调用方式</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> dbo.getStuInfo(<span class=\"string\">&#x27;Cs010902&#x27;</span>)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"触发器\"   >\n          <a href=\"#触发器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h3>\n      \n        <h4 id=\"触发器的概念\"   >\n          <a href=\"#触发器的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#触发器的概念\" class=\"headerlink\" title=\"触发器的概念\"></a>触发器的概念</h4>\n      <p>触发器是一段由对数据的更改操作引发的自动执行的代码。通常用于保证业务规则和数据完整性，其主要优点是用户可以用编程的方式来实现复杂的处理逻辑和业务规则，增强了数据完整性约束的功能。</p>\n<ul>\n<li><p>触发器的分类</p>\n<ul>\n<li>DML触发器<ul>\n<li>当数据库服务器中发生<strong>数据操作语言事件</strong>，如<code>INSERT``ALTER``UPDATE</code>等操作触发的触发器。</li>\n<li>后触发器 AFTER触发器<ul>\n<li>操作完成后再被激活执行触发器里的SQL语句</li>\n</ul>\n</li>\n<li>前触发器 INSTEAD OF触发器<ul>\n<li>对记录的操作进行之前就被激活，执行触发器中的SQL语句，而不再执行原来的SQL操作。</li>\n</ul>\n</li>\n<li>当触发器触发时，系统自动在内存中创建<code>deleted</code>表或<code>inserted</code>表，这两个表的结构同建立触发器的结构完全相同，这两张表是只读的，不允许修改，触发器执行完成后自动删除</li>\n</ul>\n</li>\n<li>DDL触发器<ul>\n<li>当数据库服务器中发生<strong>数据定义语言事件</strong>，如<code>CREATE``ALTER``DROP</code>等操作出发的触发器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建DML触发器</p>\n<ul>\n<li>触发器名称要符合命名规范，且必须唯一</li>\n<li>FOR和AFTER均表示后触发器，INSTEAD OF表示前触发器</li>\n<li>DELETE,INSERT和UPDATE表示引发触发器执行的操作，如果同时指定多个操作，各个操作用逗号分隔</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> 触发器名称</span><br><span class=\"line\"><span class=\"keyword\">ON</span> 表名</span><br><span class=\"line\">&#123;<span class=\"keyword\">FOR</span><span class=\"operator\">|</span>AFTER<span class=\"operator\">|</span>INSTEAD <span class=\"keyword\">OF</span>&#125;</span><br><span class=\"line\">&#123;[<span class=\"keyword\">DELETE</span>][,][<span class=\"keyword\">INSERT</span>][,][UPDATE]&#125;</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\">  <span class=\"keyword\">SQL</span>语句<span class=\"operator\">|</span>语句块</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"后触发器\"   >\n          <a href=\"#后触发器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#后触发器\" class=\"headerlink\" title=\"后触发器\"></a>后触发器</h4>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> tri_After</span><br><span class=\"line\"><span class=\"keyword\">ON</span> Class AFTER <span class=\"keyword\">INSERT</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Class</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> inserted</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>在Grade表上创建一个后触发器，当成绩字段修改或新数据插入后触发，检查分数是否在0-100之间。</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> tri_grade</span><br><span class=\"line\"><span class=\"keyword\">ON</span> Grade</span><br><span class=\"line\">AFTER <span class=\"keyword\">INSERT</span>, UPDATE</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\">  IF <span class=\"keyword\">EXISTS</span>(<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> inserted <span class=\"keyword\">WHERE</span> grade<span class=\"operator\">&lt;</span><span class=\"number\">0</span> <span class=\"keyword\">OR</span> grade<span class=\"operator\">&gt;</span><span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">  PRINT<span class=\"string\">&#x27;输入的分数应该在0-100之间，请确认输入的考试分数！&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">ROLLBACK</span></span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span></span><br><span class=\"line\">  PRINT<span class=\"string\">&#x27;修改成功！&#x27;</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"前触发器\"   >\n          <a href=\"#前触发器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#前触发器\" class=\"headerlink\" title=\"前触发器\"></a>前触发器</h4>\n      <p><code>INSTEAD OF</code>触发器是在对记录的操作进行之前就被激活，执行触发器中的SQL语句，而<strong>不再执行原来的SQL操作</strong>。</p>\n<ul>\n<li>在student表上创建一个前触发器，在录入学生信息时，限制班级人数不能超过10人。</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> tri_Instead2</span><br><span class=\"line\"><span class=\"keyword\">ON</span> student</span><br><span class=\"line\">INSTEAD <span class=\"keyword\">OF</span> <span class=\"keyword\">INSERT</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\">  <span class=\"keyword\">DECLARE</span> <span class=\"variable\">@classno</span> <span class=\"type\">char</span>(<span class=\"number\">8</span>)</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> <span class=\"variable\">@classno</span><span class=\"operator\">=</span>ClassID</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> inserted</span><br><span class=\"line\">  IF(<span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> STUDENT <span class=\"keyword\">WHERE</span> ClassID<span class=\"operator\">=</span><span class=\"variable\">@classno</span>)<span class=\"operator\">&lt;</span><span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> student <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> inserted</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Student <span class=\"keyword\">WHERE</span> ClassID<span class=\"operator\">=</span><span class=\"variable\">@classno</span></span><br><span class=\"line\">  <span class=\"keyword\">END</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span></span><br><span class=\"line\">  PRINT<span class=\"string\">&#x27;班级人数已满&#x27;</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"安全管理\"   >\n          <a href=\"#安全管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#安全管理\" class=\"headerlink\" title=\"安全管理\"></a>安全管理</h3>\n      <ol>\n<li>身份验证</li>\n<li>操作权控制</li>\n<li>文件操作控制</li>\n<li>加密存储与冗余</li>\n</ol>\n<ul>\n<li><p>登录账户来源</p>\n<ul>\n<li>Windows授权用户</li>\n<li>SQL Server授权用户</li>\n</ul>\n</li>\n<li><p>安全认证模式</p>\n<ul>\n<li>Windows身份验证模式</li>\n<li>混合身份验证模式</li>\n</ul>\n</li>\n<li><p>SQL Server登录账户</p>\n<ul>\n<li>SQL Server的安全权限是基于用户登录标识符的，没有有效的登录ID，用户无法连接数据库服务器</li>\n<li>SQL Server身份验证登录，默认的登录名是sa，拥有系统管理员权限</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--使用SQL语句创建登录账号</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> LOGIN SQL_USERNAME </span><br><span class=\"line\"><span class=\"keyword\">WITH</span> PASSWORD<span class=\"operator\">=</span><span class=\"string\">&#x27;XXXXXX&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">---删除登录账号</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> LOGIN login_name</span><br><span class=\"line\"><span class=\"comment\">--不能删除正在使用的登录用户，也不能删除拥有任何数据库和服务器级别对象的登录用户</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--为某一数据库创建用户</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> SQL_USERNAME</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--删除用户</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">USER</span> USER_NAME</span><br><span class=\"line\"><span class=\"comment\">--不能删除拥有对象的用户</span></span><br><span class=\"line\"><span class=\"comment\">--用户的删除，不影响登录账号的存在，反过来也一样</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>登录账户和数据库用户的关系</p>\n<ul>\n<li>一个登录账号可以映射为多个数据库用户，但一个登录名在每个数据库中只能映射一次</li>\n</ul>\n</li>\n<li><p>对象管理权限</p>\n<ul>\n<li>用户创建和管理数据库中表、视图等对象的权限</li>\n<li>CREATE DATABASE</li>\n<li>CREATE TABLE</li>\n<li>CREATE VIEW</li>\n<li>CREATE PROCEDURE</li>\n<li>BACKUP DATABASE</li>\n<li>BACKUP LOG</li>\n</ul>\n</li>\n<li><p>数据操作权限</p>\n<ul>\n<li>对数据库中表、视图中的数据进行查询、增加、删除和修改的权限</li>\n<li>INSERT</li>\n<li>DELETE</li>\n<li>UPDATE</li>\n<li>SELECT</li>\n<li>EXECUTE</li>\n</ul>\n</li>\n<li><p>隐含权限</p>\n<ul>\n<li>内置权限，不需要再明确地授予这些权限</li>\n</ul>\n</li>\n<li><p>权限的管理</p>\n<ul>\n<li>授予权限<ul>\n<li>授予用户或角色具有某种操作权</li>\n</ul>\n</li>\n<li>收回权限<ul>\n<li>收回(或撤销)曾经授予给用户或角色的权限</li>\n</ul>\n</li>\n<li>拒绝权限<ul>\n<li>拒绝某用户或角色具有某种操作权限。一旦拒绝了用户的某个权限，则用户从任何地方都不能获得该权限</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--授权语句</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> 权限名[,……]</span><br><span class=\"line\">  <span class=\"keyword\">TO</span>&#123;数据库用户名<span class=\"operator\">|</span>用户角色名&#125;[,……]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--收权语句</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> 权限名[,……]</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span>&#123;数据库用户名<span class=\"operator\">|</span>用户角色名&#125;[,……]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--拒绝语句</span></span><br><span class=\"line\">DENY 权限名[,……]</span><br><span class=\"line\">  <span class=\"keyword\">TO</span>&#123;数据库用户名<span class=\"operator\">|</span>用户角色名&#125;[,……]</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>角色<ul>\n<li>为便于对角色及权限的管理，可以将一组具有相同权限的用户组织在一起，这一组具有相同权限的用户就称为<strong>角色</strong>。</li>\n<li>3类<ul>\n<li>固定的服务器角色<ul>\n<li>bulkadmin<ul>\n<li>具有执行BULK,INSERT语句的权限</li>\n</ul>\n</li>\n<li>dbcreator<ul>\n<li>具有创建数据库的权限</li>\n</ul>\n</li>\n<li>diskadmin<ul>\n<li>具有管理磁盘资源的权限</li>\n</ul>\n</li>\n<li>processadmin<ul>\n<li>具有管理全部的连接以及服务器状态的权限</li>\n</ul>\n</li>\n<li>securityadmin<ul>\n<li>具有管理服务器登录账户的权限</li>\n</ul>\n</li>\n<li>serveradmin<ul>\n<li>具有全部配置服务器范围的设置</li>\n</ul>\n</li>\n<li>setupadmin<ul>\n<li>具有更改任何链接服务器的权限</li>\n</ul>\n</li>\n<li>sysadmin<ul>\n<li>系统管理员角色，具有服务器及数据库上的全部权限</li>\n</ul>\n</li>\n<li>public<ul>\n<li>每个登录账户自动拥有，不能对其进行授权</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>固定的数据库角色<ul>\n<li>db_accessadmin<ul>\n<li>具有添加或删除数据库用户的权限</li>\n</ul>\n</li>\n<li>db_backupoperator<ul>\n<li>具有备份数据库、日志的权限</li>\n</ul>\n</li>\n<li>db_datareader<ul>\n<li>具有查询数据库中所有用户表数据的权限</li>\n</ul>\n</li>\n<li>db_datawriter<ul>\n<li>具有更改数据库中所有用户表数据的权限</li>\n</ul>\n</li>\n<li>db_ddladmin<ul>\n<li>具有建立、修改和删除数据库对象的权限</li>\n</ul>\n</li>\n<li>db_denydatareader<ul>\n<li>不允许具有查询数据库中所有用户表数据的权限</li>\n</ul>\n</li>\n<li>db_denydatawriter<ul>\n<li>不允许具有更改数据库中所有用户表数据的权限</li>\n</ul>\n</li>\n<li>db_owner<ul>\n<li>具有数据库中的全部操作权限</li>\n</ul>\n</li>\n<li>db_securityadmin<ul>\n<li>具有管理数据库角色和角色成员以及数据库中的对象管理和数据操作的全部权限</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用户自定义的角色<ul>\n<li>用户自定义的角色属于数据库级别的角色</li>\n<li>用户的成员可以是数据库的角色，也可以是用户定义的角色</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--在固定的服务器角色中添加成员用系统存储过程sp_addsrvrolemember:</span></span><br><span class=\"line\">sp_addsrvrolemember 登录名,角色名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--在固定的服务器角色中删除成员用系统存储过程sp_dropsrvrolemember:</span></span><br><span class=\"line\">sp_dropsrvrolemember 登录名,角色名</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--创建新角色的语法</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> ROLE 新角色名 [<span class=\"keyword\">AUTHORIZATION</span>拥有者]</span><br><span class=\"line\"><span class=\"comment\">--新角色没有权限，要进行授权</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--删除</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> ROLE 名字</span><br><span class=\"line\"><span class=\"comment\">--不能删除拥有安全对象的角色</span></span><br><span class=\"line\"><span class=\"comment\">--不能从数据库中删除拥有成员的角色</span></span><br><span class=\"line\"><span class=\"comment\">--不能删除固定的数据库角色</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"网课-5\"   >\n          <a href=\"#网课-5\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课-5\" class=\"headerlink\" title=\"网课\"></a>网课</h2>\n      \n        <h3 id=\"备份和恢复数据库\"   >\n          <a href=\"#备份和恢复数据库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#备份和恢复数据库\" class=\"headerlink\" title=\"备份和恢复数据库\"></a>备份和恢复数据库</h3>\n      \n        <h4 id=\"数据故障\"   >\n          <a href=\"#数据故障\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据故障\" class=\"headerlink\" title=\"数据故障\"></a>数据故障</h4>\n      <ul>\n<li><p>系统故障</p>\n<ul>\n<li>造成系统停止运转的任何事件，是的系统要重新启动。</li>\n<li>特定类型的硬件错误(如CPU故障)</li>\n<li>操作系统故障</li>\n<li>数据库管理系统代码错误</li>\n<li>系统断电</li>\n</ul>\n</li>\n<li><p>事务故障</p>\n<ul>\n<li>某事物在未运行至正常终止点就夭折了，可以分为可预期的和不可预期的两类。<ul>\n<li>可预期的事物故障：取款余额不足，买票以售完等。</li>\n<li>非预期的事物故障：运算溢出、并发事物发生死锁等。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>介质故障</p>\n<ul>\n<li>磁盘损坏</li>\n<li>磁头碰撞</li>\n<li>瞬时强磁场干扰</li>\n<li>介质故障比前两类故障的可能性小得多，但破坏性大得多</li>\n</ul>\n</li>\n<li><p>故障影响</p>\n<ul>\n<li>数据库本身被破坏，需要通过备份的数据库还原数据库。</li>\n<li>数据库没有被破坏，但数据可能不正确，可以通过日志文件恢复。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"备份数据库\"   >\n          <a href=\"#备份数据库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#备份数据库\" class=\"headerlink\" title=\"备份数据库\"></a>备份数据库</h4>\n      <ul>\n<li><p>数据库的安全性和可靠性必不可少，为了保障数据库的正常运行，就必须做好数据库备份。</p>\n</li>\n<li><p>备份数据库就是将<strong>数据库中的数据</strong>和<strong>保证数据库系统正常运行的相关信息</strong>保存起来，以备系统出现问题时，恢复数据库时使用。</p>\n</li>\n<li><p>备份内容</p>\n<ul>\n<li>系统数据库</li>\n<li>用户数据库</li>\n</ul>\n</li>\n<li><p>备份时间</p>\n<ul>\n<li>系统数据库：变化频率低，修改之后备份</li>\n<li>用户数据库：周期性备份，备份周期由用户需求决定，时间点选在数据操作少的时候进行。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"备份策略\"   >\n          <a href=\"#备份策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#备份策略\" class=\"headerlink\" title=\"备份策略\"></a>备份策略</h4>\n      <ul>\n<li><p>备份策略</p>\n<ul>\n<li>备份策略的制定<ul>\n<li>确定备份类型</li>\n<li>频率</li>\n<li>备份所需硬件特征和速度</li>\n<li>备份的测试方法</li>\n<li>备份所存放的位置</li>\n</ul>\n</li>\n<li>考虑的因素<ul>\n<li>业务需求</li>\n<li>数据库特征</li>\n<li>对资源的约束</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>策略1：完整备份</p>\n<ul>\n<li>适合于数据库数据不是很大，而且数据更改不是很频繁地情况，会丢失部分数据。</li>\n</ul>\n</li>\n<li><p>策略2：完整备份+事务日志备份</p>\n<ul>\n<li>不希望经常地进行完成备份，则可以在完整备份中间加一些日志备份。</li>\n</ul>\n</li>\n<li><p>策略3：完整备份+差异备份+事务日志备份</p>\n<ul>\n<li>优点是备份和恢复的速度都比较快，而且当系统出现故障时，丢失的数据也比较少。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"SQL-Server的备份机制\"   >\n          <a href=\"#SQL-Server的备份机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#SQL-Server的备份机制\" class=\"headerlink\" title=\"SQL Server的备份机制\"></a>SQL Server的备份机制</h4>\n      <ul>\n<li><p>备份设备</p>\n</li>\n<li><p>恢复模式</p>\n</li>\n<li><p>备份类型</p>\n</li>\n<li><p>实现备份</p>\n</li>\n<li><p>备份设备</p>\n<ul>\n<li>SQL Server中备份数据库的场所被称为备份设备，逻辑备份设备是指数据库备份的逻辑名，物理备份设备是操作系统上数据文件。</li>\n<li>备份设备可以分为：<ul>\n<li><strong>永久备份设备</strong>需要在备份之前需要预先建立。</li>\n<li><strong>临时备份设备</strong>不需要预先建立，在备份时直接使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建备份设备</p>\n<ul>\n<li>创建备份设备可以使用系统存储过程<code>sp_addumpdevice</code>。<ul>\n<li>语法规则:<code>sp_addumpdevice 备份数倍类型,逻辑名,物理文件名</code></li>\n</ul>\n</li>\n<li>例如建立一个名为bk2的此版备份设备，物理存储位置以及文件名为：<code>D:\\dump\\bk.bak</code><ul>\n<li><code>sp_addumpdevice &#39;disk&#39;,&#39;bk2&#39;,&#39;D:\\dump\\bk2.bak&#39;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>恢复模式</p>\n<ul>\n<li>简单恢复<ul>\n<li>不备份事物日志</li>\n<li>丢失风险高</li>\n<li>适用于测试开发</li>\n</ul>\n</li>\n<li>完整恢复<ul>\n<li>完整记录事务</li>\n<li>可恢复到故障点</li>\n<li>适用于实际应用</li>\n</ul>\n</li>\n<li>大容量日志<ul>\n<li>记录大容量操作</li>\n<li>有一定风险</li>\n<li>作为完整恢复模式的附加模式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>备份类型</p>\n<ul>\n<li>数据库的恢复模式决定了可以使用的备份类型，数据库备份类型决定所备份的内容。</li>\n<li>SQL Server中的备份类型包括：<ul>\n<li>数据库备份(完整备份和差异备份)</li>\n<li>文件备份</li>\n<li>事务日志备份</li>\n</ul>\n</li>\n<li>文件备份可使用分离和附加数据库的功能</li>\n</ul>\n</li>\n<li><p>数据库备份</p>\n<ul>\n<li>完整备份<ul>\n<li>完整数据库备份是所有备份方法中最基本也是最重要的备份，也是差异备份的基准。</li>\n<li>备份数据库中的全部信息，包括数据文件、日志文件，文件存储的位置信息以及数据库全部对象。</li>\n<li>消耗较长时间和资源，但不影响用户使用。</li>\n</ul>\n</li>\n<li>差异备份<ul>\n<li>差异备份以前一次完整备份为基准点(差异基准)，备份从上次完整备份之后数据库的全部变化内容。</li>\n<li>差异备份通常速度快，耗时短，但较为复杂。差异备份的时间和大小取决于自建立差异基准后更改的数据量。通常，差异基准越旧，新的差异备份就越大。</li>\n</ul>\n</li>\n<li>事务日志备份<ul>\n<li>事务日志备份，不备份数据库本身，它只备份日志记录，而且只备份从上次备份之后到当前备份时间发生变化的日志内容。</li>\n<li>可将数据库恢复到故障点或特定的某个时间点。</li>\n<li>比完整备份和差异备份使用的资源少，但只能在完整恢复模式和大容量日志恢复模式下使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SQL语句备份数据库</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">BACKUP DATABASE 数据库名</span><br><span class=\"line\"><span class=\"keyword\">TO</span> 备份设备名[<span class=\"keyword\">WITH</span> [DIFFERENTIAL][[,]&#123;INIT<span class=\"operator\">|</span>NOINIT&#125;]]</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>DIFFERENTIAL:差异备份</p>\n</li>\n<li><p>INIT:本次备份将重写备份设备</p>\n</li>\n<li><p>NOINIT:本次备份将追加到备份设备。默认项</p>\n</li>\n<li><p>SQL语句备份事务日志</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">BACKUP LOG 数据库名 <span class=\"keyword\">TO</span>&#123;<span class=\"operator\">&lt;</span>备份设备名<span class=\"operator\">&gt;</span>&#125;</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> [&#123;INIT<span class=\"operator\">|</span>NOINIT&#125;],NORECOVERY][&#123;[,]NO_LOG<span class=\"operator\">|</span>TRUNCATE_ONLY<span class=\"operator\">|</span>NO_TRUNCATE&#125;]</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>NORECOVERY:尾部日志</li>\n<li>NO_LOG|TRUNCATE_ONLY:截断日志</li>\n<li>NO_TRUNCATE:不截断日志</li>\n</ul>\n\n        <h4 id=\"恢复数据库\"   >\n          <a href=\"#恢复数据库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#恢复数据库\" class=\"headerlink\" title=\"恢复数据库\"></a>恢复数据库</h4>\n      <ul>\n<li><p>如果数据库没有毁坏，则应先对数据库的访问进行一些必要的限制。因为<strong>在恢复数据库的过程中，不允许用户操作数据库</strong>。</p>\n</li>\n<li><p>如果数据库的日志文件没有损坏，则为尽可能减少数据丢失，<strong>可在恢复之前对数据库进行一次尾部日志备份</strong>。</p>\n</li>\n<li><p>恢复数据库的顺序</p>\n<ol>\n<li>最近的完整数据库备份</li>\n<li>最近的差异数据库备份</li>\n<li>按备份顺序还原日志</li>\n</ol>\n</li>\n<li><p>SQL语句恢复数据库</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">RESTORE DATABASE 数据库名</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> 备份设备名</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> FILE <span class=\"operator\">=</span> 文件号,NORECOVERY<span class=\"operator\">|</span>RECOVERY]</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>FILE = 文件号：标识要还原的备份，文件号为1标识备份设备上的第一个备份</p>\n</li>\n<li><p>NORECOVERY：表明对数据库的恢复还没有完成</p>\n</li>\n<li><p>RECOVERY：表明对数据库的恢复已经完成</p>\n</li>\n<li><p>SQL语句还原事务日志</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">RESTORE LOG 数据库名</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> 备份设备名</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> FILE <span class=\"operator\">=</span> 文件号,NORECOVERY<span class=\"operator\">|</span>RECOVERY]</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>参数含义和上面那个一样的</li>\n</ul>\n\n        <h2 id=\"网课第九单元\"   >\n          <a href=\"#网课第九单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课第九单元\" class=\"headerlink\" title=\"网课第九单元\"></a>网课第九单元</h2>\n      \n        <h3 id=\"9-1-数据模型\"   >\n          <a href=\"#9-1-数据模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-1-数据模型\" class=\"headerlink\" title=\"9.1 数据模型\"></a>9.1 数据模型</h3>\n      <ul>\n<li><p>实体</p>\n<ul>\n<li>实体名</li>\n<li>属性<ul>\n<li>取值不可为空的属性，强制的<code>*</code>标注</li>\n<li>取值可以为空的属性，可选的<code>o</code>标注</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实例</p>\n<ul>\n<li>实体中每个属性赋予具体的值，形成实例</li>\n</ul>\n</li>\n<li><p>唯一标识符(UID)</p>\n<ul>\n<li>对于所有实例，取值各不相同(唯一)的属性集，称为唯一标识符，用<code>#</code>标注</li>\n<li>每个实体有且仅有一个UID</li>\n<li>UID并非总是属性，也可为属性集</li>\n</ul>\n</li>\n<li><p>ER模型：</p>\n<ul>\n<li>描述世界的数据模型称为概念模型</li>\n<li>ER模型为最常用的概念模型</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"9-2-联系\"   >\n          <a href=\"#9-2-联系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-2-联系\" class=\"headerlink\" title=\"9.2 联系\"></a>9.2 联系</h3>\n      <ul>\n<li><p>联系</p>\n<ul>\n<li>实体与实体之间的关联，用联系来表示</li>\n<li>联系描述实体之间的对应关系</li>\n<li>一对一比较常见</li>\n<li>其实就是函数的映射关系</li>\n</ul>\n</li>\n<li><p>阅读规则</p>\n<ul>\n<li>每个</li>\n<li>实体A</li>\n<li>必须/可以(实体A一侧的线为实线/虚线)</li>\n<li>联系动词(实体A一侧的联系动词)</li>\n<li>一个或多个/一个且仅有一个(实体A对侧的线 鸡爪线/单线)</li>\n<li>实体B</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"9-3-多对多\"   >\n          <a href=\"#9-3-多对多\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-3-多对多\" class=\"headerlink\" title=\"9.3 多对多\"></a>9.3 多对多</h3>\n      \n        <h3 id=\"9-4-关系数据库的基本概念\"   >\n          <a href=\"#9-4-关系数据库的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-4-关系数据库的基本概念\" class=\"headerlink\" title=\"9.4 关系数据库的基本概念\"></a>9.4 关系数据库的基本概念</h3>\n      <ul>\n<li><p>笛卡尔积</p>\n</li>\n<li><p>关系</p>\n<ul>\n<li>就是二维表，满足如下性质：<ul>\n<li>关系表中的每一列都是不可再分的基本属性</li>\n<li>表中个属性不能重名</li>\n<li>表中的行、列次序并不重要</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>属性</p>\n<ul>\n<li>二维表中的每个列称为一个属性(或叫字段)</li>\n<li>每个属性有一个名字，称为<strong>属性名</strong>。</li>\n<li>二维表中对应某一列的值称为<strong>属性值</strong>。</li>\n</ul>\n</li>\n<li><p>二维表中列的个数称为关系的<strong>元数</strong>。如果一个二维表有n个列，则称其为<strong>n元关系</strong>。</p>\n</li>\n<li><p>关系数据库：对应于一个关系模型的所有关系的集合称为关系数据库。</p>\n</li>\n<li><p>候选码：如果一个属性或属性集的值能够唯一标识一个关系的元组而又不包含多余的属性，则称该属性或属性集为候选码</p>\n<ul>\n<li>候选码也称为候选键或候选关键字</li>\n<li>在一个关系上可以有多个候选码</li>\n</ul>\n</li>\n<li><p>主码</p>\n<ul>\n<li>当一个关系中有多个候选码时，可以从中选择一个作为主码</li>\n<li>每个关系只能有一个主码</li>\n<li>主码也称为逐渐或主关键字，用于唯一确定一个元组</li>\n<li>主码可以由一个属性组成，也可以由多个属性共同组成</li>\n</ul>\n</li>\n<li><p>主属性和非主属性</p>\n<ul>\n<li>包含在任一候选码中的属性称为主属性</li>\n<li>不包含在任一候选码中的属性称为非主属性</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"9-5-函数依赖\"   >\n          <a href=\"#9-5-函数依赖\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-5-函数依赖\" class=\"headerlink\" title=\"9.5 函数依赖\"></a>9.5 函数依赖</h3>\n      \n        <h3 id=\"9-6-关系规范化\"   >\n          <a href=\"#9-6-关系规范化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-6-关系规范化\" class=\"headerlink\" title=\"9.6 关系规范化\"></a>9.6 关系规范化</h3>\n      <ul>\n<li>数据冗余问题</li>\n<li>异常<ul>\n<li>更新异常(Update Anomalies)</li>\n<li>插入异常(Insert Anomalies)</li>\n<li>删除异常(Delete Anomalies)</li>\n</ul>\n</li>\n<li>关系规范化<ul>\n<li>规范化的程度，可以分为：<ul>\n<li>1NF</li>\n<li>2NF</li>\n<li>3NF</li>\n<li>BCNF,4NF,5NF</li>\n</ul>\n</li>\n<li>满足高阶范式的关系模式一定满足低阶范式<ul>\n<li>譬如满足3NF,则一定已经满足1NF及2NF</li>\n<li>范式越高，规范化程度越好</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"9-7-1NF和2NF\"   >\n          <a href=\"#9-7-1NF和2NF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-7-1NF和2NF\" class=\"headerlink\" title=\"9.7 1NF和2NF\"></a>9.7 1NF和2NF</h3>\n      \n        <h4 id=\"1NF\"   >\n          <a href=\"#1NF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1NF\" class=\"headerlink\" title=\"1NF\"></a>1NF</h4>\n      <p>定义：如果关系模式R中所有的属性都是基本属性，即每个属性都是不可再分的，则称R属于第一范式，简称1NF，记作R∈1NF</p>\n\n        <h4 id=\"2NF\"   >\n          <a href=\"#2NF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2NF\" class=\"headerlink\" title=\"2NF\"></a>2NF</h4>\n      <p>定义：如果关系模式R∈1NF，并且R中的每个非主属性都完全函数依赖于主码，则称R属于第二范式，简称2NF，记作R∈2NF</p>\n\n        <h3 id=\"9-3-3NF\"   >\n          <a href=\"#9-3-3NF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-3-3NF\" class=\"headerlink\" title=\"9.3 3NF\"></a>9.3 3NF</h3>\n      <ul>\n<li><p>如何使关系模式达到2NF，分解步骤共三步：</p>\n<ol>\n<li>将原关系模式主码属性集合的每一个子集作为主码分别构成相应的表。</li>\n<li>将完全依赖于这些主码的属性放置到相应的表中</li>\n<li>去掉只由原关系模式主码属性集的子集构成的表</li>\n</ol>\n</li>\n<li><p>定义：如果关系模式R∈2NF，非主属性之间不存在函数依赖，则称R属于第三范式，简称3NF，记作R∈3NF</p>\n</li>\n<li><p>如何使关系模式达到3NF，分解步骤共三步：</p>\n<ol>\n<li>对于不是候选码的每个决定因子，从表中删去依赖于它的所有属性。</li>\n<li>新建一个表，新标中包含该决定要因子以及原表中所有依赖于该决定因子的属性。</li>\n<li>将决定因子作为新表的主码。</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"网课第十单元\"   >\n          <a href=\"#网课第十单元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网课第十单元\" class=\"headerlink\" title=\"网课第十单元\"></a>网课第十单元</h2>\n      \n        <h3 id=\"10-1-事务与并发控制\"   >\n          <a href=\"#10-1-事务与并发控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#10-1-事务与并发控制\" class=\"headerlink\" title=\"10.1 事务与并发控制\"></a>10.1 事务与并发控制</h3>\n      <ul>\n<li><p>事务的特性(ACID)</p>\n<ul>\n<li>原子性<ul>\n<li>事务是一个完整的操作。事务的各步骤是不可分的；要么都执行，要么都不执行。</li>\n</ul>\n</li>\n<li>一致性<ul>\n<li>当事务完成时，数据必须处于一致状态。</li>\n</ul>\n</li>\n<li>隔离性<ul>\n<li>对数据进行修改的所有并发事物是彼此隔离的，这表明事物必须是独立的，它不应以任何方式依赖于或影响其他事务。</li>\n</ul>\n</li>\n<li>永久性<ul>\n<li>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>事务的分类</p>\n<ul>\n<li>显性事务<ul>\n<li>用BEGIN TRANSACTION(TRAN)明确指定事务的开始，这是<strong>最常用的事物类型</strong></li>\n</ul>\n</li>\n<li>隐性事务<ul>\n<li>通过设置SET IMPLICIT_TRANSACTIONS ON语句，可启动阴性事务模式。当某个事务完成时，再下一个T-SQL语句又将启动一个新事务，隐性事务模式下，自动形成事务链。</li>\n</ul>\n</li>\n<li>自动提交事务<ul>\n<li>这是SQLServer的默认模式，它将每条单独的T-SQL语句视为一个事务，如果成功执行，则自动提交；如果错误，则自动回滚。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>事务相关语句</p>\n<ul>\n<li>BEGIN Transaction<ul>\n<li>标记事务开始，只是显示事务中使用</li>\n</ul>\n</li>\n<li>COMMIT Transaction<ul>\n<li>事务已经成功执行，数据已经处理妥当</li>\n</ul>\n</li>\n<li>ROLLBACK Transaction<ul>\n<li>数据处理过程中出错，回滚到没有处理之前的数据状态，或回滚到事务内部的保存点。</li>\n</ul>\n</li>\n<li>SAVE Transaction<ul>\n<li>事务内部设置的保存点，就是事务可以不全部回滚，只回滚到这里。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>例子</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BEGIN</span> tran updateAccount</span><br><span class=\"line\">UPDATE bank <span class=\"keyword\">SET</span> Money <span class=\"operator\">=</span> Money<span class=\"number\">-1000</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\">SAVE tran before_update_2</span><br><span class=\"line\">UPDATE bank <span class=\"keyword\">SET</span> Money<span class=\"operator\">=</span>Money<span class=\"operator\">+</span><span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\">IF OK</span><br><span class=\"line\">  <span class=\"keyword\">COMMIT</span> tran updateAccount</span><br><span class=\"line\"><span class=\"keyword\">ELSE</span></span><br><span class=\"line\">  <span class=\"keyword\">ROLLBACK</span> tran updateAccount</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>丢失修改过程</p>\n<ul>\n<li>丢失修改是指事务1与事物2从数据库中读入同一数据并修改</li>\n<li>事务2的提交结果破坏了事务1提交的结果导致事务1的修改被丢失</li>\n</ul>\n</li>\n<li><p>读“脏”数据过程</p>\n<ul>\n<li>事务1修改某一数据，并将其写回磁盘</li>\n<li>事务2读取同一数据后，事务1由于某种原因被撤销，这是事务1已修改过的数据恢复原值</li>\n<li>事务2独到的数据就与数据库中的数据不一致，是不正确的数据，又称为“脏”数据</li>\n</ul>\n</li>\n<li><p>不可重复读过程</p>\n<ul>\n<li>事务1读取某一数据后<ul>\n<li>事务2对其做了修改，当事务1再次读取该数据时，得到与前一次不同的值。</li>\n<li>事务2删除了其中部分记录，当事务1再次读取数据时，发现某些记录神秘的消失了！</li>\n<li>事务2插入了一些记录，当事务1再次按相同条件读取数据时，发现多了一些记录。</li>\n</ul>\n</li>\n<li>后两种不可重复读有时也称为幻影现象。</li>\n</ul>\n</li>\n<li><p>并发控制措施</p>\n<ul>\n<li>当许多人试图同时修改数据库内的数据时，必须执行控制系统以使某个人所做的修改不会对其他人产生负面影响，这称为并发控制。</li>\n<li>封锁(加锁)是实现并发控制的主要技术。</li>\n</ul>\n</li>\n<li><p>封锁的定义</p>\n<ul>\n<li>事务T在堆某个数据对象(例如表、记录等)操作之前，先向系统发出请求，对其加锁。加锁后，事务T对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。</li>\n<li>一个事务对某个数据对象加锁后究竟拥有什么样的控制是由锁的类型决定的。</li>\n</ul>\n</li>\n<li><p>封锁的类型</p>\n<ul>\n<li>基本封锁类型有两种<ul>\n<li>排它锁(简记为x锁、写锁)<ul>\n<li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，知道T释放A上的锁。</li>\n</ul>\n</li>\n<li>共享锁(简记类s锁、读锁)<ul>\n<li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>封锁协议</p>\n<ul>\n<li>在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则称为封锁协议<ul>\n<li>何时申请X锁或S锁</li>\n<li>持锁时间</li>\n<li>何时释放</li>\n</ul>\n</li>\n<li>对封锁方式规定不同的规则，就形成了各种不同的封锁协议<ul>\n<li>一级封锁协议<ul>\n<li>事务T在修改数据R之前不许先对其加X锁</li>\n<li>可防止丢失修改，不能保证可重复读和不读“脏”数据。</li>\n</ul>\n</li>\n<li>二级封锁协议<ul>\n<li>事务T对要修改数据必须先加X锁，知道事务结束才释放X锁；</li>\n<li>事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁</li>\n<li>防止丢失修改和读“脏”数据，不能保证可重复读。</li>\n</ul>\n</li>\n<li>三级封锁协议<ul>\n<li>事务T在读取数据R之前必须先对其加S锁，在修改数据之前必须先加上X锁，知道事务结束才释放所有锁。</li>\n<li>防止丢失修改、读脏数据和不可重复读。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>活锁是一种<strong>某个事务长期等待</strong>的现象</p>\n</li>\n<li><p>死锁是<strong>两个或两个以上</strong>的事务之间的<strong>循环等待</strong></p>\n</li>\n<li><p>解决活锁——先来先服务</p>\n<ul>\n<li>当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对这些事务排队。该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁</li>\n</ul>\n</li>\n<li><p>解决死锁的方法</p>\n<ul>\n<li>预防死锁发生<ul>\n<li>一次封锁法<ul>\n<li>要求每个事务必须一次将所有要使用的数据<strong>全部加锁</strong>，否则就不能继续执行；问题在于<strong>降低并发度</strong>。</li>\n</ul>\n</li>\n<li>顺序封锁法<ul>\n<li>预先对数据对象规定一个封锁顺序，<strong>所有事务都按这个顺序实行封锁</strong>。存在的问题<strong>难于实现</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>允许发生，定期诊断，所有死锁则解锁<ul>\n<li>超时法<ul>\n<li>每个事务设定一个等待时限，如果等待时间超过了规定的时限，就认为发生了死锁。</li>\n<li>优点：实现简单</li>\n<li>缺点：有可能误判死锁</li>\n</ul>\n</li>\n<li>等待图法<ul>\n<li>周期性地检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>死锁的解除</p>\n<ul>\n<li>选择一个或多个处于死锁状态的事务将其撤销，释放它们持有的锁，使其它事务能继续运行下去。</li>\n<li>被撤销的事务对数据的修改必须加以恢复。</li>\n<li>为了降低处理死锁的代价，通常选取处理死锁代价最小的事务。</li>\n</ul>\n</li>\n<li><p>可串行化调度</p>\n<ul>\n<li>多个事务的并行执行是正确的，当且仅当其结果与<strong>按某一次序串行地执行</strong>它们时的<strong>结果相同</strong>，称这种调度策略为可串行化的调度。</li>\n<li>可串行化是并发事物正确调度的准则。</li>\n</ul>\n</li>\n<li><p>两端锁协议</p>\n<ul>\n<li>可串行性是并行调度正确性的唯一准则，两段锁(2PL)协议就是为保证并行调度可串行性而提供的封锁协议</li>\n<li>两段锁协议的要求所有事务必须分两个阶段对数据项加锁和解锁<ul>\n<li>在对任何数据进行读、写操作之前，事务首先要申请并获得对该数据的封锁。</li>\n<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>“两段”锁的含义事务分为两个阶段：</p>\n<ul>\n<li>第一阶段是获得封锁，也称为扩展阶段</li>\n<li>第二阶段是释放封锁，也称为收缩阶段</li>\n</ul>\n</li>\n<li><p>遵循两段锁协议是并发执行结果正确的充分条件而并非必要条件</p>\n</li>\n</ul>\n","categories":["课堂笔记"],"tags":["课堂笔记","数据库"]},{"title":"计算机网络随堂笔记","url":"/notebooks-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"\n        <h1 id=\"第1课-计算机网络与因特网\"   >\n          <a href=\"#第1课-计算机网络与因特网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第1课-计算机网络与因特网\" class=\"headerlink\" title=\"第1课 计算机网络与因特网\"></a>第1课 计算机网络与因特网</h1>\n      <p>计算机网络自20世纪60年代开始发展。这种被定义，随着年代逐渐发展被逐渐修正。</p>\n\n        <h2 id=\"计算机网络的定义\"   >\n          <a href=\"#计算机网络的定义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#计算机网络的定义\" class=\"headerlink\" title=\"计算机网络的定义\"></a>计算机网络的定义</h2>\n      <ul>\n<li><p>简单定义</p>\n<ul>\n<li>一些互相连接的、自治的计算机的集合。</li>\n</ul>\n</li>\n<li><p>文献定义</p>\n<ul>\n<li>计算机网络是通信设备和线路将分散在不同地点的有独立功能的多个计算机系统相互连接起来，并按照网络协议进行数据通信，实现资源共享的计算机集合。<ul>\n<li>多个计算机：为用户提供服务</li>\n<li>一个通信子网：通信设备和线路</li>\n<li>一系列协议：保证数据通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>网络类型</p>\n<ul>\n<li>很多：如局域网、广域网……</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"1-1-什么是因特网\"   >\n          <a href=\"#1-1-什么是因特网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-什么是因特网\" class=\"headerlink\" title=\"1.1 什么是因特网\"></a>1.1 什么是因特网</h2>\n      \n        <h3 id=\"1-1-1-互联网的基本构成\"   >\n          <a href=\"#1-1-1-互联网的基本构成\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-1-互联网的基本构成\" class=\"headerlink\" title=\"1.1.1 互联网的基本构成\"></a>1.1.1 互联网的基本构成</h3>\n      <p>螺母和螺栓的构成。</p>\n<ul>\n<li>设备<ul>\n<li>将所有的计算机连在一起运行程序。</li>\n</ul>\n</li>\n<li>Packet switches—分组交换机<ul>\n<li>路由器、交换机</li>\n</ul>\n</li>\n<li>Communication links—网络连接方式<ul>\n<li>fiber,copper,radio,satellite</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"1-1-2-互联网标准\"   >\n          <a href=\"#1-1-2-互联网标准\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-2-互联网标准\" class=\"headerlink\" title=\"1.1.2 互联网标准\"></a>1.1.2 互联网标准</h3>\n      <p>因特网标准：由IETF指定的<code>标准文档RFC</code></p>\n<ul>\n<li>RFC：请求评论</li>\n<li>IETF：因特网工程任务组</li>\n</ul>\n\n        <h3 id=\"1-1-3-协议\"   >\n          <a href=\"#1-1-3-协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-3-协议\" class=\"headerlink\" title=\"1.1.3 协议\"></a>1.1.3 协议</h3>\n      <ul>\n<li>TCP/IP</li>\n</ul>\n\n        <h3 id=\"1-1-4-网络边界\"   >\n          <a href=\"#1-1-4-网络边界\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-4-网络边界\" class=\"headerlink\" title=\"1.1.4 网络边界\"></a>1.1.4 网络边界</h3>\n      <p>边界都是端设备</p>\n<ul>\n<li>设备<ul>\n<li>PC</li>\n<li>服务器</li>\n<li>…… </li>\n</ul>\n</li>\n<li>接入方式<ul>\n<li>无线</li>\n<li>有线</li>\n<li>Wifi</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"1-1-4-1-网络核心的设备等\"   >\n          <a href=\"#1-1-4-1-网络核心的设备等\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-4-1-网络核心的设备等\" class=\"headerlink\" title=\"1.1.4.1 网络核心的设备等\"></a>1.1.4.1 网络核心的设备等</h4>\n      <ul>\n<li>设备<ul>\n<li>交换机</li>\n<li>路由器</li>\n</ul>\n</li>\n<li>接入方式<ul>\n<li>以太网</li>\n<li>DSL</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"1-1-4-2-传输链路\"   >\n          <a href=\"#1-1-4-2-传输链路\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-4-2-传输链路\" class=\"headerlink\" title=\"1.1.4.2 传输链路\"></a>1.1.4.2 传输链路</h4>\n      <ul>\n<li><p>Guided media</p>\n</li>\n<li><p>Unguiede media </p>\n<p>  全双工：能同时收发<br>  半双工：只能收或发</p>\n</li>\n</ul>\n\n        <h3 id=\"1-1-5-网络核心\"   >\n          <a href=\"#1-1-5-网络核心\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-5-网络核心\" class=\"headerlink\" title=\"1.1.5 网络核心\"></a>1.1.5 网络核心</h3>\n      <p>通过路由器和交换机将各种设备连接在一起，使其能够相互通信。</p>\n<ul>\n<li>路由器</li>\n<li>通信链路</li>\n<li>网络的网络  </li>\n</ul>\n\n        <h1 id=\"第2课\"   >\n          <a href=\"#第2课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第2课\" class=\"headerlink\" title=\"第2课\"></a>第2课</h1>\n      <p>胖AP、瘦AP</p>\n\n        <h3 id=\"交换技术\"   >\n          <a href=\"#交换技术\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#交换技术\" class=\"headerlink\" title=\"交换技术\"></a>交换技术</h3>\n      <ol>\n<li>电路交换：早期的电话线技术</li>\n<li>报文交换：添加源地址、目的地址等附加信息后发送。</li>\n<li>分组交换：将要发送的的数据分成若干小的<strong>块</strong>，<strong>添加首部形成分组</strong>，分别发送到目的端，再组装恢复成原数据。</li>\n</ol>\n<p>第一个分组交换网络：<code>ARPA网</code>，产生于20世纪70年代，是因特网的“最早祖先”。</p>\n\n        <h3 id=\"接入网络方式\"   >\n          <a href=\"#接入网络方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#接入网络方式\" class=\"headerlink\" title=\"接入网络方式\"></a>接入网络方式</h3>\n      \n        <h4 id=\"1-拨号调制解调器\"   >\n          <a href=\"#1-拨号调制解调器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-拨号调制解调器\" class=\"headerlink\" title=\"1. 拨号调制解调器\"></a>1. 拨号调制解调器</h4>\n      <p>将家庭端系统通过普通模拟点划线用拨号调制解调器与住宅ISP连接。</p>\n\n        <h4 id=\"2-HFC-电视光纤\"   >\n          <a href=\"#2-HFC-电视光纤\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-HFC-电视光纤\" class=\"headerlink\" title=\"2. HFC 电视光纤\"></a>2. HFC 电视光纤</h4>\n      <p>共享式的</p>\n\n        <h4 id=\"3-DSL\"   >\n          <a href=\"#3-DSL\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-DSL\" class=\"headerlink\" title=\"3. DSL\"></a>3. DSL</h4>\n      \n        <h4 id=\"4-ADSL\"   >\n          <a href=\"#4-ADSL\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-ADSL\" class=\"headerlink\" title=\"4. ADSL\"></a>4. ADSL</h4>\n      \n        <h3 id=\"以太网技术\"   >\n          <a href=\"#以太网技术\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#以太网技术\" class=\"headerlink\" title=\"以太网技术\"></a>以太网技术</h3>\n      <ul>\n<li>共享以太网：端系统共享以太网的传输速率</li>\n<li>交换以太网：多个用户可同时使用全部带宽通信</li>\n</ul>\n\n        <h3 id=\"无线局域网\"   >\n          <a href=\"#无线局域网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#无线局域网\" class=\"headerlink\" title=\"无线局域网\"></a>无线局域网</h3>\n      \n        <h3 id=\"广域无线接入网\"   >\n          <a href=\"#广域无线接入网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#广域无线接入网\" class=\"headerlink\" title=\"广域无线接入网\"></a>广域无线接入网</h3>\n      \n        <h3 id=\"物理媒体\"   >\n          <a href=\"#物理媒体\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#物理媒体\" class=\"headerlink\" title=\"物理媒体\"></a>物理媒体</h3>\n      \n        <h4 id=\"导引型的\"   >\n          <a href=\"#导引型的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#导引型的\" class=\"headerlink\" title=\"导引型的\"></a>导引型的</h4>\n      <ol>\n<li>双绞线<ul>\n<li>扭合度越高，抗干扰能力越好，网速越快。</li>\n</ul>\n<ol>\n<li>屏蔽双绞线</li>\n<li>非屏蔽双绞线</li>\n</ol>\n</li>\n<li>同轴电缆<ul>\n<li><code>内导体</code>传递数据</li>\n<li><code>外导体</code>用作地线及屏蔽干扰</li>\n<li>类型：<ul>\n<li>基带同轴电缆（50欧姆）<ul>\n<li>比特流直接向电缆发送，不需要调制。</li>\n</ul>\n</li>\n<li>宽带同轴电缆（75欧姆）<ul>\n<li>将数字信号调制成特定频段的模拟信号</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>光纤<ul>\n<li>双层结构</li>\n<li>传光原理：全反射，越细越好</li>\n<li>传输系统构成</li>\n<li>光纤类型</li>\n<li>光缆</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"无导引型的\"   >\n          <a href=\"#无导引型的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#无导引型的\" class=\"headerlink\" title=\"无导引型的\"></a>无导引型的</h4>\n      \n        <h1 id=\"第3课\"   >\n          <a href=\"#第3课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第3课\" class=\"headerlink\" title=\"第3课\"></a>第3课</h1>\n      \n        <h2 id=\"上节课的补充\"   >\n          <a href=\"#上节课的补充\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#上节课的补充\" class=\"headerlink\" title=\"上节课的补充\"></a>上节课的补充</h2>\n      \n        <h3 id=\"网线的种类\"   >\n          <a href=\"#网线的种类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网线的种类\" class=\"headerlink\" title=\"网线的种类\"></a>网线的种类</h3>\n      <ol>\n<li>直连线<ul>\n<li>终端之间的连接</li>\n</ul>\n</li>\n<li>交叉线<ul>\n<li>交换机与交换机之间的连接</li>\n</ul>\n</li>\n<li>控制线(console线)<ul>\n<li>交换机与服务器的配置</li>\n</ul>\n</li>\n</ol>\n<p>直连线和交叉线的标准已经自适应了，可以混用。</p>\n\n        <h2 id=\"网络核心\"   >\n          <a href=\"#网络核心\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h2>\n      \n        <h3 id=\"分组交换\"   >\n          <a href=\"#分组交换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h3>\n      <p>将报文拆分成较小的数据块(package)</p>\n\n        <h4 id=\"存储转发传输\"   >\n          <a href=\"#存储转发传输\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#存储转发传输\" class=\"headerlink\" title=\"存储转发传输\"></a>存储转发传输</h4>\n      <p>先存储在转发</p>\n<p>存储转发时延：将一个分组<strong>转发到输出链路</strong>上所需时间。若一个分组长Lbit，链路传输速率R，该时延是L/R s。</p>\n<p>输出缓存：用于保存准备发往某个链路的分组。每条相连的链路都对应有一个。</p>\n<p>排队时延：在缓存中排队等待转发。</p>\n<p>传播时延：信号在传输的过程中。</p>\n\n        <h3 id=\"分组交换网络\"   >\n          <a href=\"#分组交换网络\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分组交换网络\" class=\"headerlink\" title=\"分组交换网络\"></a>分组交换网络</h3>\n      <p>统计复用：按需分配资源。如A和B分组没有固定的顺序。<br>时分复用：按时间分配资源。</p>\n\n        <h3 id=\"电路交换\"   >\n          <a href=\"#电路交换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h3>\n      \n        <h3 id=\"三层ISP\"   >\n          <a href=\"#三层ISP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三层ISP\" class=\"headerlink\" title=\"三层ISP\"></a>三层ISP</h3>\n      <ol>\n<li>骨干ISP</li>\n<li>地区ISP</li>\n<li>本地ISP</li>\n<li>IXP</li>\n</ol>\n<p>4个时延</p>\n\n        <h1 id=\"第4课\"   >\n          <a href=\"#第4课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第4课\" class=\"headerlink\" title=\"第4课\"></a>第4课</h1>\n      \n        <h2 id=\"traceroute-tracert\"   >\n          <a href=\"#traceroute-tracert\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#traceroute-tracert\" class=\"headerlink\" title=\"traceroute/tracert\"></a>traceroute/tracert</h2>\n      <ul>\n<li>Linux：traceroute</li>\n<li>Windows：tracert</li>\n</ul>\n\n        <h2 id=\"分层后数据传递的过程\"   >\n          <a href=\"#分层后数据传递的过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分层后数据传递的过程\" class=\"headerlink\" title=\"分层后数据传递的过程\"></a>分层后数据传递的过程</h2>\n      <p>主机(端系统)间数据传送实际上并不是在对等层间直接进行，而是<strong>通过相邻层间的传递</strong>。</p>\n\n        <h2 id=\"因特网协议栈\"   >\n          <a href=\"#因特网协议栈\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#因特网协议栈\" class=\"headerlink\" title=\"因特网协议栈\"></a>因特网协议栈</h2>\n      <p>逻辑上的栈。</p>\n<p>物理层：比特(bit)<br>链路层：帧(frame)<br>网络层：数据报(datagram)<br>运输层：报文段(segment)<br>应用层：报文(message)</p>\n<p>IP Over Everything!</p>\n<p>Everything Over IP!</p>\n\n        <h2 id=\"各层功能\"   >\n          <a href=\"#各层功能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#各层功能\" class=\"headerlink\" title=\"各层功能\"></a>各层功能</h2>\n      <ul>\n<li>应用层：提供各种网络应用。传输应用<strong>报文</strong>。<ul>\n<li>FTP、SMTP、HTTP</li>\n</ul>\n</li>\n<li>运输层：在应用程序的客户机和服务器之间提供传输应用层报文服务。传输<strong>报文段</strong>。<ul>\n<li>TCP、UDP</li>\n</ul>\n</li>\n<li>网络层：主机和主机之间传输网络层分组。<strong>数据报</strong>。<ul>\n<li>IP协议、选路协议</li>\n</ul>\n</li>\n<li>链路层：在邻近单元之间传输数据<strong>帧</strong>。<ul>\n<li>PPP、以太网</li>\n</ul>\n</li>\n<li>物理层：在结点之间传输<strong>比特流</strong>。<ul>\n<li>传输媒体</li>\n</ul>\n</li>\n</ul>\n<p>物理层关注的是比特本身。</p>\n<p>OSI的传输层功能：流量控制、差错检测、数据分段。</p>\n<p>OSI的会话层功能：管理会话，建立、维持、切断连接。</p>\n\n        <h2 id=\"节点分层\"   >\n          <a href=\"#节点分层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#节点分层\" class=\"headerlink\" title=\"节点分层\"></a>节点分层</h2>\n      <ul>\n<li>路由器：实现第一层到第三层，能够实现IP协议。</li>\n<li>链路交换机：实现第一层和第二层，能够识别第二层地址，如以太网地址。</li>\n<li>主机：实现所有5个层次。</li>\n</ul>\n\n        <h1 id=\"第5课\"   >\n          <a href=\"#第5课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第5课\" class=\"headerlink\" title=\"第5课\"></a>第5课</h1>\n      \n        <h2 id=\"网络安全\"   >\n          <a href=\"#网络安全\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网络安全\" class=\"headerlink\" title=\"网络安全\"></a>网络安全</h2>\n      <p>安全策略、规章制度</p>\n<p>哪些是安全的，哪些是不必要的</p>\n<p>没有绝对安全的系统</p>\n<p>防火墙、入侵检测(IDS)、入侵防御系统(IPS)</p>\n\n        <h2 id=\"就业\"   >\n          <a href=\"#就业\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#就业\" class=\"headerlink\" title=\"就业\"></a>就业</h2>\n      <p>做大数据的难点：</p>\n<ul>\n<li>数据来源</li>\n<li>算法这东西靠他妈天分</li>\n</ul>\n\n        <h1 id=\"第6课\"   >\n          <a href=\"#第6课\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第6课\" class=\"headerlink\" title=\"第6课\"></a>第6课</h1>\n      \n        <h2 id=\"应用层\"   >\n          <a href=\"#应用层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2>\n      <p>网络应用是计算机网络的重要功能之一。</p>\n<ul>\n<li>主要内容：<ul>\n<li>应用层概念：应用层协议、和主机与服务器、进程、套接字和运输层接口</li>\n<li>应用程序：</li>\n<li>套接字编程：</li>\n</ul>\n</li>\n</ul>\n<p>写出能够分别<strong>在不同端系统运行，并通过网络相互通信</strong>的程序。</p>\n<p>应用程序软件只在端系统运行，不需要再网络核心设备上运行。</p>\n<ul>\n<li><p>三种类型</p>\n<ul>\n<li>C/S</li>\n<li>P2P</li>\n<li>C/S &amp; P2P</li>\n</ul>\n</li>\n<li><p>服务器：</p>\n<ul>\n<li>总是打开</li>\n<li>为多个客户机请求提供服务</li>\n<li>永久的IP地址</li>\n<li>可扩展为服务器场</li>\n</ul>\n</li>\n<li><p>客户机：</p>\n<ul>\n<li>总是打开或间歇打开</li>\n<li>向服务器发出请求</li>\n<li>具有动态地IP地址</li>\n<li>彼此之间不直接通信</li>\n</ul>\n</li>\n<li><p>P2P:</p>\n<ul>\n<li>无打开的服务器</li>\n<li>任意端系统可以直接通信</li>\n<li>对等方间歇的连接</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"进程通信\"   >\n          <a href=\"#进程通信\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3>\n      <p>进程：在主机上运行的程序</p>\n<ul>\n<li>进程通信：<ul>\n<li>同一主机中两个进程间的通信：由操作系统控制；</li>\n<li>不同主机中进程间的通信：通过网络交换<strong>报文</strong>进行。<ul>\n<li>发送进程：产生报文并向网络发送</li>\n<li>接收进程：接收报文，并回送报文</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"客户机和服务器进程\"   >\n          <a href=\"#客户机和服务器进程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#客户机和服务器进程\" class=\"headerlink\" title=\"客户机和服务器进程\"></a>客户机和服务器进程</h3>\n      <ul>\n<li>网络应用程序由<strong>成对的进程组成</strong>，并通过网络相互发送报文</li>\n</ul>\n\n        <h3 id=\"套接字socket\"   >\n          <a href=\"#套接字socket\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#套接字socket\" class=\"headerlink\" title=\"套接字socket\"></a>套接字socket</h3>\n      <p>套接字：同一台主机内应用层与传输层之间的接口。</p>\n<p>进程类似房子，套接字是进程的门</p>\n<p>进程通过<strong>套接字</strong>在网络上发送和接收报文</p>\n\n        <h3 id=\"进程寻址\"   >\n          <a href=\"#进程寻址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程寻址\" class=\"headerlink\" title=\"进程寻址\"></a>进程寻址</h3>\n      <p>主机上的进程可以有多个</p>\n<p>网络中有多个主机，每个主机上有多个进程</p>\n<p>进程识别信息：表示那台主机上的哪一个进程</p>\n<ul>\n<li>主机名称或地址：网络中的哪一个主机</li>\n<li>进程的标识：主机中的哪一个进程</li>\n</ul>\n\n        <h3 id=\"应用程序需要什么样的运输服务\"   >\n          <a href=\"#应用程序需要什么样的运输服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#应用程序需要什么样的运输服务\" class=\"headerlink\" title=\"应用程序需要什么样的运输服务\"></a>应用程序需要什么样的运输服务</h3>\n      <ul>\n<li>可靠的数据传输</li>\n<li>带宽</li>\n<li>定时</li>\n<li>安全性</li>\n</ul>\n\n        <h3 id=\"TCP\"   >\n          <a href=\"#TCP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3>\n      <ul>\n<li>流量控制</li>\n<li>拥塞控制</li>\n<li>未提供的服务：<ul>\n<li>发送进程受拥塞控制机制制约</li>\n</ul>\n</li>\n<li>不提供时延保证<ul>\n<li>数据传输的时间不确定</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"UDP\"   >\n          <a href=\"#UDP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3>\n      <ul>\n<li>无连接</li>\n<li>不可靠数据传输</li>\n<li>没有拥塞控制机制</li>\n<li>没有时延保证</li>\n</ul>\n\n        <h3 id=\"应用层协议\"   >\n          <a href=\"#应用层协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h3>\n      <p>定义了运行在不同端系统上的应用程序<strong>进程间传递报文的格式和方式</strong>。</p>\n<ul>\n<li>交换的报文类型：如请求报文和响应报文</li>\n<li>各种报文类型的语法：报文中的各个字段及描述</li>\n<li>字段的含义：字段包含信息的含义</li>\n<li>进程何时、如何发送报文及对报文进行响应的规则。</li>\n</ul>\n\n        <h1 id=\"第5课-1\"   >\n          <a href=\"#第5课-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第5课-1\" class=\"headerlink\" title=\"第5课\"></a>第5课</h1>\n      <p>Web和HTTP，没什么值得记的</p>\n\n        <h1 id=\"第6课-1\"   >\n          <a href=\"#第6课-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第6课-1\" class=\"headerlink\" title=\"第6课\"></a>第6课</h1>\n      <ol>\n<li>套接字(socket)</li>\n</ol>\n<p>同一台主机内<strong>应用层与传输层</strong>之间的接口。</p>\n<p>也叫应用程序和网络之间的<strong>应用程序接口API</strong>，是在网络上建立网络应用程序的<strong>可编程接口</strong>。</p>\n\n        <h2 id=\"请求一个HTML文件所需时间\"   >\n          <a href=\"#请求一个HTML文件所需时间\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求一个HTML文件所需时间\" class=\"headerlink\" title=\"请求一个HTML文件所需时间\"></a>请求一个HTML文件所需时间</h2>\n      <p>即<strong>从客户机请求基本HTML文件开始，到用户收到整个文件为止所花时间</strong>。</p>\n<ul>\n<li><p>往返时延RTT：</p>\n<ul>\n<li>一个分组从客户机到服务器，再回到客户机所花时间。</li>\n<li>包括传播时延、排队时延以及处理时延</li>\n</ul>\n</li>\n<li><p>TCP连接的总响应时间：两个RTT时延加上服务器发送文件的时间。</p>\n</li>\n</ul>\n<p>HTTP是无状态的的。</p>\n<p>FTP协议是有状态的。</p>\n\n        <h2 id=\"邮件服务器\"   >\n          <a href=\"#邮件服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#邮件服务器\" class=\"headerlink\" title=\"邮件服务器\"></a>邮件服务器</h2>\n      <p>POP3缺陷：用户读取邮件后，服务器不再保存。</p>\n<p>IMAP：删除前一直存在邮件服务器中</p>\n<ul>\n<li>编码：<ul>\n<li>正文：Quoted-printable</li>\n<li>附件：Base64</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"DNS提供的服务\"   >\n          <a href=\"#DNS提供的服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#DNS提供的服务\" class=\"headerlink\" title=\"DNS提供的服务\"></a>DNS提供的服务</h2>\n      <p>DNS协议运行在UDP之上，使用53号端口。</p>\n\n        <h3 id=\"DNS根名字服务器\"   >\n          <a href=\"#DNS根名字服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#DNS根名字服务器\" class=\"headerlink\" title=\"DNS根名字服务器\"></a>DNS根名字服务器</h3>\n      <ul>\n<li>当本地名字服务器不能分解名字时联系它</li>\n<li>根名字服务器：<ul>\n<li>如果名字映射未知，联系权威名字服务器</li>\n<li>获得映射</li>\n<li>返回对本地名字服务器的映射</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"顶级域和权威服务器\"   >\n          <a href=\"#顶级域和权威服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#顶级域和权威服务器\" class=\"headerlink\" title=\"顶级域和权威服务器\"></a>顶级域和权威服务器</h3>\n      \n        <h3 id=\"DNS-请求方式\"   >\n          <a href=\"#DNS-请求方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#DNS-请求方式\" class=\"headerlink\" title=\"DNS 请求方式\"></a>DNS 请求方式</h3>\n      <ul>\n<li>递归请求<ul>\n<li>由中间询问人接着询问，直至找到目的主机的IP</li>\n</ul>\n</li>\n<li>迭代请求<ul>\n<li>询问后返回其他DNS服务器地址。</li>\n</ul>\n</li>\n</ul>\n<p>本地DNS啊服务器-&gt;根DNS服务器-&gt;TLD DNS服务器-&gt;权威DNS服务器</p>\n\n        <h3 id=\"DNS记录和报文\"   >\n          <a href=\"#DNS记录和报文\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#DNS记录和报文\" class=\"headerlink\" title=\"DNS记录和报文\"></a>DNS记录和报文</h3>\n      <ul>\n<li>A</li>\n<li>CNAME</li>\n<li>NS<ul>\n<li>权威名字服务器</li>\n</ul>\n</li>\n<li>MX</li>\n</ul>\n","categories":["课堂笔记"],"tags":["计算机网络","课堂笔记"]},{"title":"【计算机操作系统】2-1-进程与线程","url":"/Major-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","content":"\n        <h1 id=\"进程的定义、组成、组织方式、特征\"   >\n          <a href=\"#进程的定义、组成、组织方式、特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的定义、组成、组织方式、特征\" class=\"headerlink\" title=\"进程的定义、组成、组织方式、特征\"></a>进程的定义、组成、组织方式、特征</h1>\n      <ul>\n<li>定义<ul>\n<li>在计算机发展史上，“进程”是为了解决什么问题而被引入的？</li>\n</ul>\n</li>\n<li>组成<ul>\n<li>每个进程由哪些部分组成？</li>\n</ul>\n</li>\n<li>组织特征<ul>\n<li>系统中各个进程之间是如何被组织起来的？</li>\n</ul>\n</li>\n<li>特征<ul>\n<li>相比于程序，进程有哪些特征？</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"进程的定义\"   >\n          <a href=\"#进程的定义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的定义\" class=\"headerlink\" title=\"进程的定义\"></a>进程的定义</h2>\n      <p>程序：就是一个指令序列</p>\n<p>引入了多道程序技术之后，为了方便操作系统管理，完成各程序并发执行，引入了<strong>进程、进程实体</strong>的概念。</p>\n<p>内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找到各程序的存放位置呢？</p>\n<p>系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息(如程序代码存放位置)</p>\n<p>PCB、程序段、数据段三部分构成了<strong>进程实体(进程映像)</strong></p>\n<p><strong>程序段、数据段、PCB</strong>三部分组成了**进程实体(进程映像)**。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。</p>\n<p><strong>PCB是进程存在的唯一标志！！！唯一标志！！！</strong></p>\n<ul>\n<li>从不同的角度，进程可以由不同的定义，比较传统典型的定义有<ol>\n<li>进程是程序的一次<strong>执行过程</strong>。</li>\n<li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong>。</li>\n<li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，它是系统进行资源分配和调度的一个独立单位</li>\n</ol>\n</li>\n</ul>\n<p>引入进程实体的概念后，可把进程定义为：<strong>进程</strong>是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</p>\n<p>严格来说，进程实体和进程并不一样，进程实体是<strong>静态的</strong>，进程则是<strong>动态的</strong>。不过，除非题目专门考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“进程由程序段、数据段、PCB三部分组成”。</p>\n\n        <h2 id=\"进程的组成\"   >\n          <a href=\"#进程的组成\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的组成\" class=\"headerlink\" title=\"进程的组成\"></a>进程的组成</h2>\n      <p>进程(进程实体)由<strong>程序段、数据段、PCB</strong>三部分组成。都在内存中。</p>\n<ul>\n<li><p>PCB</p>\n<ul>\n<li>进程描述信息<ul>\n<li>进程标识符PID<ul>\n<li>当程序被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程(类似于身份证号)</li>\n</ul>\n</li>\n<li>用户标识符UID</li>\n</ul>\n</li>\n<li>进程控制和管理信息<ul>\n<li>进程当前状态</li>\n<li>进程优先级</li>\n</ul>\n</li>\n<li>资源分配清单<ul>\n<li>程序段指针</li>\n<li>数据段指针</li>\n<li>键盘</li>\n<li>鼠标</li>\n</ul>\n</li>\n<li>处理机相关信息<ul>\n<li>各种寄存器值<ul>\n<li>当进程切换时需要把当前进程的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>PCB</p>\n<ul>\n<li>进程标识符</li>\n<li>处理机状态</li>\n<li>进程调度信息</li>\n<li>进程控制信息</li>\n</ul>\n</li>\n<li><p>进程的组成</p>\n<ul>\n<li>PCB<ul>\n<li>进程描述信息</li>\n<li>进程控制和管理信息</li>\n<li>资源分配清单</li>\n<li>处理机相关信息</li>\n</ul>\n</li>\n<li>程序段<ul>\n<li>存放要执行的代码</li>\n</ul>\n</li>\n<li>数据段<ul>\n<li>存放程序运行过程中处理的各种数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"进程的组织\"   >\n          <a href=\"#进程的组织\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的组织\" class=\"headerlink\" title=\"进程的组织\"></a>进程的组织</h2>\n      <p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p>\n<p>进程的<strong>组成</strong>讨论的是一个<strong>进程内部</strong>由哪些部分构成的问题，而进程的<strong>组织</strong>讨论的是<strong>多个进程之间</strong>的组织方式问题。</p>\n<ul>\n<li>进程的组织方式<ul>\n<li>链接方式<ul>\n<li>按照进程状态将PCB分为多个队列</li>\n<li>操作系统持有指向各个队列的指针</li>\n</ul>\n</li>\n<li>索引方式<ul>\n<li>根据进程状态的不同，建立几张索引表</li>\n<li>操作系统持有指向各个索引表的指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"进程的特征\"   >\n          <a href=\"#进程的特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的特征\" class=\"headerlink\" title=\"进程的特征\"></a>进程的特征</h2>\n      <p>进程和程序是两个截然不同的概念，相比于程序，进程拥有以下特征</p>\n<ul>\n<li>进程的特征<ul>\n<li>动态性<ul>\n<li>进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>\n<li>动态性是进程最基本的特征</li>\n</ul>\n</li>\n<li>并发性<ul>\n<li>内存中有多个进程实体，各进程可并发执行</li>\n</ul>\n</li>\n<li>独立性<ul>\n<li>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>\n<li>进程是资源分配、接受调度的基本单位</li>\n</ul>\n</li>\n<li>异步性<ul>\n<li>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>\n<li>异步性会导致并发程序执行结果的不确定性。</li>\n</ul>\n</li>\n<li>结构性<ul>\n<li>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"进程的状态与转换\"   >\n          <a href=\"#进程的状态与转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的状态与转换\" class=\"headerlink\" title=\"进程的状态与转换\"></a>进程的状态与转换</h1>\n      <ul>\n<li>状态<ul>\n<li>运行状态</li>\n<li>就绪状态</li>\n<li>阻塞状态</li>\n<li>创建状态</li>\n<li>终止状态</li>\n</ul>\n</li>\n<li>进程状态间的转换<ul>\n<li>就绪态-&gt;运行态</li>\n<li>运行态-&gt;就绪态</li>\n<li>运行态-&gt;阻塞态</li>\n<li>阻塞态-&gt;就绪态</li>\n</ul>\n</li>\n</ul>\n<p>状态中的运行状态、就绪状态、阻塞状态是三种基本状态。</p>\n\n        <h2 id=\"进程的状态-三种基本状态\"   >\n          <a href=\"#进程的状态-三种基本状态\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的状态-三种基本状态\" class=\"headerlink\" title=\"进程的状态-三种基本状态\"></a>进程的状态-三种基本状态</h2>\n      <p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p>\n<ul>\n<li>三种基本状态<ul>\n<li>运行态<ul>\n<li>占有CPU，并在CPU上运行</li>\n<li>单核处理机环境下，每一时刻最多只有一个进程处于运行态。(双核环境下可以同时有两个进程处于运行态)</li>\n</ul>\n</li>\n<li>就绪态<ul>\n<li>已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li>\n<li>进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。</li>\n</ul>\n</li>\n<li>阻塞态<ul>\n<li>因等待某一事件而暂时不能运行</li>\n<li>等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"进程的状态—另外两种状态\"   >\n          <a href=\"#进程的状态—另外两种状态\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的状态—另外两种状态\" class=\"headerlink\" title=\"进程的状态—另外两种状态\"></a>进程的状态—另外两种状态</h2>\n      <ul>\n<li>创建态<ul>\n<li>进程正在被创建，操作系统为进程分配资源、初始化PCB</li>\n</ul>\n</li>\n<li>终止态<ul>\n<li>进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"进程状态的转换\"   >\n          <a href=\"#进程状态的转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程状态的转换\" class=\"headerlink\" title=\"进程状态的转换\"></a>进程状态的转换</h2>\n      <p>这个不就是走正常流程么==、</p>\n<ul>\n<li>创建态-&gt;就绪态</li>\n<li>就绪态-&gt;运行态</li>\n<li>运行态-&gt;就绪态</li>\n<li>运行态-&gt;阻塞态</li>\n<li>阻塞态-&gt;就绪态</li>\n<li>运行态-&gt;终止态</li>\n</ul>\n\n        <h1 id=\"进程控制\"   >\n          <a href=\"#进程控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h1>\n      <ul>\n<li>基本概念<ul>\n<li>什么是进程控制？</li>\n<li>如何实现进程控制？<ul>\n<li>用“原语”实现</li>\n</ul>\n</li>\n<li>进程控制相关的原语<ul>\n<li>进程的创建</li>\n<li>进程的终止</li>\n<li>进程的阻塞</li>\n<li>进程的唤醒</li>\n<li>进程的切换</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"什么是进程控制？\"   >\n          <a href=\"#什么是进程控制？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是进程控制？\" class=\"headerlink\" title=\"什么是进程控制？\"></a>什么是进程控制？</h2>\n      <p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>\n<p>简化理解：反正进程控制就是要实现进程状态转换</p>\n\n        <h2 id=\"如何实现进程控制\"   >\n          <a href=\"#如何实现进程控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何实现进程控制\" class=\"headerlink\" title=\"如何实现进程控制\"></a>如何实现进程控制</h2>\n      <p>用<strong>原语</strong>实现进程控制。原语的<strong>特点</strong>是执行期间<strong>不允许中断</strong>，只能一气呵成。</p>\n<p>这种不可被中断的操作即<strong>原子操作</strong>。</p>\n<p>原语采用“<strong>关中断</strong>指令”和“<strong>开中断</strong>指令”实现。</p>\n<p><strong>原语运行在核心态！</strong></p>\n\n        <h2 id=\"进程控制相关的原语\"   >\n          <a href=\"#进程控制相关的原语\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程控制相关的原语\" class=\"headerlink\" title=\"进程控制相关的原语\"></a>进程控制相关的原语</h2>\n      <p>学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做到的无非三类事情：</p>\n<ol>\n<li>更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<ol>\n<li>所有的进程控制原语一定会修改进程状态标志</li>\n<li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>\n<li>某进程开始运行前必然要恢复运行环境</li>\n</ol>\n</li>\n<li>将PCB插入合适的队列</li>\n<li>分配/回收资源</li>\n</ol>\n<ul>\n<li><p>进程的创建</p>\n<ul>\n<li>创建原语<ul>\n<li>申请空白PCB</li>\n<li>为新进程分配所需资源</li>\n<li>初始化PCB</li>\n<li>将PCB插入就绪队列</li>\n</ul>\n</li>\n<li>引起进程创建的事件<ul>\n<li>用户登录<ul>\n<li>分时系统中，用户登录成功，系统会为其建立一个新的进程</li>\n</ul>\n</li>\n<li>作业调度<ul>\n<li>多批道处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>\n</ul>\n</li>\n<li>提供服务<ul>\n<li>用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的终止</p>\n<ul>\n<li>撤销原语<ul>\n<li>从PCB集合中找到终止进程的PCB</li>\n<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>\n<li>终止其所有子进程</li>\n<li>将该进程拥有的所有资源归还给父进程或操作系统</li>\n<li>删除PCB</li>\n</ul>\n</li>\n<li>引起进程终止的事件<ul>\n<li>正常结束</li>\n<li>异常结束</li>\n<li>外界干预</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的阻塞</p>\n<ul>\n<li>阻塞原语<ul>\n<li>找到要阻塞的进程对应的PCB</li>\n<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>\n<li>将PCB插入相应事件的等待队列</li>\n</ul>\n</li>\n<li>引起进程阻塞的事件<ul>\n<li>需要等待系统分配某种资源</li>\n<li>需要等待相互合作的其他进程完成工作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的唤醒</p>\n<ul>\n<li>唤醒原语<ul>\n<li>在事件等待队列中找到PCB</li>\n<li>将PCB从等待队列移除，设置进程为就绪态</li>\n<li>将PCB插入就绪队列，等待被调度</li>\n</ul>\n</li>\n<li>引起进程唤醒的事件<ul>\n<li>等待事件的发生</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的切换</p>\n<ul>\n<li>切换原语<ul>\n<li>将运行环境云溪存入PCB</li>\n<li>PCB移入相应队列</li>\n<li>选择另一个进程执行，并更新其PCB</li>\n<li>根据PCB恢复新进程所需的运行环境</li>\n</ul>\n</li>\n<li>引起进程切换的事件<ul>\n<li>当前进程时间片到</li>\n<li>有更高优先级的进程到达</li>\n<li>当前进程主动阻塞</li>\n<li>当前进程终止</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>阻塞和唤醒要成对出现</p>\n\n        <h1 id=\"进程通信\"   >\n          <a href=\"#进程通信\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h1>\n      <ul>\n<li>共享存储<ul>\n<li>基于数据结构的共享</li>\n<li>基于存储区的共享</li>\n</ul>\n</li>\n<li>消息传递<ul>\n<li>直接通信方式</li>\n<li>间接通信方式</li>\n</ul>\n</li>\n<li>管道通信</li>\n</ul>\n\n        <h2 id=\"什么是进程通信？\"   >\n          <a href=\"#什么是进程通信？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是进程通信？\" class=\"headerlink\" title=\"什么是进程通信？\"></a>什么是进程通信？</h2>\n      <p>顾名思义，进程通信就是指进程之间的信息交换。</p>\n<p>进程是分配系统资源的单位(包括内存地址空间)，因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p>\n<p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>\n\n        <h2 id=\"进程通信——共享存储\"   >\n          <a href=\"#进程通信——共享存储\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程通信——共享存储\" class=\"headerlink\" title=\"进程通信——共享存储\"></a>进程通信——共享存储</h2>\n      <p>两个进程对共享空间的<strong>访问</strong>必须是<strong>互斥</strong>的(互斥访问通过操作系统提供的工具实现)。</p>\n<p>操作系统只负责提供共享空间和同步互斥工具(如P、V操作)</p>\n<p><strong>基于数据结构</strong>的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式。</p>\n<p><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</p>\n\n        <h2 id=\"进程通信——管道通信\"   >\n          <a href=\"#进程通信——管道通信\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程通信——管道通信\" class=\"headerlink\" title=\"进程通信——管道通信\"></a>进程通信——管道通信</h2>\n      <p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p>\n<ol>\n<li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li>\n<li>各进程要<strong>互斥</strong>地访问管道。</li>\n<li>数据以字符流的形式写入管道，当<strong>管道写满</strong>时，<strong>写进程</strong>的write()系统调用将被<strong>阻塞</strong>，等待读进程将数据取走。当读进程将数据全部取走后，<strong>管道变空</strong>，此时<strong>读进程</strong>的read()系统调用将被<strong>阻塞</strong>。</li>\n<li>如果<strong>没写满，就不允许读</strong>。如果<strong>没读空，就不允许写</strong>。</li>\n<li>数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个</strong>，否则可能会有读错数据的情况。</li>\n</ol>\n\n        <h2 id=\"进程通信——消息传递\"   >\n          <a href=\"#进程通信——消息传递\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程通信——消息传递\" class=\"headerlink\" title=\"进程通信——消息传递\"></a>进程通信——消息传递</h2>\n      <p>进程间的数据交换以<strong>格式化的消息</strong>为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>\n<p>消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息(计算机网络中发送的“报文”其实就是一种格式化消息)</p>\n<ul>\n<li>消息传递<ul>\n<li>直接通信方式<ul>\n<li>消息直接挂到接收进程的消息缓冲队列上</li>\n</ul>\n</li>\n<li>间接通信方式<ul>\n<li>消息要先发送到中间实体(信箱)中，因此也称“信箱通信方式”。Eg:计网中的电子邮件系统</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"线程概念和多线程模型\"   >\n          <a href=\"#线程概念和多线程模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#线程概念和多线程模型\" class=\"headerlink\" title=\"线程概念和多线程模型\"></a>线程概念和多线程模型</h1>\n      <ul>\n<li>什么是线程，为什么要引入线程</li>\n<li>引入线程机制后，有什么变化</li>\n<li>线程有哪些重要的属性</li>\n<li>线程的实现方式<ul>\n<li>用户级线程</li>\n<li>内核级线程</li>\n</ul>\n</li>\n<li>多线程模型<ul>\n<li>多对一模型</li>\n<li>一对一模型</li>\n<li>多对多模型</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"什么是线程，为什么要引入线程？\"   >\n          <a href=\"#什么是线程，为什么要引入线程？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是线程，为什么要引入线程？\" class=\"headerlink\" title=\"什么是线程，为什么要引入线程？\"></a>什么是线程，为什么要引入线程？</h2>\n      <p>进程是程序的一次执行。但这些功能显然不可能是由一个程序书序处理就能实现的。</p>\n<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>\n<p>传统的进程是程序执行流的最小单位。</p>\n<p>引入了线程后，线程成为了程序执行流的最小单位。</p>\n<p>可以把线程理解为“轻量级进程”。</p>\n<p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</p>\n<p>引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间</strong>也可以<strong>并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务(如QQ视频、文字聊天、传文件)</p>\n<p>引入线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单位</strong>(如打印机、内存地址空间都是分配给进程的)。</p>\n\n        <h2 id=\"引入线程机制后，有什么变化？\"   >\n          <a href=\"#引入线程机制后，有什么变化？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#引入线程机制后，有什么变化？\" class=\"headerlink\" title=\"引入线程机制后，有什么变化？\"></a>引入线程机制后，有什么变化？</h2>\n      <ul>\n<li>资源分配、调度<ul>\n<li>传统进程机制中、进程是资源分配、调度的基本单位</li>\n<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位、</li>\n</ul>\n</li>\n<li>并发性<ul>\n<li>传统进程机制中，只能进程间并发。</li>\n<li>引入线程中，各线程间也能并发，提高了并发度。</li>\n</ul>\n</li>\n<li>系统开销<ul>\n<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大。</li>\n<li>进程间并发，如果是同一进程内的进程切换，则不需要切换环境，系统开销小。</li>\n<li>引入线程后，并发所带来的系统开销减小。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"线程的属性\"   >\n          <a href=\"#线程的属性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#线程的属性\" class=\"headerlink\" title=\"线程的属性\"></a>线程的属性</h2>\n      <ul>\n<li>线程是处理机调度的单位</li>\n<li>多CPU计算机中，各个线程可占用不同的CPU。</li>\n<li>每个线程都有一个线程ID、线程控制块(TCB)。</li>\n<li>线程也有就绪、阻塞、运行三种基本状态。</li>\n<li>线程几乎不拥有系统资源。</li>\n<li>同一进程的不同线程间共享进程的资源</li>\n<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干扰</li>\n<li>同一进程中的线程切换，不会引起进程切换</li>\n<li>不同进程中的线程切换，会引起进程切换</li>\n<li>切换同进程内的线程，系统开销很小</li>\n<li>切换进程，系统开销很大</li>\n</ul>\n\n        <h2 id=\"线程的实现方式\"   >\n          <a href=\"#线程的实现方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#线程的实现方式\" class=\"headerlink\" title=\"线程的实现方式\"></a>线程的实现方式</h2>\n      \n        <h3 id=\"用户级线程\"   >\n          <a href=\"#用户级线程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#用户级线程\" class=\"headerlink\" title=\"用户级线程\"></a>用户级线程</h3>\n      <p>用户级线程由应用程序通过线程库实现。</p>\n<p>所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>(包括线程切换)</p>\n<p>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统干预。</p>\n<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。(用户级线程对用户不透明，对操作系统透明)</p>\n<p>可以这样理解，<strong>“用户级线程”</strong>就是“从用户视角看能看到的线程”。</p>\n\n        <h3 id=\"内核级线程\"   >\n          <a href=\"#内核级线程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内核级线程\" class=\"headerlink\" title=\"内核级线程\"></a>内核级线程</h3>\n      <p>内核级<strong>线程的管理工作</strong>由<strong>操作系统内核</strong>完成。</p>\n<p>线程调度、切换等工作都由内个负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</p>\n<p>可以这样理解：内核级线程就是从操作系统内核视角看能看到的线程。</p>\n<p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上(n&gt;=m)</p>\n<p><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>\n\n        <h2 id=\"多线程模型\"   >\n          <a href=\"#多线程模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多线程模型\" class=\"headerlink\" title=\"多线程模型\"></a>多线程模型</h2>\n      <p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p>\n\n        <h3 id=\"多对一模型\"   >\n          <a href=\"#多对一模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多对一模型\" class=\"headerlink\" title=\"多对一模型\"></a>多对一模型</h3>\n      <p>多个用户及线程映射到一个内核级线程。每个用户进程值对应一个内核级线程。</p>\n<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p>\n<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p>\n\n        <h3 id=\"一对一模型\"   >\n          <a href=\"#一对一模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#一对一模型\" class=\"headerlink\" title=\"一对一模型\"></a>一对一模型</h3>\n      <p>一个用户及线程映射到几个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>\n<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>\n<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>\n\n        <h3 id=\"多对多模型\"   >\n          <a href=\"#多对多模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多对多模型\" class=\"headerlink\" title=\"多对多模型\"></a>多对多模型</h3>\n      <p>n用户及线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程。</p>\n<p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【计算机操作系统】1.1-操作系统引论","url":"/Major-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%911-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/","content":"\n        <h1 id=\"操作系统的概念功能和目标\"   >\n          <a href=\"#操作系统的概念功能和目标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#操作系统的概念功能和目标\" class=\"headerlink\" title=\"操作系统的概念功能和目标\"></a>操作系统的概念功能和目标</h1>\n      <ol>\n<li>负责管理协调硬件、软件等计算机资源的工作</li>\n<li>为上层的应用程序、用户提供简单易用的服务</li>\n<li>操作系统是系统软件，而不是硬件</li>\n</ol>\n<p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong>。</p>\n\n        <h2 id=\"作为系统资源的管理者\"   >\n          <a href=\"#作为系统资源的管理者\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#作为系统资源的管理者\" class=\"headerlink\" title=\"作为系统资源的管理者\"></a>作为系统资源的管理者</h2>\n      <p>进程是一个程序的执行过程。执行前<strong>需要将该程序放到内存中</strong>，才能被CPU处理。</p>\n<ul>\n<li>作为系统资源的管理者<ul>\n<li>提供的功能<ul>\n<li>处理机管理</li>\n<li>存储器管理</li>\n<li>文件管理</li>\n<li>设备管理</li>\n</ul>\n</li>\n<li>目标<ul>\n<li>安全</li>\n<li>高效</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"作为用户和计算机硬件之间的接口\"   >\n          <a href=\"#作为用户和计算机硬件之间的接口\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#作为用户和计算机硬件之间的接口\" class=\"headerlink\" title=\"作为用户和计算机硬件之间的接口\"></a>作为用户和计算机硬件之间的接口</h2>\n      <ul>\n<li><p>命令接口：允许用户<strong>直接使用</strong></p>\n</li>\n<li><p>程序接口：允许用户通过程序<strong>间接使用</strong></p>\n</li>\n<li><p>GUI：现代操作系统中最流行的图形用户接口</p>\n</li>\n<li><p>作为用户和计算机硬件之间的接口</p>\n<ul>\n<li>提供的功能<ul>\n<li>命令接口<ul>\n<li>联机命令接口</li>\n<li>脱机命令接口</li>\n</ul>\n</li>\n<li>程序接口</li>\n<li>GUI（图形化用户界面）</li>\n</ul>\n</li>\n<li>目标<ul>\n<li>方便用户使用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>其中的<strong>命令接口</strong>和<strong>程序接口</strong>统称为“<strong>用户接口</strong>”</p>\n<ul>\n<li>用户接口<ul>\n<li>命令接口（允许用户<strong>直接使用</strong>）<ul>\n<li>联机命令接口：用户说一句，系统做一句<ul>\n<li>CMD</li>\n</ul>\n</li>\n<li>脱机命令接口：用户说一堆，系统做一堆<ul>\n<li>BAT批处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>程序接口（允许用户通过程序<strong>间接使用</strong>）<ul>\n<li>由一组<strong>系统调用</strong>组成（程序接口=系统调用）</li>\n<li>如<code>C:\\Windows\\System32\\user32.dll</code>程序员在程序中调用<code>user32.dll</code>(该调用过程即为<strong>系统调用</strong>)即可实现穿件窗口等功能。只能通过用户程序<strong>间接使用</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>有的地方会称<code>系统调用=系统调用命令=广义指令</code></p>\n\n        <h2 id=\"作为最接近硬件的层次\"   >\n          <a href=\"#作为最接近硬件的层次\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#作为最接近硬件的层次\" class=\"headerlink\" title=\"作为最接近硬件的层次\"></a>作为最接近硬件的层次</h2>\n      <p>系统提供的功能和目标：实现对硬件机器的拓展</p>\n<p>没有任何软件支持的计算机称为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。</p>\n<p>通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>\n\n        <h1 id=\"操作系统的四个特征\"   >\n          <a href=\"#操作系统的四个特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#操作系统的四个特征\" class=\"headerlink\" title=\"操作系统的四个特征\"></a>操作系统的四个特征</h1>\n      <p><strong>并发</strong>和<strong>共享</strong>这两个最基本的特征，二者互为存在条件</p>\n\n        <h2 id=\"并发\"   >\n          <a href=\"#并发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2>\n      <ul>\n<li>并发<ul>\n<li>指两个或多个时间再同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。</li>\n</ul>\n</li>\n<li>并行<ul>\n<li>指两个或多个事件在同一时刻同时发生。</li>\n</ul>\n</li>\n</ul>\n<p><strong>操作系统的并发性</strong>指计算机系统中同时存在着多个运行着的程序。</p>\n<p>一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行）</p>\n<p>事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong>。</p>\n<p>N核CPU就意味着一个CPU中又N个内核，也就意味着可以由N个程序<strong>并行！！并行执行！！！</strong>，但是并发性依然是必不可少的。</p>\n\n        <h2 id=\"共享\"   >\n          <a href=\"#共享\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#共享\" class=\"headerlink\" title=\"共享\"></a>共享</h2>\n      <p><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>\n<ul>\n<li>两种资源共享方式<ul>\n<li>互斥共享方式<ul>\n<li>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong>。</li>\n</ul>\n</li>\n<li>同时共享方式<ul>\n<li>系统中的某些资源，**允许一个时间段内由多个进程“同时”对它们进行访问。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>所谓的“同时”往往是宏观上的，而在微观上这些进程可能是交替地对资源进行访问的（即分时共享）</p>\n<ul>\n<li>并发和共享的关系<ul>\n<li><strong>并发性</strong>是指计算机系统中同时存在着多个运行着的程序。</li>\n<li><strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</li>\n</ul>\n</li>\n</ul>\n<p>并发性和共享性互为存在条件。</p>\n\n        <h2 id=\"虚拟\"   >\n          <a href=\"#虚拟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#虚拟\" class=\"headerlink\" title=\"虚拟\"></a>虚拟</h2>\n      <p><strong>虚拟</strong>是指把一个物理上的实体变成若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>\n<ul>\n<li>空分复用技术<ul>\n<li>虚拟存储器技术，一句话就是假装有更多的内存。</li>\n</ul>\n</li>\n<li>时分复用技术<ul>\n<li>微观上处理机在各个微小的时间段内交替着为各个进程服务。</li>\n</ul>\n</li>\n</ul>\n<p>如果失去了并发性，则一个时间段内系统值需运行一道程序，那么就失去了实现虚拟性的意义了。因此<strong>没有并发性，就谈不上虚拟性</strong>。</p>\n\n        <h2 id=\"异步\"   >\n          <a href=\"#异步\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2>\n      <p><strong>异步</strong>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>\n<p>如果时许了并发性，则系统只能串行地处理各个进程，每个进程的执行才会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性。</strong></p>\n\n        <h1 id=\"操作系统的发展与分类\"   >\n          <a href=\"#操作系统的发展与分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#操作系统的发展与分类\" class=\"headerlink\" title=\"操作系统的发展与分类\"></a>操作系统的发展与分类</h1>\n      <ul>\n<li>OS的发展与分类<ul>\n<li>手工操作阶段</li>\n<li>批处理阶段<ul>\n<li>单道批处理系统</li>\n<li>多道批处理系统(操作系统开始出现)</li>\n</ul>\n</li>\n<li>分时操作系统</li>\n<li>实时操作系统</li>\n<li>网络操作系统</li>\n<li>分布式操作系统</li>\n<li>个人计算机操作系统</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"手工操作阶段\"   >\n          <a href=\"#手工操作阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#手工操作阶段\" class=\"headerlink\" title=\"手工操作阶段\"></a>手工操作阶段</h2>\n      <p>打孔纸带的那个计算机，骆代富年代的那个机器</p>\n<ul>\n<li>主要缺点<ul>\n<li>用户独占全机</li>\n<li>人机速度矛盾导致资源利率极低</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"批处理阶段\"   >\n          <a href=\"#批处理阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#批处理阶段\" class=\"headerlink\" title=\"批处理阶段\"></a>批处理阶段</h2>\n      \n        <h3 id=\"单道批处理系统\"   >\n          <a href=\"#单道批处理系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#单道批处理系统\" class=\"headerlink\" title=\"单道批处理系统\"></a>单道批处理系统</h3>\n      <p>引出<strong>脱机输入/输出技术</strong>（用磁带完成），并<strong>监督程序</strong>负责控制作业的输入、输出。</p>\n<p>在手工操作的那个指代机中多了一台外围机，用来将纸带读入磁带上</p>\n<ul>\n<li>主要优点<ul>\n<li>缓解了一定程度的人机速度矛盾，资源利用率有所提升</li>\n</ul>\n</li>\n<li>主要缺点<ul>\n<li>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序</li>\n<li>CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"多道批处理系统\"   >\n          <a href=\"#多道批处理系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多道批处理系统\" class=\"headerlink\" title=\"多道批处理系统\"></a>多道批处理系统</h3>\n      <p>每次往内存中输入多道程序</p>\n<p>操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行。</p>\n<ul>\n<li>主要优点<ul>\n<li>多道程序并发执行，共享计算机资源</li>\n<li>资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</li>\n</ul>\n</li>\n<li>主要缺点<ul>\n<li>用户相应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。）</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"分时操作系统\"   >\n          <a href=\"#分时操作系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分时操作系统\" class=\"headerlink\" title=\"分时操作系统\"></a>分时操作系统</h2>\n      <p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p>\n<ul>\n<li>主要优点<ul>\n<li>用户请求可以被及时响应，解决了人机交互问题。</li>\n<li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li>\n</ul>\n</li>\n<li>主要缺点<ul>\n<li><strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"实时操作系统\"   >\n          <a href=\"#实时操作系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#实时操作系统\" class=\"headerlink\" title=\"实时操作系统\"></a>实时操作系统</h2>\n      <ul>\n<li>主要优点<ul>\n<li>能够优先响应一些紧急任务，某些紧急任务不需要时间片排队</li>\n</ul>\n</li>\n</ul>\n<p>在实时操作系统的控制下，计算机系统收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p>\n<ul>\n<li>实时操作系统<ul>\n<li>硬实时系统<ul>\n<li>必须在绝对严格的规定时间内完成处理</li>\n<li>导弹控制系统、自动驾驶系统</li>\n</ul>\n</li>\n<li>软实时系统<ul>\n<li>能接收偶尔违反时间规定</li>\n<li>12306火车票</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"其他几种操作系统\"   >\n          <a href=\"#其他几种操作系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#其他几种操作系统\" class=\"headerlink\" title=\"其他几种操作系统\"></a>其他几种操作系统</h2>\n      <p>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</p>\n<p>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机低位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>\n\n        <h1 id=\"操作系统的运行机制与体系结构\"   >\n          <a href=\"#操作系统的运行机制与体系结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#操作系统的运行机制与体系结构\" class=\"headerlink\" title=\"操作系统的运行机制与体系结构\"></a>操作系统的运行机制与体系结构</h1>\n      <ul>\n<li>OS的运行机制和体系结构<ul>\n<li>运行机制<ul>\n<li>两种指令<ul>\n<li>特权指令</li>\n<li>非特权指令</li>\n</ul>\n</li>\n<li>两种处理器状态<ul>\n<li>核心态</li>\n<li>用户态</li>\n</ul>\n</li>\n<li>两种程序<ul>\n<li>内核程序</li>\n<li>应用程序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>操作系统内核<ul>\n<li>时钟管理</li>\n<li>中断处理</li>\n<li>原语</li>\n<li>对系统资源进行管理的功能<ul>\n<li>进程管理</li>\n<li>存储器管理</li>\n<li>设备管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>操作系统的体系结构<ul>\n<li>大内核</li>\n<li>微内核</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"两种指令、两种处理器状态、两种程序\"   >\n          <a href=\"#两种指令、两种处理器状态、两种程序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#两种指令、两种处理器状态、两种程序\" class=\"headerlink\" title=\"两种指令、两种处理器状态、两种程序\"></a>两种指令、两种处理器状态、两种程序</h2>\n      <ul>\n<li><p>指令</p>\n<ul>\n<li>特权指令：如内存清零指令</li>\n<li>非特权指令：如普通的运算指令</li>\n</ul>\n</li>\n<li><p>处理器状态</p>\n<ul>\n<li>用户态(目态)<ul>\n<li>此时CPU只能执行非特权指令</li>\n</ul>\n</li>\n<li>核心态(管态)<ul>\n<li>特权指令、非特权指令都可执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>处理器状态用程序状态寄存器(PSW)中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态</p>\n<ul>\n<li><p>两种程序</p>\n<ul>\n<li>内核程序<ul>\n<li>操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</li>\n</ul>\n</li>\n<li>应用程序<ul>\n<li>为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>运行机制</p>\n<ul>\n<li>两种指令<ul>\n<li>特权指令</li>\n<li>非特权指令</li>\n</ul>\n</li>\n<li>两种处理器状态<ul>\n<li>核心态</li>\n<li>用户态</li>\n</ul>\n</li>\n<li>两种程序<ul>\n<li>内核程序</li>\n<li>应用程序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"操作系统的内核\"   >\n          <a href=\"#操作系统的内核\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#操作系统的内核\" class=\"headerlink\" title=\"操作系统的内核\"></a>操作系统的内核</h2>\n      <ul>\n<li>操作系统<ul>\n<li>非内核功能</li>\n<li>内核<ul>\n<li>进程管理、存储器管理、设备管理等功能</li>\n<li>时钟管理<ul>\n<li>实现计时功能</li>\n</ul>\n</li>\n<li>中断处理</li>\n<li>原语(设备驱动、CPU切换等)<ul>\n<li>是一种特殊的程序，是最接近硬件的部分，这种程序的运行具有原子性。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>内核是计算机上配置的底层软件，是操作系统最基本，最核心的部分。</p>\n<p>实现操作系统内核功能的那些程序就是<strong>内核程序</strong></p>\n<ul>\n<li>操作系统内核<ul>\n<li>时钟管理<ul>\n<li>实现及时功能</li>\n</ul>\n</li>\n<li>中断处理<ul>\n<li>负责实现中断机制</li>\n</ul>\n</li>\n<li>原语<ul>\n<li>是一种特殊的程序</li>\n<li>处于操作系统最底层，最接近硬件的部分</li>\n<li>这种程序的运行具有原子性——其运行只能一气呵成，不可中断</li>\n<li>运行时间较短、调用频繁</li>\n</ul>\n</li>\n<li>对系统资源进行管理的功能<ul>\n<li>进程管理</li>\n<li>存储器管理</li>\n<li>设备管理</li>\n<li>有的操作西荣不把这些功能归为“内核功能”，也就是说，不同的操作系统对内核功能的划分可能并不一样。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"操作系统的体系结构\"   >\n          <a href=\"#操作系统的体系结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#操作系统的体系结构\" class=\"headerlink\" title=\"操作系统的体系结构\"></a>操作系统的体系结构</h2>\n      <ul>\n<li><p>大内核就是包括了非必备的那些功能</p>\n</li>\n<li><p>微内核就是只包含了必备的功能</p>\n</li>\n<li><p>操作系统的体系结构</p>\n<ul>\n<li>大内核<ul>\n<li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li>\n<li>优点：高性能</li>\n<li>缺点：内核代码庞大，结构混乱，难以维护</li>\n</ul>\n</li>\n<li>微内核<ul>\n<li>只把最基本的功能保留在内核</li>\n<li>优点：内核功能少，结构清晰，方便维护。</li>\n<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"中断和异常\"   >\n          <a href=\"#中断和异常\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#中断和异常\" class=\"headerlink\" title=\"中断和异常\"></a>中断和异常</h1>\n      <ul>\n<li>中断和异常<ul>\n<li>中断机制的诞生</li>\n<li>中断的概念和作用</li>\n<li>中断的分类<ul>\n<li>内中断（也称为“异常”）</li>\n<li>外中断</li>\n</ul>\n</li>\n<li>外中断的处理过程</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"中断机制的诞生\"   >\n          <a href=\"#中断机制的诞生\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#中断机制的诞生\" class=\"headerlink\" title=\"中断机制的诞生\"></a>中断机制的诞生</h2>\n      <p>人们发明了操作系统，引入中断机制，实现了多道程序并发执行</p>\n<p>本质：发生中断就意味着需要操作系统介入，开展管理工作</p>\n<p>CPU收到计时部件发出的<strong>中断信号</strong>，切换为<strong>核心态</strong>对中断进行处理。操作系统内核负责对中断信号进行处理</p>\n\n        <h2 id=\"中断的概念和作用\"   >\n          <a href=\"#中断的概念和作用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#中断的概念和作用\" class=\"headerlink\" title=\"中断的概念和作用\"></a>中断的概念和作用</h2>\n      <ol>\n<li>当中断发生时，CPU立即进入<strong>核心态</strong></li>\n<li>当中断发生时，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li>\n<li>对于不同的中断信号，会进行不同的处理</li>\n</ol>\n<p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。<strong>中断</strong>可以使CPU从<strong>用户态切换为核心态，使操作系统获得计算机的控制权</strong>。有了中断，才能实现多道程序并发执行。</p>\n<ul>\n<li>中断是用户态-&gt;核心态的唯一！唯一途径！！</li>\n<li>核心态-&gt;用户态的切换是通过<strong>执行一个特权指令</strong>，将程序状态字(PSW)的标志位设置为“用户态”。</li>\n</ul>\n\n        <h2 id=\"中断的分类\"   >\n          <a href=\"#中断的分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#中断的分类\" class=\"headerlink\" title=\"中断的分类\"></a>中断的分类</h2>\n      <ul>\n<li>中断<ul>\n<li>内中断（也称异常、列外、陷入）(信号来源：CPU内部与当前执行的指令有关)<ul>\n<li>自愿中断-指令中断(系统调用时使用的访管指令，又叫陷入指令、trap指令)</li>\n<li>强迫中断<ul>\n<li>硬件故障(如：缺页)</li>\n<li>软件中断(如：整数除0)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>外中断（中断）(信号来源：CPU外部，与当前执行的指令无关)<ul>\n<li>外设请求(I/O操作完成发出的中断信号)</li>\n<li>人工干预(用户强行终止一个进程)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>另一种分类方式：</p>\n<ul>\n<li>中断的分类<ul>\n<li>内中断(内部异常)<ul>\n<li>陷阱、陷入(trap)<ul>\n<li>有意而为之的异常，如系统调用</li>\n</ul>\n</li>\n<li>故障(fault)<ul>\n<li>由错误条件引起的，可能被故障处理程序修复，如缺页</li>\n</ul>\n</li>\n<li>终止(abort)<ul>\n<li>不可恢复的指明错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>外中断<ul>\n<li>I/O中断请求</li>\n<li>人工干预</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"外中断的处理过程\"   >\n          <a href=\"#外中断的处理过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#外中断的处理过程\" class=\"headerlink\" title=\"外中断的处理过程\"></a>外中断的处理过程</h2>\n      <ol>\n<li>执行完每个指令后，CPU都要检查当前是否有外部中断信号。</li>\n<li>如果检测到外部终端型号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器）</li>\n<li>根据中断信号类型转入相应的中断处理程序</li>\n<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行。</li>\n</ol>\n\n        <h1 id=\"系统调用\"   >\n          <a href=\"#系统调用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h1>\n      <ul>\n<li>系统调用<ul>\n<li>什么是系统调用，有何作用？</li>\n<li>系统调用和库函数的区别</li>\n<li>系统调用背后的过程</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"什么是系统调用，有何作用？\"   >\n          <a href=\"#什么是系统调用，有何作用？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是系统调用，有何作用？\" class=\"headerlink\" title=\"什么是系统调用，有何作用？\"></a>什么是系统调用，有何作用？</h2>\n      <p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组<strong>系统调用</strong>组成。</p>\n<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>\n<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源都有操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过操作系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>\n<ul>\n<li>系统调用(按功能分类)<ul>\n<li>设备管理<ul>\n<li>完成设备的 请求/释放/启动 等功能</li>\n</ul>\n</li>\n<li>文件管理<ul>\n<li>完成文件的 读/写/创建/删除 等功能</li>\n</ul>\n</li>\n<li>进程控制<ul>\n<li>完成进程的 创建/撤销/阻塞/唤醒 等功能</li>\n</ul>\n</li>\n<li>进程通信<ul>\n<li>完成进程之间的 消息传递/信号传递 等功能</li>\n</ul>\n</li>\n<li>内存管理<ul>\n<li>完成内存的 分配/回收 等功能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些<strong>特权指令</strong>才能完成，因此<strong>系统调用的相关处理</strong>需要在<strong>核心态</strong>下进行。</p>\n\n        <h2 id=\"系统调用和库函数的区别\"   >\n          <a href=\"#系统调用和库函数的区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#系统调用和库函数的区别\" class=\"headerlink\" title=\"系统调用和库函数的区别\"></a>系统调用和库函数的区别</h2>\n      <p>库函数就是封装好的系统调用，把具体使用了哪些系统调用的细节隐藏起来了。</p>\n<ul>\n<li>不涉及系统调用的库函数：取绝对值</li>\n<li>涉及系统调用的库函数：创建一个新文件</li>\n</ul>\n\n        <h2 id=\"系统调用背后的过程\"   >\n          <a href=\"#系统调用背后的过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#系统调用背后的过程\" class=\"headerlink\" title=\"系统调用背后的过程\"></a>系统调用背后的过程</h2>\n      <p>传递系统调用参数-&gt;执行陷入指令(用户态)-&gt;执行系统调用相应服务程序(核心态)-&gt;返回用户程序</p>\n<ol>\n<li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态</li>\n<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>\n<li>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</li>\n</ol>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【计算机操作系统】2-3-进程同步、互斥","url":"/Major-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912-3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E4%BA%92%E6%96%A5/","content":"\n        <h1 id=\"进程同步、进程互斥\"   >\n          <a href=\"#进程同步、进程互斥\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程同步、进程互斥\" class=\"headerlink\" title=\"进程同步、进程互斥\"></a>进程同步、进程互斥</h1>\n      <ul>\n<li>什么是进程同步</li>\n<li>什么是进程互斥</li>\n</ul>\n\n        <h2 id=\"什么是进程同步\"   >\n          <a href=\"#什么是进程同步\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是进程同步\" class=\"headerlink\" title=\"什么是进程同步\"></a>什么是进程同步</h2>\n      <p>进程具有<strong>异步性</strong>的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>\n<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<strong>写数据-&gt;读数据</strong>”的顺序来执行的。如何解决这种<strong>异步</strong>问题，就是“进程<strong>同步</strong>”所讨论的内容。</p>\n<p><strong>同步</strong>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>\n\n        <h2 id=\"什么是进程互斥\"   >\n          <a href=\"#什么是进程互斥\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是进程互斥\" class=\"headerlink\" title=\"什么是进程互斥\"></a>什么是进程互斥</h2>\n      <p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)</p>\n<ul>\n<li>两种资源共享方式<ul>\n<li>互斥共享方式<ul>\n<li>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong>。</li>\n</ul>\n</li>\n<li>同时共享方式<ul>\n<li>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们把<strong>一个时间段内允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区都属于临界资源。</p>\n<p>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问资源。</p>\n<p>对临界资源的互斥访问，可以在逻辑上分为四个部分：</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">  entry section;  <span class=\"comment\">//进入区，负责检查是否可进入临界区，若可进入则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其他进程同时进入临界区</span></span><br><span class=\"line\">  critical section; <span class=\"comment\">//临界区，访问临界资源的那段代码</span></span><br><span class=\"line\">  exit section; <span class=\"comment\">//退出区，负责解除正在访问临界资源的标志(可理解为“解锁”)</span></span><br><span class=\"line\">  remainder section;  <span class=\"comment\">//剩余区,做其他处理</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>注意：</p>\n<ul>\n<li>临界区是进程中<strong>访问临界资源的</strong>的代码段。</li>\n<li>进入区和退出区是负责实现互斥的代码段</li>\n<li>临界区也可称为“临界区”。</li>\n</ul>\n</li>\n<li><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>\n<ol>\n<li>空闲让忙。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>\n<li>忙则等待。当已有进程进入临界区，其他试图进入临界区的进程必须等待</li>\n<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li>\n<li>让权等待。当进程不能进入临界区，应立即释放处理机，防止进程忙等待。</li>\n</ol>\n</li>\n</ul>\n\n        <h1 id=\"进程互斥的软件实现方法\"   >\n          <a href=\"#进程互斥的软件实现方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程互斥的软件实现方法\" class=\"headerlink\" title=\"进程互斥的软件实现方法\"></a>进程互斥的软件实现方法</h1>\n      <ul>\n<li><p>单标志法</p>\n</li>\n<li><p>双标志先检查</p>\n</li>\n<li><p>双标志后检查</p>\n</li>\n<li><p>Peterson算法</p>\n</li>\n<li><p>学习提示：</p>\n<ol>\n<li>理解各个算法的思想、原理</li>\n<li>结合“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li>\n<li>分析各算法存在的缺陷(结合“实现互斥要遵循的四个原则”进行分析)</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"单标志法\"   >\n          <a href=\"#单标志法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#单标志法\" class=\"headerlink\" title=\"单标志法\"></a>单标志法</h2>\n      <p>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的缺陷转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p>\n\n        <h2 id=\"双标志先检查法\"   >\n          <a href=\"#双标志先检查法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#双标志先检查法\" class=\"headerlink\" title=\"双标志先检查法\"></a>双标志先检查法</h2>\n      <p>算法思想：设置一个布尔型数组<code>flag[]</code>，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如<code>flag[0] = true</code>意味着0号进程P0现在想进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code>flag[i]</code>设为true，之后开始访问临界区。</p>\n<p>双标志先检查法的主要问题是：<strong>违反“忙则等待”原则</strong>。</p>\n<p>原因在于，<strong>进入区</strong>的“检查”和“上锁”<strong>两个处理不是一气呵成的</strong>。“检查”后，“上锁”前可能发生进程切换。</p>\n\n        <h2 id=\"双标志后检查法\"   >\n          <a href=\"#双标志后检查法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#双标志后检查法\" class=\"headerlink\" title=\"双标志后检查法\"></a>双标志后检查法</h2>\n      <p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>\n<p>双标志后检查法虽然解决了“忙则等待”的问题，但是<strong>又违背了“空闲让进”和“有限等待”原则</strong>，会因各程序都长期无法访问临界资源而<strong>产生“饥饿”现象</strong>。</p>\n<p>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>\n\n        <h2 id=\"Peterson算法\"   >\n          <a href=\"#Peterson算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Peterson算法\" class=\"headerlink\" title=\"Peterson算法\"></a>Peterson算法</h2>\n      <p>算法思想：如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</p>\n<p>其实是多设了一个标志位<code>turn</code>，P0时设<code>turn=1</code>，条件<code>turn=0</code>时进入临界区。P1时设<code>turn=0</code>，条件<code>turn=1</code>时进入临界区。当P1时间片用完后切回P0时，将会满足P0条件，从而进入临界区。</p>\n<p>Peterson算法用软件方法解决了进程互斥问题，<strong>遵循了空闲让进、忙则等待、有限等待三个原则</strong>，但是仍然<strong>未遵循让权等待</strong>的原则，</p>\n<p>Peterson算法相较于之前三种软件解决方案来说，是最好的，但仍然不够好。</p>\n\n        <h1 id=\"进程互斥的硬件实现方法\"   >\n          <a href=\"#进程互斥的硬件实现方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程互斥的硬件实现方法\" class=\"headerlink\" title=\"进程互斥的硬件实现方法\"></a>进程互斥的硬件实现方法</h1>\n      <ul>\n<li><p>中断屏蔽方法</p>\n</li>\n<li><p>TestAndSet(TS指令/TSL指令)</p>\n</li>\n<li><p>Swap指令(XCHG指令)</p>\n</li>\n<li><p>学习提示</p>\n<ol>\n<li>理解各方法的原理</li>\n<li>了解各方法的优缺点</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"中断屏蔽方法\"   >\n          <a href=\"#中断屏蔽方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#中断屏蔽方法\" class=\"headerlink\" title=\"中断屏蔽方法\"></a>中断屏蔽方法</h2>\n      <p>利用“开/关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">关中断;</span><br><span class=\"line\">临界区;</span><br><span class=\"line\">开中断;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>优点：简单、高效</li>\n<li>缺点：不适合用于多处理机；只适合于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)</li>\n</ul>\n\n        <h2 id=\"TestAndSet指令\"   >\n          <a href=\"#TestAndSet指令\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TestAndSet指令\" class=\"headerlink\" title=\"TestAndSet指令\"></a>TestAndSet指令</h2>\n      <p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令</p>\n<p>TSL指令<strong>是用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//布尔型共享变量lock表示当前临界区是否被加锁</span></span><br><span class=\"line\"><span class=\"comment\">//true表示已加锁，false表示未加锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">TestAndSet</span><span class=\"params\">(<span class=\"keyword\">bool</span> *lock)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> old;</span><br><span class=\"line\">  old = *lock;<span class=\"comment\">//old用来存放lock原来的值</span></span><br><span class=\"line\">  *lock = <span class=\"literal\">true</span>;<span class=\"comment\">//无论之前是否已加锁，都将lock设为true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> old;<span class=\"comment\">//返回lock原来的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">TestAndSet</span>(&amp;lock));<span class=\"comment\">//“上锁”并“检查”</span></span><br><span class=\"line\">临界区代码段;</span><br><span class=\"line\">lock = <span class=\"literal\">false</span>; <span class=\"comment\">//解锁</span></span><br><span class=\"line\">剩余代码段;</span><br></pre></td></tr></table></div></figure>\n\n<p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>\n<p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>\n<ul>\n<li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适合用于多处理机环境。</li>\n<li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</li>\n</ul>\n\n        <h2 id=\"Swap指令\"   >\n          <a href=\"#Swap指令\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Swap指令\" class=\"headerlink\" title=\"Swap指令\"></a>Swap指令</h2>\n      <p>有的地方也叫Exchange指令，或简称XCHG指令。</p>\n<p>Swap指令<strong>是用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Swap指令的作用是交换两个变量的值</span></span><br><span class=\"line\"><span class=\"built_in\">Swap</span>(<span class=\"keyword\">bool</span> *a,<span class=\"keyword\">bool</span> *b)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> temp;</span><br><span class=\"line\">  temp = *a;</span><br><span class=\"line\">  *a = *b;</span><br><span class=\"line\">  *b = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以下是用Swap指令实现互斥的算法逻辑</span></span><br><span class=\"line\"><span class=\"comment\">//lock表示当前临界区是否被加锁</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> old = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(old==<span class=\"literal\">true</span>)</span><br><span class=\"line\">  <span class=\"built_in\">Swap</span>(&amp;lock,&amp;old);</span><br><span class=\"line\">临界区代码段;</span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\">剩余区代码段;</span><br></pre></td></tr></table></div></figure>\n\n<p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>\n<ul>\n<li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适合用于多处理机环境。</li>\n<li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</li>\n</ul>\n\n        <h1 id=\"信号量机制\"   >\n          <a href=\"#信号量机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#信号量机制\" class=\"headerlink\" title=\"信号量机制\"></a>信号量机制</h1>\n      <ul>\n<li>整型信号量</li>\n<li>记录型信号量</li>\n</ul>\n<p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</p>\n<p><strong>信号量</strong>其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>\n<p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断/开中断指令</strong>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>\n<p><strong>一对原语</strong>：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的<strong>信号量S</strong>其实就是函数调用时传入的一个参数。</p>\n<p>wait、signal原语常<strong>简称为P、V操作</strong>。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为<strong>P(S)、V(S)</strong></p>\n\n        <h2 id=\"整型信号量\"   >\n          <a href=\"#整型信号量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#整型信号量\" class=\"headerlink\" title=\"整型信号量\"></a>整型信号量</h2>\n      <p>用一个整数型的变量作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</p>\n<p>与普通整数变量的区别：对信号量的操作只有三种，即 初始化、P操作、V操作</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> S = <span class=\"number\">1</span>;  <span class=\"comment\">//初始化整型信号量s，表示当前系统中可用的打印机资源数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">int</span> S)</span></span>&#123; <span class=\"comment\">//wait原语，相当于“进入区”</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(S&lt;=<span class=\"number\">0</span>) <span class=\"comment\">//如果资源数不够，就一直循环等待</span></span><br><span class=\"line\">  S=S<span class=\"number\">-1</span>;  <span class=\"comment\">//如果资源数够，则占用一个资源</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">(<span class=\"keyword\">int</span> S)</span></span>&#123;<span class=\"comment\">//signal原语，相当于“退出区”</span></span><br><span class=\"line\">  S=S+<span class=\"number\">1</span>;<span class=\"comment\">//使用完资源后，在退出区释放资源</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">wait</span>(S);  <span class=\"comment\">//进入区，申请资源</span></span><br><span class=\"line\">使用打印机资源... <span class=\"comment\">//临界区，访问资源</span></span><br><span class=\"line\"><span class=\"built_in\">signal</span>(S);  <span class=\"comment\">//退出区。释放资源</span></span><br></pre></td></tr></table></div></figure>\n\n<p>“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</p>\n<p>存在的问题：不满足“让权等待”原则，会发生“忙等”</p>\n\n        <h2 id=\"记录型信号量\"   >\n          <a href=\"#记录型信号量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#记录型信号量\" class=\"headerlink\" title=\"记录型信号量\"></a>记录型信号量</h2>\n      <p>整形信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//记录型信号量的定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> value;  <span class=\"comment\">//剩余资源数</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">process</span> *<span class=\"title\">L</span>;</span><span class=\"comment\">//等待队列</span></span><br><span class=\"line\">&#125;semaphore;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//某进程需要使用资源时，通过wait原语申请</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wait</span><span class=\"params\">(semaphore S)</span></span>&#123;</span><br><span class=\"line\">  S.value--;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.value&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">block</span>(S.L); <span class=\"comment\">//如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列(即阻塞队列)中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//进程使用完资源后，通过signal原语释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">(semaphore S)</span></span>&#123;</span><br><span class=\"line\">  S.value++;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.value&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">wakeup</span>(S.L);  <span class=\"comment\">//释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>对信号量S的<strong>一次P操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行S.value–，表示资源数减1，当S.value&lt;0时表示该类资源已分配完毕，因此进程应<strong>调用block原语进行自我阻塞**(当前运行的进程从**运行态-&gt;阻塞态</strong>)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</p>\n<p>对信号量S的<strong>一次V操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行S.value++，表示资源数加1，若加1后仍是S.value&lt;=0，表示依然有进程在等待该类资源，因此应<strong>调用wakeup原语唤醒等待队列中的第一个进程**(被唤醒进程从**阻塞态-&gt;就绪态</strong>)。</p>\n\n        <h1 id=\"用信号量机制实现-进程互斥、同步，前驱关系\"   >\n          <a href=\"#用信号量机制实现-进程互斥、同步，前驱关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#用信号量机制实现-进程互斥、同步，前驱关系\" class=\"headerlink\" title=\"用信号量机制实现 进程互斥、同步，前驱关系\"></a>用信号量机制实现 进程互斥、同步，前驱关系</h1>\n      <ul>\n<li>实现进程互斥</li>\n<li>实现进程同步</li>\n<li>实现进程的前驱关系</li>\n</ul>\n\n        <h2 id=\"信号量机制实现进程互斥\"   >\n          <a href=\"#信号量机制实现进程互斥\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#信号量机制实现进程互斥\" class=\"headerlink\" title=\"信号量机制实现进程互斥\"></a>信号量机制实现进程互斥</h2>\n      <ol>\n<li>分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)</li>\n<li>设置<strong>互斥信号量</strong>mutex，<strong>初值为1</strong></li>\n<li>在临界区之前执行P(mutex)</li>\n<li>在临界区之后执行V(mutex)</li>\n</ol>\n<p>对不同的临界资源需要设置不同的互斥信号。</p>\n<p>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//信号量机制实现互斥</span></span><br><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;<span class=\"comment\">//初始化信号量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">P1</span>()&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">P</span>(mutex); <span class=\"comment\">//使用临界资源的需要加锁</span></span><br><span class=\"line\">  临界区代码段...</span><br><span class=\"line\">  <span class=\"built_in\">V</span>(mutex); <span class=\"comment\">//使用临界资源后需要解锁</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">P2</span>()&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">P</span>(mutex);</span><br><span class=\"line\">  临界区代码段...</span><br><span class=\"line\">  <span class=\"built_in\">V</span>(mutex);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"信号量机制实现进程同步\"   >\n          <a href=\"#信号量机制实现进程同步\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#信号量机制实现进程同步\" class=\"headerlink\" title=\"信号量机制实现进程同步\"></a>信号量机制实现进程同步</h2>\n      <p>进程同步：要求各并发进程要求有序地推进。</p>\n<ul>\n<li>用信号量实现进程同步：<ol>\n<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li>\n<li>设置<strong>同步信号量</strong>S，初始为0</li>\n<li>在“前操作”之后执行V(S)</li>\n<li>在“后操作”之前执行P(S)</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore S=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">P1</span>()&#123;</span><br><span class=\"line\">  代码<span class=\"number\">1</span>;</span><br><span class=\"line\">  代码<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">V</span>(S);</span><br><span class=\"line\">  代码<span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">P2</span>()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">P</span>(S);</span><br><span class=\"line\">  代码<span class=\"number\">4</span>;</span><br><span class=\"line\">  代码<span class=\"number\">5</span>;</span><br><span class=\"line\">  代码<span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"信号量机制实现前驱关系\"   >\n          <a href=\"#信号量机制实现前驱关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#信号量机制实现前驱关系\" class=\"headerlink\" title=\"信号量机制实现前驱关系\"></a>信号量机制实现前驱关系</h2>\n      <p>其实每一对前驱关系都是一个进程同步问题(需要保证一前一后的操作)，因此：</p>\n<ol>\n<li>要为每一对前驱关系各设置一个同步变量</li>\n<li>在“前操作”之后对相应的同步变量执行V操作</li>\n<li>在“后操作”之前对相应的同步变量执行P操作</li>\n</ol>\n<hr>\n<ul>\n<li>互斥问题，信号量初值为1</li>\n<li>同步问题，信号量初值为0</li>\n<li>前驱关系问题，本质上就是更复杂的同步问题</li>\n<li>除了互斥，同步问题外，还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行V操作即可。</li>\n</ul>\n\n        <h1 id=\"生产者消费者问题\"   >\n          <a href=\"#生产者消费者问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#生产者消费者问题\" class=\"headerlink\" title=\"生产者消费者问题\"></a>生产者消费者问题</h1>\n      \n        <h2 id=\"问题描述\"   >\n          <a href=\"#问题描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2>\n      <p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。</p>\n<p>生产者、消费者共享一个<strong>初始为空、大小为n的缓冲区</strong>。</p>\n<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p>\n<p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</p>\n<p>缓冲区是临界资源，各进程必须互斥地访问。</p>\n<ul>\n<li><p>如何用信号量机制(P、V操作)实现生产者、消费者进程的这些功能呢？</p>\n<ul>\n<li>信号量机制可实现互斥、同步、对一类系统资源的申请和释放。</li>\n<li>互斥：设置初值为1的互斥信号量</li>\n<li>同步：设置初值为0的同步信号量(实现“一前一后”)</li>\n<li>对一类系统资源的申请和释放：设置一个信号量，初始值即为资源的数量(本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行)</li>\n</ul>\n</li>\n<li><p>PV操作题目分析步骤：</p>\n<ol>\n<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>\n<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li>\n</ol>\n<ul>\n<li>生产者每次要消耗(P)一个空闲缓冲区，并生产(V)一个产品。</li>\n<li>消费者每次要消耗(P)一个产品，并释放一个空闲缓冲区(V)。</li>\n<li>往缓冲区放入/取走产品需要互斥。</li>\n</ul>\n<ol start=\"3\">\n<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"如何实现\"   >\n          <a href=\"#如何实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2>\n      <p>生产者、消费者共享一个<strong>初始为空、大小为n的缓冲区</strong>。</p>\n<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p>\n<p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</p>\n<p>缓冲区是临界资源，各进程必须互斥地访问。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;  <span class=\"comment\">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class=\"line\">semaphore empty = n;  <span class=\"comment\">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class=\"line\">semaphore full = <span class=\"number\">0</span>;   <span class=\"comment\">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">producer</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    生产一个产品;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(empty); <span class=\"comment\">//消耗一个空闲缓冲区</span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(mutex); <span class=\"comment\">//互斥</span></span><br><span class=\"line\">    把产品放入缓冲区;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(mutex);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(full);  <span class=\"comment\">//增加一个产品</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">consumer</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(full);  <span class=\"comment\">//消耗一个产品(非空缓冲区)</span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(mutex);</span><br><span class=\"line\">    从缓冲区取出一个产品;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(mutex); <span class=\"comment\">//增加一个空闲缓冲区</span></span><br><span class=\"line\">    <span class=\"built_in\">V</span>(empty);</span><br><span class=\"line\">    使用产品;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>实现互斥的P操作一定要再实现同步的P操作之后，否则可能会造成死锁！</strong></p>\n\n        <h1 id=\"多生产者—多消费者问题\"   >\n          <a href=\"#多生产者—多消费者问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多生产者—多消费者问题\" class=\"headerlink\" title=\"多生产者—多消费者问题\"></a>多生产者—多消费者问题</h1>\n      \n        <h2 id=\"问题描述-1\"   >\n          <a href=\"#问题描述-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2>\n      <p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p>\n<p>盘子看作大小为1，初始均空的缓冲区。</p>\n\n        <h2 id=\"问题分析\"   >\n          <a href=\"#问题分析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2>\n      <ol>\n<li>分析高压包旭。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>\n<li>整理思路。根据各晋城的操作流程确定P、V操作的大致顺序。</li>\n<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li>\n</ol>\n<ul>\n<li>互斥关系：<ol>\n<li>对缓冲区(盘子)的访问要互斥地进行。</li>\n</ol>\n</li>\n<li>同步关系(一前一后)：<ol>\n<li>父亲将苹果放入盘子后，女儿才能取苹果</li>\n<li>母亲将橘子放入盘子后，儿子才能取橘子</li>\n<li>只有<strong>盘子为空</strong>时，<strong>父亲或母亲</strong>才能放入水果</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"知识回顾与重要考点\"   >\n          <a href=\"#知识回顾与重要考点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#知识回顾与重要考点\" class=\"headerlink\" title=\"知识回顾与重要考点\"></a>知识回顾与重要考点</h2>\n      <p>总结：再生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p>\n<p>建议：在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p>\n<ul>\n<li>PV操作题目的解题思路：<ol>\n<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>\n<li>整理思路。根据各进程的操作确定P、V操作的大致顺序。</li>\n<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li>\n</ol>\n</li>\n</ul>\n\n        <h1 id=\"吸烟者问题\"   >\n          <a href=\"#吸烟者问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#吸烟者问题\" class=\"headerlink\" title=\"吸烟者问题\"></a>吸烟者问题</h1>\n      \n        <h2 id=\"问题描述-2\"   >\n          <a href=\"#问题描述-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题描述-2\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2>\n      <p>假设一个系统有<strong>三个吸烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽调它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)</p>\n\n        <h2 id=\"如何实现-1\"   >\n          <a href=\"#如何实现-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何实现-1\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore offer1 = <span class=\"number\">0</span>; <span class=\"comment\">//桌上组合一的数量</span></span><br><span class=\"line\">semaphore offer2 = <span class=\"number\">0</span>; <span class=\"comment\">//桌上组合二的数量</span></span><br><span class=\"line\">semaphore offer3 = <span class=\"number\">0</span>; <span class=\"comment\">//桌上组合三的数量</span></span><br><span class=\"line\">semaphore finish = <span class=\"number\">0</span>; <span class=\"comment\">//抽烟是否完成</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;  <span class=\"comment\">//用于实现“三个抽烟者轮流抽烟”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">provider</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      将组合一放桌上;</span><br><span class=\"line\">      <span class=\"built_in\">V</span>(offer1);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">      将组合二放桌上;</span><br><span class=\"line\">      <span class=\"built_in\">V</span>(offer2);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">      将组合三放桌上;</span><br><span class=\"line\">      <span class=\"built_in\">V</span>(offer3);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = (i+<span class=\"number\">1</span>)%<span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(finish);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">smoker1</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(offer1);</span><br><span class=\"line\">    从桌上拿走组合一;</span><br><span class=\"line\">    卷烟;</span><br><span class=\"line\">    抽烟;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(finish);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">smoker2</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(offer2);</span><br><span class=\"line\">    从桌上拿走组合二;</span><br><span class=\"line\">    卷烟;</span><br><span class=\"line\">    抽烟;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(finish);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">smoker3</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(offer3);</span><br><span class=\"line\">    从桌上拿走组合三;</span><br><span class=\"line\">    卷烟;</span><br><span class=\"line\">    抽烟;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(finish);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"读者-写者问题\"   >\n          <a href=\"#读者-写者问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#读者-写者问题\" class=\"headerlink\" title=\"读者-写者问题\"></a>读者-写者问题</h1>\n      \n        <h2 id=\"问题描述-3\"   >\n          <a href=\"#问题描述-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题描述-3\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2>\n      <p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。</p>\n<ul>\n<li>因此要求：<ol>\n<li>允许多个读者可以同时对文件执行读操作</li>\n<li>只允许一个写者往文件中写信息</li>\n<li>任一写者在完成写操作之前不允许其他读者或写者工作</li>\n<li>写者执行写操作钱，应让已有的读者和写者全部退出</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"如何实现-2\"   >\n          <a href=\"#如何实现-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何实现-2\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore rw = <span class=\"number\">1</span>; <span class=\"comment\">//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;    <span class=\"comment\">//记录当前有几个进程在访问文件</span></span><br><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;  <span class=\"comment\">//用于保证对count变量的互斥访问</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">writer</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(rw);  <span class=\"comment\">//写之前“加锁”</span></span><br><span class=\"line\">    写文件;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(rw);  <span class=\"comment\">//写之后“解锁”</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">reader</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(mutex); <span class=\"comment\">//各读进程互斥访问count</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"built_in\">P</span>(rw);  <span class=\"comment\">//第一个读进程负责(加锁)</span></span><br><span class=\"line\">    count++;  <span class=\"comment\">//访问文件的读进程数+1</span></span><br><span class=\"line\">    <span class=\"built_in\">V</span>(mutex);</span><br><span class=\"line\">    读文件;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(mutex); <span class=\"comment\">//各读进程互斥访问count</span></span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"built_in\">V</span>(rw);  <span class=\"comment\">//最后一个读进程负责“解锁”</span></span><br><span class=\"line\">    <span class=\"built_in\">V</span>(mutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>思考：若两个读进程并发执行，则两个读进程有可能先后执行P(rw)，从而使第二个读进程阻塞的情况。</p>\n<p>如何解决：出现上述问题的原因在于对count变量的检查和复制无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程对count的访问是互斥的。</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore rw = <span class=\"number\">1</span>; <span class=\"comment\">//用于实现对文件的互斥访问</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;    <span class=\"comment\">//记录当前有几个读进程在访问文件</span></span><br><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;  <span class=\"comment\">//用于保证对count变量的互斥访问</span></span><br><span class=\"line\">semaphore w = <span class=\"number\">1</span>;  <span class=\"comment\">//用于实现“写优先”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">writer</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(w);</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(rw);</span><br><span class=\"line\">    写文件;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(rw);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(w);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">reader</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(w);</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(mutex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"built_in\">P</span>(rw);</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(mutex);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(w);</span><br><span class=\"line\">    读文件;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(mutex);</span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"built_in\">V</span>(rw);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(mutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"哲学家进餐问题\"   >\n          <a href=\"#哲学家进餐问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#哲学家进餐问题\" class=\"headerlink\" title=\"哲学家进餐问题\"></a>哲学家进餐问题</h1>\n      \n        <h2 id=\"问题描述-4\"   >\n          <a href=\"#问题描述-4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题描述-4\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2>\n      <p>一张圆桌上坐着5名哲学家，没两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>\n\n        <h2 id=\"问题分析-1\"   >\n          <a href=\"#问题分析-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题分析-1\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Pi</span>()&#123; <span class=\"comment\">//i号哲学家的进程</span></span><br><span class=\"line\">  <span class=\"built_in\">P</span>(chopstick[i]);  <span class=\"comment\">//拿左</span></span><br><span class=\"line\">  <span class=\"built_in\">P</span>(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);  <span class=\"comment\">//拿右</span></span><br><span class=\"line\">  吃饭;</span><br><span class=\"line\">  <span class=\"built_in\">V</span>(chopstick[i]);  <span class=\"comment\">//放左</span></span><br><span class=\"line\">  <span class=\"built_in\">V</span>(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);  <span class=\"comment\">//放右</span></span><br><span class=\"line\">  思考;</span><br><span class=\"line\">&#125; <span class=\"comment\">//但是如果所有哲学家同时拿起筷子，就会循环等待其他人放下</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>如何预防死锁的发生呢？<ol>\n<li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</li>\n<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li>\n<li>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;  <span class=\"comment\">//互斥地取筷子</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Pi</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(mutex);</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(chopstick[i]);  <span class=\"comment\">//拿左</span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);  <span class=\"comment\">//拿右</span></span><br><span class=\"line\">    <span class=\"built_in\">V</span>(mutex);</span><br><span class=\"line\">    吃饭;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(chopstick[i]);  <span class=\"comment\">//放左</span></span><br><span class=\"line\">    <span class=\"built_in\">V</span>(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);  <span class=\"comment\">//放右</span></span><br><span class=\"line\">    思考;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一般时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"管程\"   >\n          <a href=\"#管程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#管程\" class=\"headerlink\" title=\"管程\"></a>管程</h1>\n      <ul>\n<li>为什么要引入管程</li>\n<li>管程的定义和基本特征</li>\n<li>拓展1：用管程解决生产者消费问题</li>\n<li>拓展2：Java中类似于管程的机制</li>\n</ul>\n\n        <h2 id=\"为什么要引入管程\"   >\n          <a href=\"#为什么要引入管程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#为什么要引入管程\" class=\"headerlink\" title=\"为什么要引入管程\"></a>为什么要引入管程</h2>\n      <p>信号量机制存在的问题：编写程序困难，易出错。</p>\n<p>因此设计一种机制，让程序员写程序时不需要再灌注复杂的PV操作，让写代码更轻松。</p>\n\n        <h2 id=\"管程的定义和基本特征\"   >\n          <a href=\"#管程的定义和基本特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#管程的定义和基本特征\" class=\"headerlink\" title=\"管程的定义和基本特征\"></a>管程的定义和基本特征</h2>\n      <ul>\n<li>管程时一种特殊的软件模块，有这些组成部分：<ol>\n<li>局部于管程的<strong>共享数据结构</strong>说明</li>\n<li>对该数据结构进行操作的<strong>一组过程</strong></li>\n<li>对局部于管程的共享数据设置初始值的语句</li>\n<li>管程有一个名字</li>\n</ol>\n</li>\n</ul>\n<p>跨考Tips:“过程”其实就是“函数”</p>\n<ul>\n<li>管程的基本特征：<ol>\n<li>局部于管程的数据只能被局部于管程的过程所访问</li>\n<li>一个进程只通过管程内的过程才能进入管程访问共享数据</li>\n<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"拓展1：用管程解决生产者消费者问题\"   >\n          <a href=\"#拓展1：用管程解决生产者消费者问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#拓展1：用管程解决生产者消费者问题\" class=\"headerlink\" title=\"拓展1：用管程解决生产者消费者问题\"></a>拓展1：用管程解决生产者消费者问题</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">monitor ProducerConsumer</span><br><span class=\"line\">  condition full,empty; <span class=\"comment\">//条件变量用来实现同步(排队)</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//缓冲区中的产品数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Item item)</span></span>&#123; <span class=\"comment\">//把产品item放入缓冲区</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count == N)</span><br><span class=\"line\">      <span class=\"built_in\">wait</span>(full);</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"built_in\">insert_item</span>(item);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count == <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"built_in\">signal</span>(empty);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\">Item <span class=\"title\">remove</span><span class=\"params\">()</span></span>&#123;  <span class=\"comment\">//从缓冲区取出一个产品</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"built_in\">wait</span>(empty);</span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count == N<span class=\"number\">-1</span>)</span><br><span class=\"line\">      <span class=\"built_in\">signal</span>(full);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">remove_item</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">end monitor;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//生产者进程</span></span><br><span class=\"line\"><span class=\"built_in\">producer</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    item = 生产一个产品;</span><br><span class=\"line\">    ProdecerConsumer.<span class=\"built_in\">insert</span>(item);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">consumer</span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    item = ProdecerConsumer.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    消费产品item;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li><p>由编译器负责实现进程互斥地进入管程中的过程。</p>\n</li>\n<li><p>管程中设置条件变量和等待唤醒操作，以解决同步问题。</p>\n</li>\n<li><p>引入管程的目的无非就是要更方便地实现进程互斥和同步</p>\n<ol>\n<li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li>\n<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li>\n<li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></li>\n<li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。<strong>注意：这种互斥特性是由编译器负责实现的，程序员不用关心</strong>)</li>\n<li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>以解决同步问题。可以让一个进程或线程在条件变量上等待(<strong>此时，该进程应先释放管程的使用权，也就是让出“入口”</strong>)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"拓展2：Java中类似于管程的机制\"   >\n          <a href=\"#拓展2：Java中类似于管程的机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#拓展2：Java中类似于管程的机制\" class=\"headerlink\" title=\"拓展2：Java中类似于管程的机制\"></a>拓展2：Java中类似于管程的机制</h2>\n      <p>Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">monitor</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Item buffer[]=<span class=\"keyword\">new</span> Item[N];</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Item item)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>每次只能有一个进程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</p>\n<hr>\n<ul>\n<li>为什么要引入管程<ul>\n<li>解决信号量机制编程麻烦、易出错问题</li>\n</ul>\n</li>\n<li>组成<ul>\n<li>共享数据结构</li>\n<li>对数据结构初始化的语句</li>\n<li>一组用来访问数据结构的过程(函数)</li>\n</ul>\n</li>\n<li>基本特征<ul>\n<li>各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据</li>\n<li>每次仅允许一个进程在管程内执行某个内部过程</li>\n</ul>\n</li>\n<li>补充<ul>\n<li>各进程必须互斥地访问管程的特性是由编译器实现的</li>\n<li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题</li>\n</ul>\n</li>\n</ul>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【计算机操作系统】2-2-调度","url":"/Major-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912-2-%E8%B0%83%E5%BA%A6/","content":"\n        <h1 id=\"处理机调度的概念、层次\"   >\n          <a href=\"#处理机调度的概念、层次\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#处理机调度的概念、层次\" class=\"headerlink\" title=\"处理机调度的概念、层次\"></a>处理机调度的概念、层次</h1>\n      <ul>\n<li>基本概念</li>\n<li>三个层次<ul>\n<li>高级调度(作业调度)</li>\n<li>中级调度(内存调度)</li>\n<li>低级调度(进程调度)</li>\n</ul>\n</li>\n<li>三层调度的联系、对比</li>\n<li>补充知识<ul>\n<li>进程的“挂起态”</li>\n<li>七状态模型</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"调度的基本概念\"   >\n          <a href=\"#调度的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调度的基本概念\" class=\"headerlink\" title=\"调度的基本概念\"></a>调度的基本概念</h2>\n      <p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。</p>\n<p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p>\n<p><strong>处理机调度</strong>，就是从就绪队列中<strong>按照一定的算法选择一个进程</strong>并<strong>将处理机分配给它</strong>运行，以实现进程的并发执行。</p>\n\n        <h2 id=\"调度的三个层次——高级调度\"   >\n          <a href=\"#调度的三个层次——高级调度\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调度的三个层次——高级调度\" class=\"headerlink\" title=\"调度的三个层次——高级调度\"></a>调度的三个层次——高级调度</h2>\n      <p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>\n<p><strong>高级调度(作业调度)<strong>。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并</strong>建立相应的进程(建立PCB)<strong>，以使它们</strong>获得竞争处理机的权利</strong>。</p>\n<p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。<strong>作业调入时会建立相应的PCB，作业调出时才撤销PCB。</strong>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p>\n\n        <h2 id=\"调度的三个层次——中级调度\"   >\n          <a href=\"#调度的三个层次——中级调度\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调度的三个层次——中级调度\" class=\"headerlink\" title=\"调度的三个层次——中级调度\"></a>调度的三个层次——中级调度</h2>\n      <p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p>\n<p>这么做的目的是为了<strong>提高内存利用率</strong>和<strong>系统吞吐量</strong>。</p>\n<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。值得注意的是，<strong>PCB</strong>并不会一起调到外存，而是<strong>会常驻内存</strong>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的<strong>挂起队列</strong>中。</p>\n<p>**中级调度(内存调度)**，就是要决定将哪个处于挂起状态的进程重新调入内存。</p>\n<p>一个进程可能会被多次调出、调入内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong>。</p>\n\n        <h2 id=\"补充知识：进程的挂起状态与七状态模型\"   >\n          <a href=\"#补充知识：进程的挂起状态与七状态模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#补充知识：进程的挂起状态与七状态模型\" class=\"headerlink\" title=\"补充知识：进程的挂起状态与七状态模型\"></a>补充知识：进程的挂起状态与七状态模型</h2>\n      <p>暂时调到外存等待的进程状态为<strong>挂起状态(挂起态，suspend)</strong></p>\n<p>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态。</p>\n<p>注意“挂起”和“阻塞”的却别，两种状态都是暂时不能获得CPU的服务，但挂起状态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p>\n<p>有的操作系统会把就绪挂起、阻塞改期分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>\n\n        <h2 id=\"调度的三个层次——低级调度\"   >\n          <a href=\"#调度的三个层次——低级调度\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调度的三个层次——低级调度\" class=\"headerlink\" title=\"调度的三个层次——低级调度\"></a>调度的三个层次——低级调度</h2>\n      <p>**低级调度(进程调度)**，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>\n<p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。</p>\n<p>进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p>\n\n        <h2 id=\"三层调度的联系、对比\"   >\n          <a href=\"#三层调度的联系、对比\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三层调度的联系、对比\" class=\"headerlink\" title=\"三层调度的联系、对比\"></a>三层调度的联系、对比</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">要做什么</th>\n<th align=\"center\">调度发生在什么时候</th>\n<th align=\"center\">发生频率</th>\n<th align=\"center\">对进程状态的影响</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">高级调度(作业调度)</td>\n<td align=\"center\">按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>\n<td align=\"center\">外存-&gt;内存(面向作业)</td>\n<td align=\"center\">最低</td>\n<td align=\"center\">无-&gt;创建态-&gt;就绪态</td>\n</tr>\n<tr>\n<td align=\"center\">中级调度(内存调度)</td>\n<td align=\"center\">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>\n<td align=\"center\">外存-&gt;内存(面向进程)</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">挂起态-&gt;就绪态(阻塞挂起-&gt;阻塞态)</td>\n</tr>\n<tr>\n<td align=\"center\">低级调度(进程调度)</td>\n<td align=\"center\">按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>\n<td align=\"center\">内存-&gt;CPU</td>\n<td align=\"center\">最高</td>\n<td align=\"center\">就绪态-&gt;运行态</td>\n</tr>\n</tbody></table></div>\n\n        <h1 id=\"进程调度的时机、切换与过程调度方式\"   >\n          <a href=\"#进程调度的时机、切换与过程调度方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程调度的时机、切换与过程调度方式\" class=\"headerlink\" title=\"进程调度的时机、切换与过程调度方式\"></a>进程调度的时机、切换与过程调度方式</h1>\n      <ul>\n<li>时机<ul>\n<li>什么时候需要进程调度</li>\n<li>什么时候不能进行进程调度</li>\n</ul>\n</li>\n<li>切换与过程<ul>\n<li>“下一的调度”与“切换”的区别</li>\n<li>进程切换的过程需要做什么？</li>\n</ul>\n</li>\n<li>方式<ul>\n<li>非剥夺调度方式(非抢占式)</li>\n<li>剥夺调度方式(抢占式)</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"进程调度的时机\"   >\n          <a href=\"#进程调度的时机\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程调度的时机\" class=\"headerlink\" title=\"进程调度的时机\"></a>进程调度的时机</h2>\n      <p><strong>进程调度</strong>(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>\n<ul>\n<li>需要进行切换调度与切换的情况<ul>\n<li>当前运行的进程<strong>主动放弃</strong>处理机<ul>\n<li>运行正常终止</li>\n<li>运行过程中发生异常而终止</li>\n<li>进程主动请求阻塞(如等待I/O)</li>\n</ul>\n</li>\n<li>当前运行的进程<strong>被动放弃</strong>处理机<ul>\n<li>分给进程的时间片用完</li>\n<li>有更紧急的事需要处理(如I/O中断)</li>\n<li>有更高优先级的进程进入就绪队列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>不能进行进程调度与切换的情况<ol>\n<li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件模切相关，很难做到在中断处理过程中进行进程切换。</li>\n<li>进程在<strong>操作系统内核程序临界区</strong>中。一定是内核程序临界区！！！</li>\n<li>在**原子操作过程中(原语)。原子操作不可中断，要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)。</li>\n</ol>\n</li>\n</ul>\n<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<strong>互斥地</strong>访问临界资源。</p>\n<p>临界区：访问临界资源的那段代码。</p>\n<p><strong>内核程序临界区</strong>一般用来访问<strong>某种内核数据结构</strong>的，比如进程的就绪队列(由各就绪进程的PCB组成)</p>\n<p>如果还没退出临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，因此又无法顺利进行进程调度。</p>\n<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p>\n<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p>\n<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>\n\n        <h2 id=\"进程调度的方式\"   >\n          <a href=\"#进程调度的方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程调度的方式\" class=\"headerlink\" title=\"进程调度的方式\"></a>进程调度的方式</h2>\n      \n        <h3 id=\"非剥夺调度方式\"   >\n          <a href=\"#非剥夺调度方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#非剥夺调度方式\" class=\"headerlink\" title=\"非剥夺调度方式\"></a>非剥夺调度方式</h3>\n      <p>又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>\n<p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早起的批处理系统。</p>\n\n        <h3 id=\"剥夺调度方式\"   >\n          <a href=\"#剥夺调度方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#剥夺调度方式\" class=\"headerlink\" title=\"剥夺调度方式\"></a>剥夺调度方式</h3>\n      <p>又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或者更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>\n<p>可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统。</p>\n\n        <h2 id=\"进程的切换与过程\"   >\n          <a href=\"#进程的切换与过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的切换与过程\" class=\"headerlink\" title=\"进程的切换与过程\"></a>进程的切换与过程</h2>\n      <p>“狭义的进程调度”与“进程切换”的区别：</p>\n<p><strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。(这个进程可以是刚刚被暂停执行的进程)，<strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>\n<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>\n<p>进程切换的过程主要完成了：</p>\n<ol>\n<li>对原来运行进程各种数据的保存</li>\n<li>对新的进程各种数据的恢复</li>\n</ol>\n<p>(如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</p>\n<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁的</strong>进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>\n\n        <h1 id=\"调度算法的评价指标\"   >\n          <a href=\"#调度算法的评价指标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调度算法的评价指标\" class=\"headerlink\" title=\"调度算法的评价指标\"></a>调度算法的评价指标</h1>\n      <ul>\n<li>CPU利用率</li>\n<li>系统吞吐量</li>\n<li>周转时间<ul>\n<li>周转时间、平均周转时间</li>\n<li>带权周转时间、平均带权周转时间</li>\n</ul>\n</li>\n<li>等待时间</li>\n<li>响应时间</li>\n</ul>\n\n        <h2 id=\"CPU利用率\"   >\n          <a href=\"#CPU利用率\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#CPU利用率\" class=\"headerlink\" title=\"CPU利用率\"></a>CPU利用率</h2>\n      <p>由于早期的CPU造价及其昂贵，因此人们会<strong>希望让CPU尽可能多地工作</strong>。</p>\n<p>CPU利用率：指CPU“忙碌”的时间占总时间的比例。</p>\n<p><code>利用率=忙碌的时间/总时间</code></p>\n\n        <h2 id=\"系统吞吐量\"   >\n          <a href=\"#系统吞吐量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#系统吞吐量\" class=\"headerlink\" title=\"系统吞吐量\"></a>系统吞吐量</h2>\n      <p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业</p>\n<p>系统吞吐量：单位时间内完成作业的数量</p>\n<p><code>系统吞吐量=总共完成了多少道作业/总共花了多少时间</code></p>\n\n        <h2 id=\"周转时间\"   >\n          <a href=\"#周转时间\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#周转时间\" class=\"headerlink\" title=\"周转时间\"></a>周转时间</h2>\n      <p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>\n<p><strong>周转时间</strong>，是指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。</p>\n<p>它包括四个部分：作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个过程中，可能发生多次。</p>\n<p><code>周转时间=作业完成时间-作业提交时间</code></p>\n<p>对于用户来说，更关心自己的单个作业的周转时间。</p>\n<p><code>平均周转时间=各作业周转时间之和/作业数</code></p>\n<p>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值。</p>\n\n        <h2 id=\"带权周转时间\"   >\n          <a href=\"#带权周转时间\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#带权周转时间\" class=\"headerlink\" title=\"带权周转时间\"></a>带权周转时间</h2>\n      <p><code>带权周转时间=作业周转时间/作业实际运行的时间=(作业完成时间-作业提交时间)/作业实际运行的时间</code></p>\n<p>带权周转时间必然&gt;=1</p>\n<p>带权周转时间与周转时间都是越小越好</p>\n<p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。</p>\n<p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意读更高。</p>\n\n        <h2 id=\"等待时间\"   >\n          <a href=\"#等待时间\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#等待时间\" class=\"headerlink\" title=\"等待时间\"></a>等待时间</h2>\n      <p>计算机的用户希望自己的作业尽可能少的等待处理机</p>\n<p><strong>等待时间</strong>，指进程/作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>\n<p>作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被CPU服务、会被I/O设备服务，当然也会有<strong>等待被服务</strong>的时候。</p>\n<p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>\n<p>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong>。</p>\n<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<strong>平均等待时间</strong>”来评价整体性能。</p>\n\n        <h2 id=\"响应时间\"   >\n          <a href=\"#响应时间\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#响应时间\" class=\"headerlink\" title=\"响应时间\"></a>响应时间</h2>\n      <p>对于计算机用户来说，会希望自己的提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务、回应。</p>\n<p><strong>响应时间</strong>，指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p>\n\n        <h2 id=\"调度算法\"   >\n          <a href=\"#调度算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调度算法\" class=\"headerlink\" title=\"调度算法\"></a>调度算法</h2>\n      <ul>\n<li><p>先来先服务(FCFS)</p>\n</li>\n<li><p>短作业优先(SJF)</p>\n</li>\n<li><p>高响应比优先(HRRN)</p>\n</li>\n<li><p>各种调度算法的学习思路</p>\n<ol>\n<li>算法思想</li>\n<li>算法规则</li>\n<li>这种调度算法是用于 作业调度 还是 进程调度？</li>\n<li>抢占式？非抢占式？</li>\n<li>优点和缺点</li>\n<li>是否会导致<strong>饥饿</strong>(某进程/作业长期得不到服务)</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"先来先服务-FCFS\"   >\n          <a href=\"#先来先服务-FCFS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#先来先服务-FCFS\" class=\"headerlink\" title=\"先来先服务(FCFS)\"></a>先来先服务(FCFS)</h2>\n      <ul>\n<li>算法思想<ul>\n<li>主要从“公平”的角度考虑</li>\n</ul>\n</li>\n<li>算法规则<ul>\n<li>按照作业/进程到达的先后顺序进行服务</li>\n</ul>\n</li>\n<li>用于作业/进程调度<ul>\n<li>用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</li>\n</ul>\n</li>\n<li>是否可抢占？<ul>\n<li>非抢占式的算法</li>\n</ul>\n</li>\n<li>优缺点<ul>\n<li>优点：公平、算法实现简单</li>\n<li>缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。</li>\n</ul>\n</li>\n<li>是否会导致饥饿<ul>\n<li>不会</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"短作业优先-SJF\"   >\n          <a href=\"#短作业优先-SJF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#短作业优先-SJF\" class=\"headerlink\" title=\"短作业优先(SJF)\"></a>短作业优先(SJF)</h2>\n      <ul>\n<li>算法思想<ul>\n<li>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</li>\n</ul>\n</li>\n<li>算法规则<ul>\n<li>最短的作业/进程优先得到服务(所谓“最短”，是指要求服务时间最短)</li>\n</ul>\n</li>\n<li>用于作业/进程调度<ul>\n<li>即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF)算法”</li>\n</ul>\n</li>\n<li>是否可抢占<ul>\n<li>SJF和SPF是<strong>非抢占</strong>的算法。但是<strong>也有抢占式的版本——最短剩余时间优先算法(SRTN)</strong></li>\n</ul>\n</li>\n<li>优缺点<ul>\n<li>优点：“最短的”平均等待时间、平均周转时间</li>\n<li>缺点“不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</li>\n</ul>\n</li>\n<li>是否会导致饥饿<ul>\n<li>会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“<strong>饥饿</strong>”现象。如果一直得不到服务，则称为“<strong>饿死</strong>”。</li>\n</ul>\n</li>\n</ul>\n<p>最短剩余时间优先算法：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个<strong>进程完成时也需要调度</strong>。</p>\n<ul>\n<li>几个小细节：<ol>\n<li>如果题目中<strong>未特别说明</strong>，所提到的“短作业/进程优先算法”<strong>默认</strong>是<strong>非抢占式</strong>的。</li>\n<li>很多书上会说“SJF调度算法的平均等待时间、平均周转时间最少”。严格来说，这个表述是错误的，不严谨的。短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少。应该加上一个条件“在<strong>所有进程同时可运行</strong>时”，采用SJF调度算法的平均等待时间、平均周转时间最少；或者说“在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少”；如果不加上述前提条件，则应该说“<strong>抢占式的</strong>短作业/进程优先调度算法(<strong>最短剩余时间优先</strong>，SNRT算法)的平均等待时间、平均周转时间最少”</li>\n<li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法(如FCFS)，SJF依然可以获得较少的平均等待时间、平均周转时间。</li>\n<li>如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选线，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项。</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"对FCFS和SJF两种算法的思考\"   >\n          <a href=\"#对FCFS和SJF两种算法的思考\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#对FCFS和SJF两种算法的思考\" class=\"headerlink\" title=\"对FCFS和SJF两种算法的思考\"></a>对FCFS和SJF两种算法的思考</h2>\n      <p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业(进程)为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</p>\n<p>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。</p>\n\n        <h2 id=\"高响应比优先-HRRN\"   >\n          <a href=\"#高响应比优先-HRRN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#高响应比优先-HRRN\" class=\"headerlink\" title=\"高响应比优先(HRRN)\"></a>高响应比优先(HRRN)</h2>\n      <ul>\n<li>算法思想<ul>\n<li>要综合考虑作业/进程的等待时间和要求服务的时间</li>\n</ul>\n</li>\n<li>算法规则<ul>\n<li>在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高的</strong>作业/进程为其服务</li>\n<li><code>响应比=(等待时间+要求服务时间)/要求服务时间</code></li>\n<li>响应比必然&gt;=1</li>\n</ul>\n</li>\n<li>用于作业/进程调度<ul>\n<li>也可用于进程调度</li>\n</ul>\n</li>\n<li>是否可抢占？<ul>\n<li><strong>非抢占式</strong>的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。</li>\n</ul>\n</li>\n<li>优缺点<ul>\n<li>综合考虑了等待时间和运行时间(要求服务时间)</li>\n<li>等待时间相同时，要求服务时间短的优先(SJF的优点)</li>\n<li>要求服务时间相同时，等待时间长的优先(FCFS的优点)</li>\n<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>\n</ul>\n</li>\n<li>是否会导致饥饿<ul>\n<li>不会</li>\n</ul>\n</li>\n</ul>\n<p>高响应比优先算法：<strong>非抢占式</strong>的调度算法，只有当前运行的进程<strong>主动放弃CPU时</strong>(正常/异步完成，或主动阻塞)，才需要进程调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的</strong>进程上处理机。</p>\n<hr>\n<p>这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急成都，因此对于用户来说，交换性很糟糕。因此这三种算法一般适合用于<strong>早起的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>\n\n        <h1 id=\"调度算法-1\"   >\n          <a href=\"#调度算法-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调度算法-1\" class=\"headerlink\" title=\"调度算法\"></a>调度算法</h1>\n      <ul>\n<li><p>时间片轮转调度算法(RR)</p>\n</li>\n<li><p>优先级调度算法</p>\n</li>\n<li><p>多级反馈队列调度算法</p>\n</li>\n<li><p>各种调度算法的学习思路</p>\n<ol>\n<li>算法思路</li>\n<li>算法规则</li>\n<li>这种调度算法是用于 作业调度 还是 进程调度</li>\n<li>抢占式？非抢占式？</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"时间片轮转-RR\"   >\n          <a href=\"#时间片轮转-RR\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#时间片轮转-RR\" class=\"headerlink\" title=\"时间片轮转(RR)\"></a>时间片轮转(RR)</h2>\n      <ul>\n<li>算法思想<ul>\n<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>\n</ul>\n</li>\n<li>算法规则<ul>\n<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。</li>\n</ul>\n</li>\n<li>用于作业/进程调度<ul>\n<li>用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</li>\n</ul>\n</li>\n<li>是否可抢占？<ul>\n<li>若进程未能在时间片内运行完，将被强心剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到。</li>\n</ul>\n</li>\n<li>优缺点<ul>\n<li>优点：公平；响应快，适用于分时操作系统。</li>\n<li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>\n</ul>\n</li>\n<li>是否会导致饥饿<ul>\n<li>不会</li>\n</ul>\n</li>\n</ul>\n<p>常用于分时操作系统，更注重“响应时间”。</p>\n<p>如果<strong>时间片太大</strong>，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法将<strong>退化为先来先服务</strong>调度算法，并且<strong>会增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。</p>\n<p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果<strong>时间片太小</strong>，会导致<strong>进程切换过于频繁</strong>，系统会话大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<strong>时间片也不能太小</strong>。</p>\n\n        <h2 id=\"优先级调度算法\"   >\n          <a href=\"#优先级调度算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#优先级调度算法\" class=\"headerlink\" title=\"优先级调度算法\"></a>优先级调度算法</h2>\n      <ul>\n<li>算法思想<ul>\n<li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</li>\n</ul>\n</li>\n<li>算法规则<ul>\n<li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。</li>\n</ul>\n</li>\n<li>用于作业/进程调度<ul>\n<li>即可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中。</li>\n</ul>\n</li>\n<li>是否可抢占<ul>\n<li>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</li>\n</ul>\n</li>\n<li>优缺点<ul>\n<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li>\n<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。</li>\n</ul>\n</li>\n<li>是否会导致饥饿<ul>\n<li>会</li>\n</ul>\n</li>\n</ul>\n<p>抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>地进程。当前进程<strong>主动放弃处理机时</strong>发生调度。另外，当<strong>就绪队列发生改变时</strong>也需要检查是否会发生抢占。</p>\n<p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。</p>\n<p>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种。</p>\n<ul>\n<li><p>静态优先级：创建进程时确定，之后一直不变。</p>\n</li>\n<li><p>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p>\n</li>\n<li><p>通常</p>\n<ul>\n<li>系统进程优先级<strong>高于</strong>用户进程</li>\n<li>前台进程优先级<strong>高于</strong>后台进程</li>\n<li>操作系统更<strong>偏好I/O型进程(或称I/O繁忙型进程)</strong></li>\n</ul>\n</li>\n</ul>\n<p>注：与I/O型进程相对的是<strong>计算型进程(活成CPU繁忙型进程)</strong></p>\n<p>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。</p>\n<ul>\n<li>可以从追求公平、提升资源利用率等角度考虑<ul>\n<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li>\n<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>\n<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"多级反馈队列调度算法\"   >\n          <a href=\"#多级反馈队列调度算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多级反馈队列调度算法\" class=\"headerlink\" title=\"多级反馈队列调度算法\"></a>多级反馈队列调度算法</h2>\n      <ul>\n<li>算法思想<ul>\n<li>对其他调度算法的这种权衡</li>\n</ul>\n</li>\n<li>算法规则<ol>\n<li>设置多级就绪队列，各队列优先级从高到低，时间片从小到大</li>\n<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。</li>\n<li>只有第K级队列为空时，才会为K+1级队头的进程分配时间片</li>\n</ol>\n</li>\n<li>用于作业/进程调度<ul>\n<li>用于进程调度</li>\n</ul>\n</li>\n<li>是否可抢占？<ul>\n<li>抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</li>\n</ul>\n</li>\n<li>优缺点<ul>\n<li>对各类型进程相对公平(FCFS的优点)</li>\n<li>每个新到达的进程都可以很快就得到响应(RR的优点)</li>\n<li>短进程只用较少的时间就可完成(SPF的优点)</li>\n<li>不必实现估计进程的运行时间(避免用户作假)</li>\n<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)</li>\n</ul>\n</li>\n<li>是否会导致饥饿<ul>\n<li>会</li>\n</ul>\n</li>\n</ul>\n<p>设置多级就绪队列，各级队列<strong>优先级</strong>从<strong>高到底</strong>，<strong>时间片</strong>从<strong>小到大</strong></p>\n<p><strong>新进程</strong>到达时<strong>先进入第1级</strong>队列，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程<strong>还未结束</strong>，则进程<strong>进入下一级队列队尾</strong>。如果此时<strong>已经在最下级</strong>的队列，则<strong>重新放回</strong>最下级队列队尾。</p>\n<p>只有第<strong>k级队列为空</strong>时，才会<strong>为k+1级</strong>队头的进程<strong>分配时间片</strong>。</p>\n<p>被抢占处理机的进程重新放回原队列队尾。</p>\n<hr>\n<p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统(包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于<strong>交互式</strong>系统。(比如UNIX使用的就是多级反馈队列调度算法)</p>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【计算机操作系统】2-4-死锁","url":"/Major-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912-4-%E6%AD%BB%E9%94%81/","content":"\n        <h1 id=\"死锁的概念\"   >\n          <a href=\"#死锁的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁的概念\" class=\"headerlink\" title=\"死锁的概念\"></a>死锁的概念</h1>\n      <ul>\n<li>什么是死锁</li>\n<li>进程死锁、饥饿、死循环的区别</li>\n<li>死锁产生的必要条件</li>\n<li>什么时候会发生死锁</li>\n<li>死锁的处理策略</li>\n</ul>\n\n        <h2 id=\"什么是死锁\"   >\n          <a href=\"#什么是死锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h2>\n      <p>每个人都占有一个资源，同时又在等待另一个人手里的寺院。发生“死锁”。</p>\n<p>在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong>，就是“死锁”。发生死锁后若无外力干涉，这些进程都讲无法向前推进。</p>\n\n        <h2 id=\"死锁、饥饿、死循环的区别\"   >\n          <a href=\"#死锁、饥饿、死循环的区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁、饥饿、死循环的区别\" class=\"headerlink\" title=\"死锁、饥饿、死循环的区别\"></a>死锁、饥饿、死循环的区别</h2>\n      <p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p>\n<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p>\n<p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时时因为程序逻辑bug导致的，有时时程序员故意设计的。</p>\n<ul>\n<li>区别<ul>\n<li>死锁至少有两个或两个以上的进程同时发生死锁。</li>\n<li>饥饿可能只有一个进程发生饥饿，既可能时阻塞态，也可能是就绪态。</li>\n<li>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"死锁产生的必要条件\"   >\n          <a href=\"#死锁产生的必要条件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁产生的必要条件\" class=\"headerlink\" title=\"死锁产生的必要条件\"></a>死锁产生的必要条件</h2>\n      <ul>\n<li>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。<ol>\n<li>互斥条件：只有必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。</li>\n<li>不剥夺条件：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放。</li>\n<li>请求和保持条件：进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占用，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</li>\n<li>循环等待条件：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>\n</ol>\n</li>\n</ul>\n<p><strong>发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong></p>\n<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>\n\n        <h2 id=\"什么时候会发生死锁\"   >\n          <a href=\"#什么时候会发生死锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么时候会发生死锁\" class=\"headerlink\" title=\"什么时候会发生死锁\"></a>什么时候会发生死锁</h2>\n      <ol>\n<li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。</li>\n<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如：并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>\n<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号、同步信号量也看做时一种抽象的系统资源)</li>\n</ol>\n<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>\n\n        <h2 id=\"死锁的处理策略\"   >\n          <a href=\"#死锁的处理策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁的处理策略\" class=\"headerlink\" title=\"死锁的处理策略\"></a>死锁的处理策略</h2>\n      <ol>\n<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>\n<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li>\n<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>\n</ol>\n<hr>\n<ul>\n<li>什么是死锁<ul>\n<li>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进</li>\n</ul>\n</li>\n<li>死锁、饥饿、死循环的区别<ul>\n<li>死锁：至少两个进程一起死锁，死锁处于阻塞态</li>\n<li>饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪</li>\n<li>死循环：可能只有一个进程发生死循环，死循环的进程可上处理机</li>\n<li>死锁和饥饿时操作系统要解决的问题，死循环是应用程序员要解决的</li>\n</ul>\n</li>\n<li>死锁产生的必要条件<ul>\n<li>互斥条件<ul>\n<li>对必须互斥使用的资源的争抢才会导致死锁</li>\n</ul>\n</li>\n<li>不剥夺条件<ul>\n<li>进程保持的资源只能主动释放，不可强行剥夺</li>\n</ul>\n</li>\n<li>请求和保持条件<ul>\n<li>保持着某些资源不放的同时，请求别的资源</li>\n</ul>\n</li>\n<li>循环等待条件<ul>\n<li>存在一种进程资源的循环等待链</li>\n<li>循环等待未必死锁，死锁一定有循环等待</li>\n</ul>\n</li>\n<li>什么时候会发生死锁<ul>\n<li>对不可剥夺资源的不合理分配，可能导致死锁</li>\n</ul>\n</li>\n<li>死锁的处理策略<ul>\n<li>预防死锁<ul>\n<li>破坏死锁产生的四个必要条件</li>\n</ul>\n</li>\n<li>避免死锁<ul>\n<li>避免系统进入不安全状态(银行家算法)</li>\n</ul>\n</li>\n<li>死锁的检测和解除<ul>\n<li>允许死锁发生，系统负责检测出死锁并解除。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"死锁的处理策略——预防死锁\"   >\n          <a href=\"#死锁的处理策略——预防死锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁的处理策略——预防死锁\" class=\"headerlink\" title=\"死锁的处理策略——预防死锁\"></a>死锁的处理策略——预防死锁</h1>\n      <ul>\n<li>不允许死锁发生<ul>\n<li>静态策略：预防死锁<ul>\n<li>破坏互斥条件</li>\n<li>破坏不剥夺条件</li>\n<li>破坏请求和保持条件</li>\n<li>破坏循环等待条件</li>\n</ul>\n</li>\n<li>动态策略：避免死锁</li>\n</ul>\n</li>\n<li>允许思死锁发生<ul>\n<li>死锁的检测和解锁</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"破坏互斥条件\"   >\n          <a href=\"#破坏互斥条件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#破坏互斥条件\" class=\"headerlink\" title=\"破坏互斥条件\"></a>破坏互斥条件</h2>\n      <p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</p>\n<p>如果把只能互斥使用的资源改为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造为共享设备……</p>\n<p>使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接受处理了，不需要再阻塞等待。</p>\n<p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</p>\n\n        <h2 id=\"破坏不剥夺条件\"   >\n          <a href=\"#破坏不剥夺条件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#破坏不剥夺条件\" class=\"headerlink\" title=\"破坏不剥夺条件\"></a>破坏不剥夺条件</h2>\n      <p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>\n<p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>\n<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p>\n<ul>\n<li>该策略的缺点<ol>\n<li>实现起来比较复杂</li>\n<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li>\n<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>\n<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"破坏请求和保持条件\"   >\n          <a href=\"#破坏请求和保持条件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#破坏请求和保持条件\" class=\"headerlink\" title=\"破坏请求和保持条件\"></a>破坏请求和保持条件</h2>\n      <p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</p>\n<p>可以<strong>采用静态分配方法</strong>，即使进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>\n<ul>\n<li>该策略实现起来简单，但也有明显的缺点：<ul>\n<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有<strong>可能导致某些进程饥饿</strong>。使用资源种类和数量越多的进程就越容易出现饥饿。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"破坏循环等待条件\"   >\n          <a href=\"#破坏循环等待条件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#破坏循环等待条件\" class=\"headerlink\" title=\"破坏循环等待条件\"></a>破坏循环等待条件</h2>\n      <p>循环等待条件：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>\n<p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>，同类资源(即编号相同的资源)一次申请完。</p>\n<p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而不会产生循环等待的现象。</p>\n<p>在任何一个时刻，总有一个进程拥有资源编号时最大的，那这个进程申请之后的资源必然畅通无阻。因此不可能出现所有进程都阻塞的死锁现象。</p>\n<ul>\n<li>该策略的缺点：<ol>\n<li>不方便增加新的设备，因为可能需要重新分配所有编号</li>\n<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费。</li>\n<li>必须按规定次序申请资源，用户编程麻烦。</li>\n</ol>\n</li>\n</ul>\n<hr>\n\n        <h2 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>破坏互斥条件<ul>\n<li>将临街资源改造为可共享使用的资源</li>\n<li>缺点：可行性不高，很多时候无法破坏互斥条件</li>\n</ul>\n</li>\n<li>破坏不剥夺条件<ol>\n<li>申请的资源得不到满足时，立即释放所有的资源</li>\n<li>申请的资源被其他进程占用时，由操作系统协助剥夺(考虑优先级)</li>\n</ol>\n<ul>\n<li>缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿。</li>\n</ul>\n</li>\n<li>破坏请求和保持条件<ul>\n<li>运行前分配好所有需要的资源，之后一直保持</li>\n<li>缺点：资源资利用率低；可能导致饥饿</li>\n</ul>\n</li>\n<li>破坏循环等待条件<ul>\n<li>给资源编号必须按编号从小到大的顺序申请资源</li>\n<li>缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"死锁的处理策略——避免死锁\"   >\n          <a href=\"#死锁的处理策略——避免死锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁的处理策略——避免死锁\" class=\"headerlink\" title=\"死锁的处理策略——避免死锁\"></a>死锁的处理策略——避免死锁</h1>\n      <ul>\n<li>不允许死锁发生<ul>\n<li>静态策略：预防死锁</li>\n<li>动态策略：避免死锁<ul>\n<li>什么是安全序列</li>\n<li>什么是系统的不安全状态，与死锁有何联系</li>\n<li>如何避免系统进入不安全状态——银行家算法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>允许死锁发生<ul>\n<li>死锁的检测和解除</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"什么是安全序列\"   >\n          <a href=\"#什么是安全序列\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是安全序列\" class=\"headerlink\" title=\"什么是安全序列\"></a>什么是安全序列</h2>\n      <p>所谓安全序列，就是指如果系统按照这种序列分配资源则每个进程都能顺利完成，只能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。</p>\n<p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利执行下去。当然，如果有进程提前归还了一些资源，那<strong>系统也有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</p>\n\n        <h2 id=\"安全序列、不安全状态、死锁的联系\"   >\n          <a href=\"#安全序列、不安全状态、死锁的联系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#安全序列、不安全状态、死锁的联系\" class=\"headerlink\" title=\"安全序列、不安全状态、死锁的联系\"></a>安全序列、不安全状态、死锁的联系</h2>\n      <p>如果系统处于<strong>安全状态</strong>，就<strong>一定不会</strong>发生<strong>死锁</strong>。如果系统进入<strong>不安全状态</strong>，就<strong>可能</strong>发生<strong>死锁</strong>(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</p>\n<p>因此可在<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求。这也是“<strong>银行家算法</strong>”的核心思想。</p>\n\n        <h2 id=\"银行家算法\"   >\n          <a href=\"#银行家算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h2>\n      <p>银行家算法时荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况，后来该算法被用在操作系统中，用于<strong>避免死锁</strong>。</p>\n<p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>\n<hr>\n\n        <h2 id=\"总结-1\"   >\n          <a href=\"#总结-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li><p>数据结构</p>\n<ul>\n<li>长度为m的以为数组Avaliable表示还有多少可用资源</li>\n<li>n*m矩阵Max表示各进程对资源的最大需求数</li>\n<li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li>\n<li><code>Max-Allocation=Need</code>矩阵表示各进程自多还需要多少资源</li>\n<li>用长度为m的一维数组Request表示进程此次申请的各种资源数</li>\n</ul>\n</li>\n<li><p>银行家算法步骤</p>\n<ol>\n<li>检查此次申请是否超过了之前声明的最大需求数</li>\n<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>\n<li>试探着分配，更改各数据结构</li>\n<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>\n</ol>\n</li>\n<li><p>安全性算法步骤：</p>\n<ul>\n<li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li>\n<li>不断重复上述过程，看最终能否让所有进程都加入安全序列。</li>\n</ul>\n</li>\n</ul>\n<p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</p>\n\n        <h1 id=\"死锁的处理策略——检测和解除\"   >\n          <a href=\"#死锁的处理策略——检测和解除\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁的处理策略——检测和解除\" class=\"headerlink\" title=\"死锁的处理策略——检测和解除\"></a>死锁的处理策略——检测和解除</h1>\n      <ul>\n<li><p>不允许死锁发生</p>\n<ul>\n<li>静态策略：预防死锁</li>\n<li>动态策略：避免死锁</li>\n</ul>\n</li>\n<li><p>允许死锁发生</p>\n<ul>\n<li>死锁的检测和解除<ul>\n<li>死锁的检测</li>\n<li>死锁的解除</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很<strong>可能发生死锁</strong>。在这种情况下，系统应当提供两个算法：</p>\n<ol>\n<li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li>\n<li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"死锁的检测\"   >\n          <a href=\"#死锁的检测\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁的检测\" class=\"headerlink\" title=\"死锁的检测\"></a>死锁的检测</h2>\n      <ul>\n<li><p>为了能对系统是否已发生了死锁进行检测，必须：</p>\n<ol>\n<li>用<strong>某种数据结构</strong>来保存资源的请求和分配信息</li>\n<li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态。</li>\n</ol>\n</li>\n<li><p>数据结构：资源分配图</p>\n<ul>\n<li>两种结点<ul>\n<li>进程结点：对应一个进程</li>\n<li>资源结点：对应一类资源，一类资源可能有多个</li>\n</ul>\n</li>\n<li>两种边<ul>\n<li>进程结点-&gt;资源结点：表示进程想申请几个资源(每条边代表一个)</li>\n<li>资源结点-&gt;进程结点：表示已经为进程分配了几个资源(每边代表一个)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>一般用矩形表示资源结点，矩形中的小圆代表该类资源的数量。</p>\n<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时时不会阻塞的，可以顺利地实行下去。</p>\n<p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。</p>\n<p>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程……</p>\n<p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>(详单与找到了一个安全序列)</p>\n<p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong>。</p>\n<p><strong>最终还连着边的那些进程就是处于死锁状态的进程</strong>。</p>\n<p>死锁定理：如果某时刻系统的资源分配图是<strong>不完全可简化</strong>的，那么此时系统<strong>死锁了</strong></p>\n\n        <h2 id=\"死锁的解除\"   >\n          <a href=\"#死锁的解除\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#死锁的解除\" class=\"headerlink\" title=\"死锁的解除\"></a>死锁的解除</h2>\n      <p>一旦检测出死锁的发生，就应该立即解除死锁。</p>\n<p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p>\n<ul>\n<li><p>解除死锁的主要方法有：</p>\n<ol>\n<li>资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>\n<li>撤销进程法(或称终止进程法)：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点时实现简单，但付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦终止可谓功亏一篑，以后还得从头再来。</li>\n<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>\n</ol>\n</li>\n<li><p>如何决定对谁动手？</p>\n<ul>\n<li>进程优先级</li>\n<li>已执行多长时间</li>\n<li>还要多久能完成</li>\n<li>进程已经使用了多少资源</li>\n<li>进程是交互式的还是批处理式的</li>\n</ul>\n</li>\n</ul>\n<hr>\n\n        <h2 id=\"总结-2\"   >\n          <a href=\"#总结-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>如何检测<ul>\n<li>数据结构：资源分配图<ul>\n<li>两种结点<ul>\n<li>进程结点</li>\n<li>资源结点</li>\n</ul>\n</li>\n<li>两种边<ul>\n<li>进程结点-&gt;资源结点(请求边)</li>\n<li>资源结点-&gt;进程结点(分配边)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>死锁检测算法<ul>\n<li>依次消除于不阻塞进程相连的边，直到无边可消</li>\n<li>注：所谓不阻塞进程是指其申请的资源数还足够的进程</li>\n<li>死锁定理：若资源分配图是不完全简化的，说明发生了死锁</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如何解锁<ul>\n<li>资源剥夺法</li>\n<li>撤销进程法(终止进程法)</li>\n<li>进程回退法</li>\n</ul>\n</li>\n</ul>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【计算机操作系统】3-1-内存管理","url":"/Major-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"\n        <h1 id=\"内存的基础知识\"   >\n          <a href=\"#内存的基础知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内存的基础知识\" class=\"headerlink\" title=\"内存的基础知识\"></a>内存的基础知识</h1>\n      <ul>\n<li>什么是内存，有何作用<ul>\n<li>存储单元</li>\n<li>内存地址</li>\n</ul>\n</li>\n<li>进程运行的基本原理<ul>\n<li>指令的工作原理</li>\n<li>逻辑地址 vs 物理地址</li>\n<li>从写程序到程序运行：编辑—编译—链接—装入</li>\n<li>三种链接方式</li>\n<li>三种装入方式</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"什么是内存？有何作用？\"   >\n          <a href=\"#什么是内存？有何作用？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是内存？有何作用？\" class=\"headerlink\" title=\"什么是内存？有何作用？\"></a>什么是内存？有何作用？</h2>\n      <p>内存是用于存放数据的硬件。程序执行前<strong>需要先放到内存中才能被CPU处理</strong>。</p>\n<p>内存地址从0开始，每个地址对应一个存储单元。</p>\n<p>内存中也有一个一个的“小房间”，每个房间就是一个“存储单元”。</p>\n<p>如果计算机“<strong>按字节编址</strong>”，则<strong>每个存储单元大小为1字节</strong>，即1B，即8各二进制位。</p>\n<p>如果字长为16位的计算机“<strong>按字编址</strong>”，则<strong>每个存储单位大小为1个字</strong>；每个字的大小为16各二进制位。</p>\n\n        <h2 id=\"进程的运行原理——指令\"   >\n          <a href=\"#进程的运行原理——指令\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#进程的运行原理——指令\" class=\"headerlink\" title=\"进程的运行原理——指令\"></a>进程的运行原理——指令</h2>\n      <p>我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据，这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量x的实际存放地址(<strong>物理地址</strong>)。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成指令中一般是使用<strong>逻辑地址(相对地址)</strong></p>\n\n        <h2 id=\"逻辑地址-vs-物理地址\"   >\n          <a href=\"#逻辑地址-vs-物理地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#逻辑地址-vs-物理地址\" class=\"headerlink\" title=\"逻辑地址 vs 物理地址\"></a>逻辑地址 vs 物理地址</h2>\n      <p>指令中的地址也可以采用这种思想。编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</p>\n<p>Eg:编译时只需确定变量x存放的地址是100(也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p>\n<p><strong>相对地址</strong>又称<strong>逻辑地址</strong>，<strong>绝对地址</strong>又称<strong>物理地址</strong>。</p>\n\n        <h2 id=\"从写程序到程序运行\"   >\n          <a href=\"#从写程序到程序运行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#从写程序到程序运行\" class=\"headerlink\" title=\"从写程序到程序运行\"></a>从写程序到程序运行</h2>\n      <ul>\n<li>编译：由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言<strong>翻译成机器语言</strong>)</li>\n<li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</li>\n<li>装入(装载)：由装入程序将装入模块装入内存运行。</li>\n</ul>\n\n        <h2 id=\"装入模块装入内存\"   >\n          <a href=\"#装入模块装入内存\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#装入模块装入内存\" class=\"headerlink\" title=\"装入模块装入内存\"></a>装入模块装入内存</h2>\n      <p>装入模块中的指令地址指的是“相对地址”，即：相对于开始地址而言的地址。相对地址又称逻辑地址。</p>\n<ul>\n<li>装入的三种方式(用三种不同的方法完成<strong>逻辑地址到物理地址的转换</strong>)：<ol>\n<li>绝对装入</li>\n<li>静态重定位</li>\n<li>动态重定位</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"装入的三种方式——绝对装入\"   >\n          <a href=\"#装入的三种方式——绝对装入\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#装入的三种方式——绝对装入\" class=\"headerlink\" title=\"装入的三种方式——绝对装入\"></a>装入的三种方式——绝对装入</h2>\n      <p>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码</p>\n<p>编译、链接后得到的装入模块的指令直接就使用了绝对地址。</p>\n<p><strong>绝对装入只适用于单道程序环境。</strong></p>\n<p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</p>\n\n        <h2 id=\"装入的三种方式——静态重定位\"   >\n          <a href=\"#装入的三种方式——静态重定位\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#装入的三种方式——静态重定位\" class=\"headerlink\" title=\"装入的三种方式——静态重定位\"></a>装入的三种方式——静态重定位</h2>\n      <p>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“<strong>重定位</strong>”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。</p>\n<p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</p>\n<p>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p>\n\n        <h2 id=\"装入的三种方式——动态重定位\"   >\n          <a href=\"#装入的三种方式——动态重定位\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#装入的三种方式——动态重定位\" class=\"headerlink\" title=\"装入的三种方式——动态重定位\"></a>装入的三种方式——动态重定位</h2>\n      <p>动态重定位：又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p>\n<p>重定位寄存器：存放装入模块存放的<strong>起始位置</strong>。</p>\n<p>采用动态重定位时<strong>允许程序在内存中发生移动</strong>。并且可将程序分配到不连续的存储区中；在程序运行期那只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存：便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>\n\n        <h2 id=\"链接的三种方式\"   >\n          <a href=\"#链接的三种方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#链接的三种方式\" class=\"headerlink\" title=\"链接的三种方式\"></a>链接的三种方式</h2>\n      <ol>\n<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接程一个完整的可执行文件(装入模块)，之后不再拆开。</li>\n<li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。</li>\n<li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li>\n</ol>\n<hr>\n\n        <h2 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>什么是内存，有何作用<ul>\n<li>存储单元、内存地址的概念和联系</li>\n<li>按字节编址vs按字编址</li>\n</ul>\n</li>\n<li>进程运行的基本原理<ul>\n<li>指令的工作原理<ul>\n<li>操作码+若干参数(可能包含地址参数)</li>\n</ul>\n</li>\n<li>逻辑地址 vs 物理地址</li>\n<li>从写程序到程序运行<ul>\n<li>编辑源代码文件</li>\n<li>编译<ul>\n<li>由源代码文件生成目标模块(高级语言“翻译”为机器语言)</li>\n</ul>\n</li>\n<li>链接<ul>\n<li>由目标模块生成装入模块，链接后形成完整的逻辑地址</li>\n</ul>\n</li>\n<li>装入<ul>\n<li>将装入模块装入内存，装入后形成物理地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>三种链接方式<ul>\n<li>静态链接<ul>\n<li>装入前链接成一个完整装入模块</li>\n</ul>\n</li>\n<li>装入时动态链接<ul>\n<li>运行前边装入边链接</li>\n</ul>\n</li>\n<li>运行时动态链接<ul>\n<li>运行时需要目标模块才装入并链接</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>三种装入方式<ul>\n<li>绝对装入<ul>\n<li>编译时产生绝对地址</li>\n</ul>\n</li>\n<li>可重定位装入<ul>\n<li>装入时将逻辑地址转换为物理地址</li>\n</ul>\n</li>\n<li>动态运行时装入<ul>\n<li>运行时将逻辑地址转换为物理地址，需要设置重定位寄存器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"内存管理的概念\"   >\n          <a href=\"#内存管理的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内存管理的概念\" class=\"headerlink\" title=\"内存管理的概念\"></a>内存管理的概念</h1>\n      <ul>\n<li>内存空间的分配与回收</li>\n<li>内存空间的扩充</li>\n<li>地址转换</li>\n<li>存储保护</li>\n</ul>\n\n        <h2 id=\"内存空间的分配与回收\"   >\n          <a href=\"#内存空间的分配与回收\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内存空间的分配与回收\" class=\"headerlink\" title=\"内存空间的分配与回收\"></a>内存空间的分配与回收</h2>\n      <p>操作系统负责<strong>内存空间的分配于回收</strong></p>\n\n        <h2 id=\"内存空间的扩展\"   >\n          <a href=\"#内存空间的扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内存空间的扩展\" class=\"headerlink\" title=\"内存空间的扩展\"></a>内存空间的扩展</h2>\n      <p>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong>。</p>\n\n        <h2 id=\"地址转换\"   >\n          <a href=\"#地址转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#地址转换\" class=\"headerlink\" title=\"地址转换\"></a>地址转换</h2>\n      <p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要注意物理内存的实际情况。</p>\n<p>操作系统需要提供地址转换功能，负责程序的逻辑地址于物理地址的转换。</p>\n<ul>\n<li>三种装入方式</li>\n</ul>\n\n        <h2 id=\"内存保护\"   >\n          <a href=\"#内存保护\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#内存保护\" class=\"headerlink\" title=\"内存保护\"></a>内存保护</h2>\n      <p>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</p>\n<ul>\n<li>内存保护可采取两种方法：<ol>\n<li>在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li>\n<li>采用<strong>重定位寄存器</strong>(又称<strong>基址寄存器</strong>)和<strong>界地址寄存器</strong>(又称<strong>限长寄存器</strong>)进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</li>\n</ol>\n</li>\n</ul>\n<hr>\n\n        <h2 id=\"总结-1\"   >\n          <a href=\"#总结-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>内存空间的分配与回收</li>\n<li>内存空间的扩充(实现虚拟性)</li>\n<li>地址转换<ul>\n<li>操作系统负责实现逻辑地址到物理地址的转换</li>\n<li>三种方式<ul>\n<li>绝对装入</li>\n<li>可重定位装入</li>\n<li>动态运行时装入</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>存储保护<ul>\n<li>保证各进程在自己的内存空间内运行，不会越界访问</li>\n<li>两种方式<ul>\n<li>设置上下限寄存器</li>\n<li>利用重定位寄存器、界地址寄存器进行判断</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"覆盖与交换\"   >\n          <a href=\"#覆盖与交换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#覆盖与交换\" class=\"headerlink\" title=\"覆盖与交换\"></a>覆盖与交换</h1>\n      <ul>\n<li>内存空间的分配与回收</li>\n<li>内存空间的扩充<ul>\n<li>覆盖技术</li>\n<li>交换技术</li>\n<li>虚拟存储技术</li>\n</ul>\n</li>\n<li>地址转换</li>\n<li>存储保护</li>\n</ul>\n\n        <h2 id=\"覆盖技术\"   >\n          <a href=\"#覆盖技术\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#覆盖技术\" class=\"headerlink\" title=\"覆盖技术\"></a>覆盖技术</h2>\n      <p>早期的计算机内存很小，比如IBM推出的第一台PC机最大只有1MB大小的内存。因此经常会出现内存大小不够的情况。</p>\n<p>后来人们引入了<strong>覆盖技术</strong>，用来<strong>解决“程序大小超过物理内存总和”的问题</strong>。</p>\n<p>覆盖技术的思想：将<strong>程序分为多个段</strong>(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。</p>\n<p>内存中分为<strong>一个“固定区”</strong>和<strong>若干个“覆盖区”</strong>。</p>\n<p>需要常驻内存的段放在“<strong>固定区</strong>”中，<strong>调入后就不再调出</strong>(除非运行结束)</p>\n<p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区。</p>\n<p><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。</p>\n<p>缺点：对用户不透明，增加了用户编程负担。</p>\n<p>覆盖技术只用于早期的操作系统中，现在已成为历史。</p>\n\n        <h2 id=\"交换技术\"   >\n          <a href=\"#交换技术\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#交换技术\" class=\"headerlink\" title=\"交换技术\"></a>交换技术</h2>\n      <p>交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存(进程在内存与磁盘间动态调度)</p>\n<p>**中级调度(内存调度)**，就是要决定将哪个处于挂起状态的进程重新调入内存。</p>\n<p>暂时换出外存等待的进程状态为<strong>挂起状态(挂起态,suspend)</strong></p>\n<p>挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态。</p>\n<ol>\n<li><p>应该在外存(磁盘)的什么位置保存被换出的进程？</p>\n</li>\n<li><p>什么时候应该交换？</p>\n</li>\n<li><p>应该换出哪些进程？</p>\n</li>\n<li><p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>。总之，<strong>对换区的I/O速度比文件区的更快</strong>。</p>\n</li>\n<li><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p>\n</li>\n<li><p>可以优先换出阻塞进程；可换出优先级低的进程；为了防止优先级的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。</p>\n</li>\n</ol>\n<p><strong>PCB会常驻内存，不会被换出外存</strong></p>\n<hr>\n\n        <h2 id=\"总结-2\"   >\n          <a href=\"#总结-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>覆盖技术<ul>\n<li>一个固定区<ul>\n<li>存放最活跃的程序段</li>\n<li>固定区中的程序段在运行过程中不会调入调出</li>\n</ul>\n</li>\n<li>若干覆盖区<ul>\n<li>不可能同时被的访问程序段可共享一个覆盖区</li>\n<li>覆盖区中的程序段在运行过程中会根据需要调入调出</li>\n<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖</li>\n<li>缺点：对用户不透明，增加了用户编程负担</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>交换技术<ul>\n<li>内存紧张时，换出某些进程以腾出内存空间，再换入某些进程</li>\n<li>磁盘分为文件区和对换区，换出的进程放在对换区</li>\n</ul>\n</li>\n<li>覆盖与交换的区别<ul>\n<li>覆盖是在同一个程序或进程中的</li>\n<li>交换是在不同进程(或作业)之间的</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"连续分配管理方式\"   >\n          <a href=\"#连续分配管理方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#连续分配管理方式\" class=\"headerlink\" title=\"连续分配管理方式\"></a>连续分配管理方式</h1>\n      <ul>\n<li>连续分配管理方式<ul>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n</ul>\n<p>连续分配：指为用户进程的必须是一个<strong>连续的内存空间</strong></p>\n\n        <h2 id=\"单一连续分配\"   >\n          <a href=\"#单一连续分配\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#单一连续分配\" class=\"headerlink\" title=\"单一连续分配\"></a>单一连续分配</h2>\n      <p>在单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</p>\n<p>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。</p>\n<p>优点：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护(eg:早期的PC操作系统MS-DOS)</p>\n<p>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低。有很大一部分用户区空闲，内存利用率低。</p>\n<p>有内部碎片：分配给某进程的内存区域中，如果有些部分没有用上，就是“内存碎片”。</p>\n\n        <h2 id=\"固定分区分配\"   >\n          <a href=\"#固定分区分配\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#固定分区分配\" class=\"headerlink\" title=\"固定分区分配\"></a>固定分区分配</h2>\n      <ul>\n<li>分区大小相等</li>\n<li>分区大小不等</li>\n</ul>\n<p>20世纪60年代出现了支持多道程序的系统，为了能子啊内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p>\n<p>分区大小相等：缺乏灵活性，但是很<strong>适合用于用一台计算机控制多个相同对象的场合</strong>(比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)</p>\n<p>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)</p>\n<p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配于回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<strong>大小、起始地址、状态</strong>(是否已分配)</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">分区号</th>\n<th align=\"center\">大小(MB)</th>\n<th align=\"center\">起始地址(M)</th>\n<th align=\"center\">状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">8</td>\n<td align=\"center\">未分配</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n<td align=\"center\">10</td>\n<td align=\"center\">未分配</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">12</td>\n<td align=\"center\">已分配</td>\n</tr>\n<tr>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table></div>\n<p>当用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p>\n<ul>\n<li>优点：<ol>\n<li>实现简单</li>\n<li><strong>无外部碎片</strong></li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li>当用户程序太大时可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li>\n<li><strong>会产生内部碎片</strong>，内存利用率低</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"动态分区分配\"   >\n          <a href=\"#动态分区分配\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#动态分区分配\" class=\"headerlink\" title=\"动态分区分配\"></a>动态分区分配</h2>\n      <p>动态分区分配又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的。</p>\n<p>动态分区分配<strong>没有内部碎片，但是有外部碎片</strong>。</p>\n<ul>\n<li>内部碎片：分配给某进程的内存区域内，如果有些部分没有用上。</li>\n<li>外部碎片：是指内存中的某些空闲翻去由于太小而难以利用。</li>\n</ul>\n<p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。</p>\n<p>可以通过<strong>紧凑</strong>技术来解决外部碎片。</p>\n<ol>\n<li>系统要用什么样的数据结构记录内存的使用情况？</li>\n<li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</li>\n<li>如何进行分区的分配与回收操作？</li>\n</ol>\n\n        <h3 id=\"系统要用什么样的数据结构记录内存的使用情况？\"   >\n          <a href=\"#系统要用什么样的数据结构记录内存的使用情况？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#系统要用什么样的数据结构记录内存的使用情况？\" class=\"headerlink\" title=\"系统要用什么样的数据结构记录内存的使用情况？\"></a>系统要用什么样的数据结构记录内存的使用情况？</h3>\n      <ul>\n<li>空闲分区表</li>\n<li>空闲分区链</li>\n</ul>\n<p>空闲分区表：每个空闲分区对应一个表项。表项中包括分区号、分区大小、分区起始地址等信息。</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">分区号</th>\n<th align=\"center\">分区大小(MB)</th>\n<th align=\"center\">起始地址(M)</th>\n<th align=\"center\">状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">20</td>\n<td align=\"center\">8</td>\n<td align=\"center\">空闲</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">10</td>\n<td align=\"center\">32</td>\n<td align=\"center\">空闲</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">60</td>\n<td align=\"center\">空闲</td>\n</tr>\n</tbody></table></div>\n<hr>\n<p>空闲分区表：每个分区的其实部分和末尾部分分别设置前向指针和后向指针。起始部出处可记录分区大小等信息。</p>\n<p>就是一个双向链表。</p>\n\n        <h3 id=\"当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\"   >\n          <a href=\"#当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\" class=\"headerlink\" title=\"当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\"></a>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</h3>\n      <p>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法对系统性能有很大的影响，因此有多种情况。</p>\n\n        <h3 id=\"如何进行分区的分配与回收操作？\"   >\n          <a href=\"#如何进行分区的分配与回收操作？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何进行分区的分配与回收操作？\" class=\"headerlink\" title=\"如何进行分区的分配与回收操作？\"></a>如何进行分区的分配与回收操作？</h3>\n      <hr>\n\n        <h2 id=\"总结-3\"   >\n          <a href=\"#总结-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>单一连续分配<ul>\n<li>只支持单道程序，内存分为系统区和用户区，用户程序放在用户区</li>\n<li>无外部碎片，有内部碎片</li>\n</ul>\n</li>\n<li>固定分区分配<ul>\n<li>支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业</li>\n<li>无外部碎片，有内部碎片</li>\n<li>两种分区方式<ul>\n<li>分区大小相等</li>\n<li>分区大小不等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>动态分区分配<ul>\n<li>支持多道程序，在进程装入内存时，根据进程的大小动态地建立分区</li>\n<li>无内部碎片，有外部碎片</li>\n<li>外部碎片可用“紧凑”技术来解决</li>\n<li>回收内存分区时，可能遇到四种情况</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"动态分区分配算法\"   >\n          <a href=\"#动态分区分配算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#动态分区分配算法\" class=\"headerlink\" title=\"动态分区分配算法\"></a>动态分区分配算法</h1>\n      <p>动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>\n<ul>\n<li>首次适应算法(First Fit)</li>\n<li>最佳适应算法(Best Fit)</li>\n<li>最坏适应算法(Worst Fit)</li>\n<li>邻近适应算法(Next Fit)</li>\n</ul>\n\n        <h2 id=\"首次适应算法\"   >\n          <a href=\"#首次适应算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#首次适应算法\" class=\"headerlink\" title=\"首次适应算法\"></a>首次适应算法</h2>\n      <p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p>\n<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>\n\n        <h2 id=\"最佳适应算法\"   >\n          <a href=\"#最佳适应算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最佳适应算法\" class=\"headerlink\" title=\"最佳适应算法\"></a>最佳适应算法</h2>\n      <p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</p>\n<p>如何实现：空闲分区<strong>按容量递增次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>(或<strong>空闲分区表</strong>)，找到大小能满足要求的第一个空闲分区。</p>\n<p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p>\n\n        <h2 id=\"最坏适应算法\"   >\n          <a href=\"#最坏适应算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最坏适应算法\" class=\"headerlink\" title=\"最坏适应算法\"></a>最坏适应算法</h2>\n      <p>又称最大适应算法</p>\n<p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>\n<p>如何实现：空闲分区<strong>按容量递减次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>\n<p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p>\n\n        <h2 id=\"邻近适应算法\"   >\n          <a href=\"#邻近适应算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#邻近适应算法\" class=\"headerlink\" title=\"邻近适应算法\"></a>邻近适应算法</h2>\n      <p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>\n<p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时<strong>从上次查找结束的位置开始</strong>查找<strong>空闲分区链</strong>(或<strong>空闲分区表</strong>)，找到大小能满足要求的第一个空闲分区。</p>\n<p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)</p>\n<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(最大适应算法的缺点)。</p>\n\n        <h1 id=\"基本分页存储管理的基本概念\"   >\n          <a href=\"#基本分页存储管理的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基本分页存储管理的基本概念\" class=\"headerlink\" title=\"基本分页存储管理的基本概念\"></a>基本分页存储管理的基本概念</h1>\n      <ul>\n<li>考虑支持多道程序的两种连续分配方式：<ol>\n<li>固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低。</li>\n<li>动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”时间代价很高。</li>\n</ol>\n</li>\n</ul>\n<p>如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”。</p>\n<p>基于这一思想，产生了“非连续分配方式”，或者称为“离散分配方式”。</p>\n<ul>\n<li><p>非连续分配管理方式</p>\n<ul>\n<li>基本分页存储管理</li>\n<li>基本分段存储管理</li>\n<li>段页式存储管理</li>\n</ul>\n</li>\n<li><p>连续分配：为用户进程分配的必须是一个<strong>连续的内存空间</strong></p>\n</li>\n<li><p>非连续分配：为用户进程分配的可以时一些<strong>分散地内存空间</strong></p>\n</li>\n</ul>\n\n        <h2 id=\"把“固定分区分配”改造为“非连续分配版本”\"   >\n          <a href=\"#把“固定分区分配”改造为“非连续分配版本”\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#把“固定分区分配”改造为“非连续分配版本”\" class=\"headerlink\" title=\"把“固定分区分配”改造为“非连续分配版本”\"></a>把“固定分区分配”改造为“非连续分配版本”</h2>\n      <p>如果把分区大小设置的更小一些。内部碎片会更小，内存利用率会更高。</p>\n<p>基本分区存储管理的思想——把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p>\n\n        <h2 id=\"分页存储管理的基本概念\"   >\n          <a href=\"#分页存储管理的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分页存储管理的基本概念\" class=\"headerlink\" title=\"分页存储管理的基本概念\"></a>分页存储管理的基本概念</h2>\n      <p>将内存空间分为一个个<strong>大小相等的分区</strong>(比如：每个分区4KB)，每个分区就是一个“<strong>页框</strong>”，或称“<strong>页帧</strong>”、“<strong>内存块</strong>”、“<strong>物理块</strong>”。每个页框有一个编号，即“<strong>页框号</strong>”(或者“<strong>内存块号</strong>”、“<strong>页帧号</strong>”、“<strong>物理块号</strong>”)页框号<strong>从0开始</strong>。</p>\n<p>将用户进程的地址空间也分为<strong>与页框大小相等</strong>的一个个区域。称为<strong>页</strong>或<strong>页面</strong>，每个页面也有一个编号，即<strong>页号</strong>，页号也是<strong>从0开始</strong></p>\n<p>注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片。</p>\n<p>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系。</p>\n<p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p>\n\n        <h2 id=\"如何实现地址的转换\"   >\n          <a href=\"#如何实现地址的转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何实现地址的转换\" class=\"headerlink\" title=\"如何实现地址的转换\"></a>如何实现地址的转换</h2>\n      <ol>\n<li>要算出逻辑地址对应的<strong>页号</strong></li>\n<li>要知道该页号对应<strong>页面在内存中的起始地址</strong></li>\n<li>要算出逻辑地址<strong>在页面内的“偏移量”</strong>。</li>\n<li><code>物理地址=页面始址+页内偏移量</code></li>\n</ol>\n<ul>\n<li>如何计算：<ul>\n<li><code>页号=逻辑地址/页面长度</code>(取除法的<strong>整数</strong>部分)</li>\n<li><code>页内偏移量 = 逻辑地址%页面长度</code>(取除法的<strong>余数</strong>部分)</li>\n<li>页面<strong>在内存中的其实位置</strong>：操作系统需要用某种数据结构记录进程各个页面的起始位置。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">页号 = 80/50 = 1</span><br><span class=\"line\">页内偏移量 = 80 % 50 = 30</span><br><span class=\"line\">1号页在内存中存放的其实位置为450</span><br></pre></td></tr></table></div></figure>\n\n<p>为了方便计算页号、页内偏移量，<strong>页面大小</strong>一般设为<strong>2的整数幂</strong>。</p>\n<p>如果每个页面大小为2的k次方B，用二进制数表示逻辑地址，则末尾k位即为<strong>页内偏移量</strong>，其余部分就是<strong>页号</strong>。</p>\n<p>因此，如果让<strong>每个页面的大小为2的整数幂</strong>，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p>\n\n        <h2 id=\"逻辑地址结构\"   >\n          <a href=\"#逻辑地址结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#逻辑地址结构\" class=\"headerlink\" title=\"逻辑地址结构\"></a>逻辑地址结构</h2>\n      <p>分页存储管理的<strong>逻辑地址结构</strong>如下所示：</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">31 … 12</th>\n<th align=\"center\">11 … 0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">页面P</td>\n<td align=\"center\">页内偏移量W</td>\n</tr>\n</tbody></table></div>\n<p>地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量W。在上图所示的例子中，地址长度为32位，其中0<del>11位位“<strong>页内偏移量</strong>”，或称“<strong>页内地址</strong>”；12</del>31位为“<strong>页号</strong>”。</p>\n<p><strong>如果有K为表示“页内偏移量”，则说明该系统中一个页面的大小是2的K次方各内存单元。</strong></p>\n<p><strong>如果有M位表示“页内”，则说明在该系统中，一个进程最多允许有2的M次方个页面。</strong></p>\n<ul>\n<li>分页存储管理中，实现地址转化：<ol>\n<li>要算出逻辑地址对应的<strong>页号</strong></li>\n<li>要知道该页号对应<strong>页面在内存中的起始地址</strong></li>\n<li>要算出逻辑地址<strong>在页面内的“偏移量”</strong></li>\n<li>物理地址=页面始址+页面偏移量</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"页表\"   >\n          <a href=\"#页表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#页表\" class=\"headerlink\" title=\"页表\"></a>页表</h2>\n      <p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为<strong>每个进程建立一张页表</strong>。</p>\n<ol>\n<li>一个进程对应一张页表</li>\n<li>进程的每一页对应一个页表项</li>\n<li>每个<strong>页表项</strong>由“页号”和“块号”组成</li>\n<li>页表记录<strong>进程页面和实际存放的内存块之间的对应关系</strong>。</li>\n</ol>\n<p>M号内存块的起始地址就是M*内存块大小</p>\n<p>块号（页表项长度）是固定的，只需要知道<strong>页表存放的起始位置</strong>和<strong>页表项长度</strong>，即可找到各个对应的页表项存放的位置。</p>\n<hr>\n\n        <h2 id=\"总结-4\"   >\n          <a href=\"#总结-4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>基本分页存储管理的思想：把进程分页，各个页面可离散地放到各个内存块中</li>\n<li>重要概念<ul>\n<li>页框、页帧、内存块、物理块 VS 页、页面</li>\n<li>页框号、页帧号、内存块号、物理块号 VS 页号、页面号</li>\n</ul>\n</li>\n<li>如何实现地址转换<ol>\n<li>计算出逻辑地址对应的页号</li>\n<li>找到对应页面在内存中的存放位置</li>\n<li>算出逻辑地址对应的页内偏移量</li>\n<li><code>物理地址 = 页面始址 + 页内偏移量</code></li>\n</ol>\n</li>\n<li>页号、页内偏移量的计算<ul>\n<li><code>页号 = 逻辑地址/页面大小</code>;<code>页内偏移量 = 逻辑地址%页面大小</code></li>\n<li>或根据逻辑地址结构计算，<code>逻辑地址 = [页号P,页内偏移量W]</code></li>\n</ul>\n</li>\n<li>页表<ul>\n<li>页表记录进程页面和实际存放的内存块之间的对应关系</li>\n<li>一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成</li>\n<li>每个页表项的长度时相同的，页号时“隐含”的。</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"基本地址变换机构\"   >\n          <a href=\"#基本地址变换机构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基本地址变换机构\" class=\"headerlink\" title=\"基本地址变换机构\"></a>基本地址变换机构</h1>\n      <p>这个内容属于基本分页存储管理</p>\n<p>重点理解、记忆基本地址变换机构(用于实现逻辑地址到物理地址转换的一组硬件机构)的原理和流程</p>\n<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>\n<p>通常会在系统中设置一个<strong>页表寄存器(PTR)<strong>，存放</strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong>。</p>\n<p>进程未执行时，页表的始址 和 页表长度 <strong>放在进程控制块(PCB)中</strong>，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>\n<p>理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得<strong>每个页面恰好可以装得下整数个页表项</strong>。</p>\n<p>进程页通常是<strong>装在连续的内存块中</strong>。</p>\n<hr>\n\n        <h2 id=\"总结-5\"   >\n          <a href=\"#总结-5\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>页表寄存器的作用<ul>\n<li>存放页表起始地址</li>\n<li>存放页表长度</li>\n</ul>\n</li>\n<li>地址变换过程<ol>\n<li>根据逻辑地址算出页号、页内偏移量</li>\n<li>页号的合法性检查(与页表长度对比)</li>\n<li>若页号合法，再根据页表起始地址、页号找到对应页表项<ol>\n<li>第一次访问内存：查页表</li>\n</ol>\n</li>\n<li>根据页表项中记录的内存块号、页内偏移量 得到最终的物理地址</li>\n<li>访问物理内存对应的内存单元<ol>\n<li>第二次访问内存：访问目标内存单元</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>其他小细节<ul>\n<li>页内偏移量位数与页面大小之间的关系(要能用其中一个条件推出另一个条件)</li>\n<li>页式管理中地址是一维的</li>\n<li>实际应用中，通常使一个页框恰好能放入整数个页表项</li>\n<li>为了方便找到页表项，页表一般时放在连续的内存块中的</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"具有块表的地址变换机构\"   >\n          <a href=\"#具有块表的地址变换机构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#具有块表的地址变换机构\" class=\"headerlink\" title=\"具有块表的地址变换机构\"></a>具有块表的地址变换机构</h1>\n      <ul>\n<li>局部性原理</li>\n<li>什么是块表(TLB)</li>\n<li>引入块表后，地址的变换过程</li>\n</ul>\n\n        <h2 id=\"局部性原理\"   >\n          <a href=\"#局部性原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span>(i&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">  a[i] = i;</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">//这个程序执行时，会频繁访问“存放程序对应的指令”，“存放程序中定义的变量”。</span></span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能子啊次被访问(因为程序中存在大量的循环)</li>\n<li>空间局限性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(连续存放)</li>\n</ul>\n<p>由于局部性原理，<strong>可能连续很多查到的都是同一个页表</strong>。既然如此，能否利用这个特性减少访问页表次数？</p>\n\n        <h2 id=\"什么是块表-TLB\"   >\n          <a href=\"#什么是块表-TLB\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是块表-TLB\" class=\"headerlink\" title=\"什么是块表(TLB)\"></a>什么是块表(TLB)</h2>\n      <p>块表，又称<strong>联想寄存器(TLB)<strong>，是一种</strong>访问速度比内存快很多</strong>的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程，以加速地址变换的过程。与此对应，内存中的页表常称为<strong>慢表</strong>。</p>\n<p>就是一个高速缓冲而已。</p>\n<p>在找到页表项后，应同时将其存入块表，以便后面的可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</p>\n\n        <h1 id=\"两级页表\"   >\n          <a href=\"#两级页表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#两级页表\" class=\"headerlink\" title=\"两级页表\"></a>两级页表</h1>\n      <ul>\n<li>单级页表存在什么问题？如何解决？</li>\n<li>两级页表的原理、逻辑地址结构</li>\n<li>如何实现地址变换</li>\n<li>两级页表问题需要注意的几个细节</li>\n</ul>\n\n        <h2 id=\"单级页表存在的问题\"   >\n          <a href=\"#单级页表存在的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#单级页表存在的问题\" class=\"headerlink\" title=\"单级页表存在的问题\"></a>单级页表存在的问题</h2>\n      <p>需要给进程分配多个连续的页表框来存放页表，丧失了离散分配的优点。</p>\n<p>进程在一段时间内只需要访问某几个页面就可以正常运行了。因此<strong>没有必要让整个页表都常驻内存</strong>。</p>\n\n        <h2 id=\"如何解决单级页表的问题？\"   >\n          <a href=\"#如何解决单级页表的问题？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何解决单级页表的问题？\" class=\"headerlink\" title=\"如何解决单级页表的问题？\"></a>如何解决单级页表的问题？</h2>\n      <p>对长页表进行分组，再建立一张页表，称为<strong>页目录表</strong>，或称<strong>外层页表</strong>，或称<strong>顶层页表</strong>。</p>\n<p>可以在需要访问页面时才把页面调入内存(虚拟存储技术)。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>\n<p>若想访问的页面不在内存中，则产生缺页中断(内中断)，然后将目标页面从外存调入内存。</p>\n\n        <h2 id=\"两级页表的原理、地址结构\"   >\n          <a href=\"#两级页表的原理、地址结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#两级页表的原理、地址结构\" class=\"headerlink\" title=\"两级页表的原理、地址结构\"></a>两级页表的原理、地址结构</h2>\n      <blockquote>\n<p>两级页表结构的逻辑地址结构<br>|31 … 22|21 … 12|11 … 0|<br>|:—:|:—:|:—:|<br>|一级目录|二级目录|页内偏移量|</p>\n</blockquote>\n\n        <h2 id=\"如何实现地址变换\"   >\n          <a href=\"#如何实现地址变换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何实现地址变换\" class=\"headerlink\" title=\"如何实现地址变换\"></a>如何实现地址变换</h2>\n      <ol>\n<li>按照地址结构将逻辑地址拆分成三部分</li>\n<li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li>\n<li>根据二级页号查表，找到最终想访问的内存块号</li>\n<li>结合页内偏移量得到物理地址</li>\n</ol>\n\n        <h2 id=\"需要注意的几个细节\"   >\n          <a href=\"#需要注意的几个细节\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#需要注意的几个细节\" class=\"headerlink\" title=\"需要注意的几个细节\"></a>需要注意的几个细节</h2>\n      <ol>\n<li>若采用多级页表机制，则<strong>各级页表的大小不能超过一个页面</strong></li>\n<li>两级页表的<strong>访问次数</strong>分析(假设没有快表机构)：<ol>\n<li>第一次访存：访问内存中的页目录表</li>\n<li>第二次访存：访问内存中的二级页表</li>\n<li>第三次访存：访问目标内存单元</li>\n</ol>\n</li>\n</ol>\n<hr>\n\n        <h2 id=\"总结-6\"   >\n          <a href=\"#总结-6\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>单级页表存在的问题<ul>\n<li>所有页表项必须连续存放，页表过大时需要很大的连续空间</li>\n<li>在一段时间内并非所有页面都用得到，没有必要让整个页表常驻内存</li>\n</ul>\n</li>\n<li>两级页表<ul>\n<li>将长长的页表再分页</li>\n<li>逻辑地址结构：(一级页号，二级页号，页内偏移量)</li>\n<li>注意几个术语：页目录表/外层页表/顶级页表</li>\n</ul>\n</li>\n<li>如何实现地址变换<ol>\n<li>按照地址结构将逻辑地址拆分成三部分</li>\n<li>从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表再内存中的存放位置</li>\n<li>根据二级页号查表，找到最终想访问的内存块号</li>\n<li>结合页内偏移量得到物理地址</li>\n</ol>\n</li>\n<li>几个细节<ul>\n<li>多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级。</li>\n<li>多级页表的访存次数(假设没有快表机构)——N级页表访问一个逻辑地址需要N+1次访存</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"基本分段存储管理方式\"   >\n          <a href=\"#基本分段存储管理方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基本分段存储管理方式\" class=\"headerlink\" title=\"基本分段存储管理方式\"></a>基本分段存储管理方式</h1>\n      <ul>\n<li>什么是分段(类似于分页管理中的“分区”)</li>\n<li>什么是段表(类似于分页管理中的“页表”)</li>\n<li>如何实现地址变换</li>\n<li>分段、分页管理的对比</li>\n</ul>\n<p>与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同</p>\n\n        <h2 id=\"分段\"   >\n          <a href=\"#分段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分段\" class=\"headerlink\" title=\"分段\"></a>分段</h2>\n      <p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，<strong>每段从0开始编址</strong>。</p>\n<p>由于是按逻辑功能模块划分，用户<strong>编程更方便，程序的可读性更高</strong></p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">LOAD 1,[D]|&lt;A&gt;; //将分段D中A单元内的值读入寄存器1</span><br><span class=\"line\">STORE 1,[X]|&lt;B&gt;;  //将寄存器1的内容存入X分段的B单位中</span><br></pre></td></tr></table></div></figure>\n\n<p>编译程序会将段名转换为段号</p>\n<p>分段系统的逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成：</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">31 … 16</th>\n<th align=\"center\">15 … 0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">段号</td>\n<td align=\"center\">段内地址</td>\n</tr>\n</tbody></table></div>\n<p><strong>段号的位数决定了每个进程最多可以分几个段</strong></p>\n<p><strong>段内地址位数决定了每个段的最大长度时多少</strong></p>\n<p>程序分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“<strong>段表</strong>”。</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">段号</th>\n<th align=\"center\">段长</th>\n<th align=\"center\">基址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">7K</td>\n<td align=\"center\">80K</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3K</td>\n<td align=\"center\">120K</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">6K</td>\n<td align=\"center\">40K</td>\n</tr>\n</tbody></table></div>\n<ol>\n<li>每个段对应一个段表项，其中记录了该段在内存中的<strong>起始位置</strong>(又称“<strong>基址</strong>”)和<strong>段的长度</strong>。</li>\n<li><strong>各个段表项的长度是相同的</strong>。由于长度相同，因此<strong>段号可以是隐含的，不占存储空间</strong>。</li>\n</ol>\n<p><code>LOAD 1,[D]|&lt;A&gt;;  //将分段D中A单元内的值读入寄存器1</code></p>\n\n        <h2 id=\"分段、分页管理的对比\"   >\n          <a href=\"#分段、分页管理的对比\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分段、分页管理的对比\" class=\"headerlink\" title=\"分段、分页管理的对比\"></a>分段、分页管理的对比</h2>\n      <p><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行文，<strong>对用户是不可见的</strong>。</p>\n<p><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。</p>\n<p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p>\n<ul>\n<li><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。</li>\n<li><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在表示一个地址时，既要给出段名，也要给出段内地址。</li>\n</ul>\n<p>分段比分页更容易实现信息的共享和保护。不同的进程可以在自己的段表内添加同一个段就能实现进程间数据共享。</p>\n<p>不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>(不属于临界资源)，这样的代码时可以共享的。可修改的代码时不能共享的(比如：有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)</p>\n<hr>\n\n        <h2 id=\"总结-7\"   >\n          <a href=\"#总结-7\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-7\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>分段<ul>\n<li>将地址空间按照程序自身的逻辑关系划分为若干个段，每段从0开始编址</li>\n<li>每个段在内存中占据连续空间，但各段之间可以不相邻</li>\n<li>逻辑地址结构：(段号,段内地址)</li>\n</ul>\n</li>\n<li>段表<ul>\n<li>记录逻辑段到实际存储地址的映射关系</li>\n<li>每个段对应一个段表项，各段表项长度相同，由段号(隐含)、段长、基址组成</li>\n</ul>\n</li>\n<li>地址变换<ol>\n<li>由逻辑地址得到段号、段内地址</li>\n<li>段号与段表寄存器中的段长比较，检查是否越界</li>\n<li>由段表始址、段号找到对应段表项</li>\n<li>根据段表中记录的段长，检查段内地址是否越界</li>\n<li>由段表中的“基址+段内地址”得到最终的物理地址</li>\n<li>访问目标单元</li>\n</ol>\n</li>\n<li>分段 VS 分页<ul>\n<li>分页对用户不可见，分段对用户可见</li>\n<li>分页的地址空间是一维的，分段的地址空间是二维的</li>\n<li>分段更容易实现信息的共享和保护(纯代码/可重入代码可以共享)</li>\n<li>分页(单级页表)、分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"段页式管理方式\"   >\n          <a href=\"#段页式管理方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#段页式管理方式\" class=\"headerlink\" title=\"段页式管理方式\"></a>段页式管理方式</h1>\n      <ul>\n<li>分页、分段管理方式中最大的优缺点</li>\n<li>分段+分页的结合——段页式管理方式</li>\n<li>段表、页表</li>\n<li>如何实现地址变换</li>\n</ul>\n\n        <h2 id=\"分页、分段的优缺点分析\"   >\n          <a href=\"#分页、分段的优缺点分析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分页、分段的优缺点分析\" class=\"headerlink\" title=\"分页、分段的优缺点分析\"></a>分页、分段的优缺点分析</h2>\n      <p>||优点|缺点|<br>|分页管理|内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片|不方便按照逻辑模块实现信息的共享和保护|<br>|分段管理|很方便按照逻辑模块实现信息的共享和保护|如果段长过长，为其分配很大的连续空间会很不更方便。另外，段式管理会产生外部碎片|</p>\n\n        <h2 id=\"分段-分页-段页式管理\"   >\n          <a href=\"#分段-分页-段页式管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分段-分页-段页式管理\" class=\"headerlink\" title=\"分段+分页=段页式管理\"></a>分段+分页=段页式管理</h2>\n      <p>将进程按逻辑模块分段，再将各段分页(如每个页面4KB)</p>\n<p>再将内存空间分为大小相同的内存块/页框/页帧/物理块</p>\n\n        <h2 id=\"段页式管理的逻辑地址结构\"   >\n          <a href=\"#段页式管理的逻辑地址结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#段页式管理的逻辑地址结构\" class=\"headerlink\" title=\"段页式管理的逻辑地址结构\"></a>段页式管理的逻辑地址结构</h2>\n      <p>|31 … 16|15 … 12|11 … 0|<br>|段号|分页|页内偏移量|</p>\n<p><strong>段号的位数决定了每个进程最多可以分几个段</strong></p>\n<p><strong>页号位数决定了每个段最大有多少页</strong></p>\n<p><strong>页内偏移量决定了页面大小、内存块大小是多少</strong></p>\n<p>“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。</p>\n<p>因此<strong>段页式</strong>管理的<strong>地址结构是二维的</strong>。</p>\n\n        <h2 id=\"段表、页表\"   >\n          <a href=\"#段表、页表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#段表、页表\" class=\"headerlink\" title=\"段表、页表\"></a>段表、页表</h2>\n      <p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始地址)组成。每个段表项长度相等，段号是隐含的。</p>\n<p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p>\n<hr>\n\n        <h2 id=\"总结-8\"   >\n          <a href=\"#总结-8\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-8\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>分段+分页<ul>\n<li>将地址空间按照程序自身的逻辑关系划分为若干个段，在将各段分为大小相等的页面</li>\n<li>将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存</li>\n<li>逻辑地址结构：（段号，页号，页面偏移量）</li>\n</ul>\n</li>\n<li>段表、页表<ul>\n<li>每个段对应一个段表项。各段表项长度相同，由段号(隐含)、页表长度、页面存放地址 组成</li>\n<li>每个页对应一个页表项。各页表项长度相同，由页号(隐含)、页面存放的内存块号 组成</li>\n</ul>\n</li>\n<li>地址变换<ol>\n<li>由逻辑地址得到段号、页号、页面偏移量</li>\n<li>段号与段表寄存器中的段长度比较，检查是否越界</li>\n<li>由段表始址、段号找到对应段表项</li>\n<li>根据段表中记录的页表长度，检查页号是否越界</li>\n<li>由段表中的页表地址、页号得到查询页表，找到相应页表项</li>\n<li>由页面存放的内存块号、页内偏移量得到最终的物理地址</li>\n<li>访问目标单元</li>\n</ol>\n</li>\n<li>访问一个逻辑地址所需访存次数<ul>\n<li>第一次——查段表、第二次——查页表、第三次——访问目标单元</li>\n<li>可引入快表机构，以段号和页号Wie关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存。</li>\n</ul>\n</li>\n</ul>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"王道计算机网络笔记","url":"/Major-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/","content":"\n        <h1 id=\"第1章——计算机网络体系结构\"   >\n          <a href=\"#第1章——计算机网络体系结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第1章——计算机网络体系结构\" class=\"headerlink\" title=\"第1章——计算机网络体系结构\"></a>第1章——计算机网络体系结构</h1>\n      \n        <h2 id=\"1-1-计算机网络概述\"   >\n          <a href=\"#1-1-计算机网络概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-1-计算机网络概述\" class=\"headerlink\" title=\"1.1 计算机网络概述\"></a>1.1 计算机网络概述</h2>\n      \n        <h3 id=\"1-概念、组成、功能和分类\"   >\n          <a href=\"#1-概念、组成、功能和分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-概念、组成、功能和分类\" class=\"headerlink\" title=\"1. 概念、组成、功能和分类\"></a>1. 概念、组成、功能和分类</h3>\n      <p>计算机网络：是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p>\n<ul>\n<li><p>计算机网络是<strong>互连</strong>的、<strong>自治</strong>的计算机集合。</p>\n<ul>\n<li>互连指互联互通 <em>通信链路</em></li>\n<li>无主从关系</li>\n</ul>\n</li>\n<li><p>计算机网络的功能</p>\n<ol>\n<li> 数据通信（连通性）</li>\n<li> 资源共享（硬件、软件、数据）</li>\n<li> 分布式处理</li>\n<li> 提高可靠性</li>\n<li> 负载均衡</li>\n<li> ……</li>\n</ol>\n</li>\n<li><p>计算机网络的组成</p>\n<ol>\n<li>组成部分<ul>\n<li>硬件</li>\n<li>软件</li>\n<li>协议</li>\n</ul>\n</li>\n<li>工作方式<ul>\n<li>边缘系统<ul>\n<li>C/S模式</li>\n<li>P2P模式</li>\n</ul>\n</li>\n<li>核心部分<ul>\n<li>为边缘部分服务</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>功能组成<ul>\n<li>通信子网<ul>\n<li>  实现<strong>数据通信</strong></li>\n<li>  各种传输介质、通信设备、相应的网络协议组成</li>\n</ul>\n</li>\n<li>资源子网 <ul>\n<li>  实现<strong>资源共享</strong>/数据处理</li>\n<li>  实现资源共享功能的设备和软件的集合</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>计算机网络的分类</p>\n<ol>\n<li>按分布范围分<ul>\n<li>广域网WAN<ul>\n<li>交换技术</li>\n</ul>\n</li>\n<li>城域网MAN</li>\n<li>局域网WAN<ul>\n<li>广播技术</li>\n</ul>\n</li>\n<li>个人区域网PAN</li>\n</ul>\n</li>\n<li>按使用者分<ul>\n<li>公用网<ul>\n<li>  三大运营商</li>\n</ul>\n</li>\n<li>专用网<ul>\n<li>  政府、军队</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>按交换技术分<ul>\n<li>  电路交换</li>\n<li>  报文交换</li>\n<li>  分组交换</li>\n</ul>\n</li>\n<li>按拓补结构分<ul>\n<li>  总线型</li>\n<li>  星型</li>\n<li>  环型</li>\n<li>网状型<ul>\n<li>  常用于广域网</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>按传输技术分<ul>\n<li>广播式网络<ul>\n<li>共享公共通信信道</li>\n</ul>\n</li>\n<li>点对点网络<ul>\n<li>使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"2-计算机网络标准化工作及相关组织\"   >\n          <a href=\"#2-计算机网络标准化工作及相关组织\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-计算机网络标准化工作及相关组织\" class=\"headerlink\" title=\"2. 计算机网络标准化工作及相关组织\"></a>2. 计算机网络标准化工作及相关组织</h3>\n      \n        <h4 id=\"标准化工作\"   >\n          <a href=\"#标准化工作\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#标准化工作\" class=\"headerlink\" title=\"标准化工作\"></a>标准化工作</h4>\n      <p>要实现不同厂商的软硬件之间相互通信，必须遵从统一的标准。</p>\n<ul>\n<li>标准的分类<ul>\n<li>法定标准<ul>\n<li>由权威机构制定的正式的、合法的标准</li>\n<li>如：OSI</li>\n</ul>\n</li>\n<li>事实标准<ul>\n<li>某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准</li>\n<li>如：TCP/IP</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"RFC及其发展为因特网标准的四个阶段\"   >\n          <a href=\"#RFC及其发展为因特网标准的四个阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RFC及其发展为因特网标准的四个阶段\" class=\"headerlink\" title=\"RFC及其发展为因特网标准的四个阶段\"></a>RFC及其发展为因特网标准的四个阶段</h4>\n      <ul>\n<li>RFC(Request For Comments)——因特网标准的形式<ol>\n<li> 因特网草案(Internet Draft) 这个阶段还不是RFC文档</li>\n<li> 建议标准(Proposed Standard) 从这个阶段开始称为RFC文档</li>\n<li> 草案标准(Draft Standard) IETF、IAB审核，2011年取消了该阶段</li>\n<li> 成为因特网标准(Internet Standard)</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"标准化工作的相关组织\"   >\n          <a href=\"#标准化工作的相关组织\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#标准化工作的相关组织\" class=\"headerlink\" title=\"标准化工作的相关组织\"></a>标准化工作的相关组织</h4>\n      <ul>\n<li>ISO 国际标准化组织<ul>\n<li>案例：OSI参考模型</li>\n<li>HDLC协议</li>\n</ul>\n</li>\n<li>ITU 国际电信联盟<ul>\n<li>制定通信规则</li>\n</ul>\n</li>\n<li>IEEE 国际电气电子工程师协会<ul>\n<li>学术机构</li>\n<li>IEEE802系列标准</li>\n<li>5G</li>\n</ul>\n</li>\n<li>IETF Internet工程任务组<ul>\n<li>负责因特网相关标准的制定</li>\n<li>RFC XXXX</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"3-性能指标之速率、带宽、吞吐量\"   >\n          <a href=\"#3-性能指标之速率、带宽、吞吐量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-性能指标之速率、带宽、吞吐量\" class=\"headerlink\" title=\"3.性能指标之速率、带宽、吞吐量\"></a>3.性能指标之速率、带宽、吞吐量</h3>\n      \n        <h4 id=\"速率\"   >\n          <a href=\"#速率\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#速率\" class=\"headerlink\" title=\"速率\"></a>速率</h4>\n      <p>速率即<strong>数据率</strong>或称<strong>数据传输率</strong>或<strong>比特率</strong>。</p>\n<p>连接在计算机网络上的<strong>主机</strong>在数字信道上传送数据<strong>位数的速率</strong>。</p>\n<ul>\n<li>速率<ul>\n<li>kb/s</li>\n<li>Mb/s</li>\n<li>Gb/s</li>\n<li>Tb/s</li>\n<li>倍数是10的3次方</li>\n</ul>\n</li>\n<li>存储容量<ul>\n<li>1 Byte(字节) = 8 bit(比特)</li>\n<li>1KB = 1024 B</li>\n<li>1MB = 1024 KB</li>\n<li>1GB = 1024 MB</li>\n<li>1TB = 1024 GB</li>\n<li>倍数为1024倍</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"带宽\"   >\n          <a href=\"#带宽\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#带宽\" class=\"headerlink\" title=\"带宽\"></a>带宽</h4>\n      <ol>\n<li>“带宽”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是盒子(Hz)。</li>\n<li>计算机网络中，带宽用来表示传输数据时的最高数据率</li>\n<li>带宽越高，在单位时间内发送的数据信号密度越大</li>\n</ol>\n\n        <h4 id=\"吞吐量\"   >\n          <a href=\"#吞吐量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h4>\n      <p>表示在<strong>单位时间</strong>内通过**某个网络(或信道、接口)**的数据量。</p>\n<p>吞吐量受网络的带宽或网络的额定速率的限制，服务器性能以及网线等原因都会影响吞吐量。</p>\n\n        <h3 id=\"4-时延、时延带宽积、RTT和利用率\"   >\n          <a href=\"#4-时延、时延带宽积、RTT和利用率\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-时延、时延带宽积、RTT和利用率\" class=\"headerlink\" title=\"4. 时延、时延带宽积、RTT和利用率\"></a>4. 时延、时延带宽积、RTT和利用率</h3>\n      \n        <h4 id=\"时延\"   >\n          <a href=\"#时延\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h4>\n      <p>指数据(报文/分组/比特流)从网络(或链路)的一段传送到另一端所需的时间。也叫<code>延迟</code>或<code>迟延</code>。单位是s。</p>\n<ul>\n<li>时延<ol>\n<li>发送时延(传输时延)<ul>\n<li>  从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间</li>\n<li>  发送时延 = 数据长度/信道带宽</li>\n<li>  <strong>高速链路</strong>是提高发送速率，减小了发送时延！</li>\n</ul>\n</li>\n<li>传播时延<ul>\n<li>  取决于电磁波传播速率和链路长度</li>\n<li>  固体传播速率比在真空中要慢点</li>\n<li>  传播时延 = 信道长度/电磁波在信道上的传播率</li>\n</ul>\n</li>\n<li>排队时延<ul>\n<li>  等待输出\\输入链路可用</li>\n<li>  其实就是在路由器缓存区等待转发的时间</li>\n</ul>\n</li>\n<li>处理实验<ul>\n<li>  路由器进行校验以及通过路由表查询路径</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"时延带宽积\"   >\n          <a href=\"#时延带宽积\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#时延带宽积\" class=\"headerlink\" title=\"时延带宽积\"></a>时延带宽积</h4>\n      <p>有多少数据在链路中：<br><code>时延带宽积 = 传播时延 X 带宽</code><br>时延带宽积又称为以<strong>比特为单位的链路长度</strong>。</p>\n\n        <h4 id=\"往返时延RTT-roud-trip-time\"   >\n          <a href=\"#往返时延RTT-roud-trip-time\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#往返时延RTT-roud-trip-time\" class=\"headerlink\" title=\"往返时延RTT(roud trip time)\"></a>往返时延RTT(roud trip time)</h4>\n      <p>从发送方发送数据开始，到发送方收到接收方的确认，总经历的时延。</p>\n<p>RTT越大，在收到确认之前，可以发送的数据越多。</p>\n<ul>\n<li>RTT包括<ul>\n<li>往返传播时延 = 传播时延 * 2<ul>\n<li>  主要时间</li>\n</ul>\n</li>\n<li>末端处理时间<ul>\n<li>  通常忽略</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"利用率\"   >\n          <a href=\"#利用率\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#利用率\" class=\"headerlink\" title=\"利用率\"></a>利用率</h4>\n      <ul>\n<li>利用率<ul>\n<li>信道利用率<ul>\n<li><code>有数据通过时间\\(有+无)数据通过时间</code></li>\n</ul>\n</li>\n<li>网络利用率<ul>\n<li>信道利用率加权平均值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>利用率趋近于1时，时延呈指数级增长，从而导致速率被降低</p>\n\n        <h2 id=\"1-2-计算机网络体系结构与参考模型\"   >\n          <a href=\"#1-2-计算机网络体系结构与参考模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-2-计算机网络体系结构与参考模型\" class=\"headerlink\" title=\"1.2 计算机网络体系结构与参考模型\"></a>1.2 计算机网络体系结构与参考模型</h2>\n      \n        <h3 id=\"1-分层结构、协议、接口、服务\"   >\n          <a href=\"#1-分层结构、协议、接口、服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-分层结构、协议、接口、服务\" class=\"headerlink\" title=\"1. 分层结构、协议、接口、服务\"></a>1. 分层结构、协议、接口、服务</h3>\n      \n        <h4 id=\"为什么要分层？\"   >\n          <a href=\"#为什么要分层？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#为什么要分层？\" class=\"headerlink\" title=\"为什么要分层？\"></a>为什么要分层？</h4>\n      <ul>\n<li>发送文件前要完成的工作：<ol>\n<li>发起通信的计算机必须将数据通信的通路进行<strong>激活</strong>。</li>\n<li>要告诉网络如何识别目的主机</li>\n<li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常</li>\n<li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作</li>\n<li>确保差错和以外可以解决</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"怎么分层？\"   >\n          <a href=\"#怎么分层？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#怎么分层？\" class=\"headerlink\" title=\"怎么分层？\"></a>怎么分层？</h4>\n      <ul>\n<li>分层的基本原则<ol>\n<li> 各层之间相互<strong>独立</strong>，每层只实现一种相对独立的功能。</li>\n<li> 各层之间<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少。</li>\n<li> 结构上可分割开。每层都采用<strong>最合适的技术</strong>来实现。</li>\n<li> 保持<strong>下层</strong>对<strong>上层</strong>的独立性，<strong>上层单向使用下层提供的服务</strong>。</li>\n<li> 整个分层结构应该能促进标准化工作。</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"正式认识分层结构\"   >\n          <a href=\"#正式认识分层结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#正式认识分层结构\" class=\"headerlink\" title=\"正式认识分层结构\"></a>正式认识分层结构</h4>\n      <ul>\n<li>正式认识分层结构<ol>\n<li> 实体：第n层中的活动元素称为<strong>n层实体</strong>。同一层的实体叫做<strong>对等实体</strong>。</li>\n<li>协议：为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议。【协议是水平的】<ul>\n<li>语法：规定传输数据的格式</li>\n<li>语义：规定所要完成的功能</li>\n<li>同步：规定各种操作的顺序</li>\n</ul>\n</li>\n<li>接口(访问服务点SAP)：上层使用下层服务的入口。</li>\n<li>服务：下层为相邻上层提供的功能调用。【垂直】</li>\n</ol>\n</li>\n</ul>\n<p><code>PDU = PCI + SDU</code></p>\n<ul>\n<li>SDU服务数据单元：为完成用户所要求的功能而应传送的数据</li>\n<li>PCI协议控制信息：控制协议操作的信息。</li>\n<li>PDU协议数据单元：对等层次之间传送的数据单位</li>\n</ul>\n\n        <h4 id=\"概念总结\"   >\n          <a href=\"#概念总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#概念总结\" class=\"headerlink\" title=\"概念总结\"></a>概念总结</h4>\n      <ul>\n<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</li>\n<li>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong></li>\n<li>每层遵循某个/些<strong>网络协议</strong>以完成本层功能。</li>\n<li><strong>计算机网络体系结构</strong>是计算机网络的<strong>各层及其协议</strong>的集合。</li>\n<li>在n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</li>\n<li>仅仅在<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上一层完全屏蔽。</li>\n<li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</li>\n</ul>\n\n        <h3 id=\"2-OSI参考模型\"   >\n          <a href=\"#2-OSI参考模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-OSI参考模型\" class=\"headerlink\" title=\"2. OSI参考模型\"></a>2. OSI参考模型</h3>\n      <ul>\n<li>计算机网络分层结构<ul>\n<li>7层OSI参考模型（法定标准）</li>\n<li>4层TCP/IP参考模型（事实标准）</li>\n<li>5层的体系结构（仅供学习）</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"ISO-OSI参考模型——怎么来的？\"   >\n          <a href=\"#ISO-OSI参考模型——怎么来的？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#ISO-OSI参考模型——怎么来的？\" class=\"headerlink\" title=\"ISO/OSI参考模型——怎么来的？\"></a>ISO/OSI参考模型——怎么来的？</h4>\n      <p>为了解决计算机网络复杂的大问题，按功能设计分层结构，目的是支持异构网络系统的互联互通。</p>\n\n        <h4 id=\"ISO-OSI参考模型\"   >\n          <a href=\"#ISO-OSI参考模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#ISO-OSI参考模型\" class=\"headerlink\" title=\"ISO/OSI参考模型\"></a>ISO/OSI参考模型</h4>\n      <ol start=\"7\">\n<li> 应用层</li>\n<li> 表示层</li>\n<li> 会话层</li>\n<li> 传输层</li>\n<li> 网络层</li>\n<li> 数据链路层</li>\n<li> 物理层</li>\n</ol>\n<p>前四层端到端，后三层点到点</p>\n\n        <h4 id=\"应用层\"   >\n          <a href=\"#应用层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h4>\n      <p>所有能和用户交互产生网络流量的程序。</p>\n<ul>\n<li>典型应用层服务：<ul>\n<li>文件传输（FTP）</li>\n<li>电子邮件（SMTP）</li>\n<li>万维网（HTTP）</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"表示层\"   >\n          <a href=\"#表示层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#表示层\" class=\"headerlink\" title=\"表示层\"></a>表示层</h4>\n      <p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>\n<p>功能：</p>\n<ol>\n<li> 数据格式变换</li>\n<li> 数据加密解密</li>\n<li> 数据压缩和恢复</li>\n</ol>\n\n        <h4 id=\"会话层\"   >\n          <a href=\"#会话层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#会话层\" class=\"headerlink\" title=\"会话层\"></a>会话层</h4>\n      <p>向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据。</p>\n<p>这是会话，也是<strong>建立同步(SYN)</strong>.</p>\n<p>功能：</p>\n<ol>\n<li>建立、管理、终止会话</li>\n<li>使用校验点可使会话在通信时效时从<strong>校验点/同步点</strong>继续恢复通信，实现数据同步。<ul>\n<li>适用于传输大文件</li>\n<li>主要协议：ADSP、ASP</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"传输层\"   >\n          <a href=\"#传输层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h4>\n      <p>负责主机中<strong>两个进程</strong>的通信，即<strong>端到端</strong>的通信。传输单位是报文段或用户数据报。</p>\n<p>报文段就是数据切割后封装好形成的。</p>\n<p>功能：</p>\n<ol>\n<li>可靠传输、不可靠传输<ul>\n<li>TCP</li>\n<li>UDP</li>\n</ul>\n</li>\n<li>差错控制<ul>\n<li>校验</li>\n</ul>\n</li>\n<li>流量控制<ul>\n<li>控制发送速度，用来协调</li>\n</ul>\n</li>\n<li>复用分用<ul>\n<li>复用：多个应用层进程可同时使用下面运输层的服务。</li>\n<li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程。</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"网络层\"   >\n          <a href=\"#网络层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h4>\n      <p>主要任务是吧<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是<strong>数据报</strong>。</p>\n<p>功能：</p>\n<ol>\n<li> 路由选择</li>\n</ol>\n<ul>\n<li>根据网络状况规划最佳路径</li>\n</ul>\n<ol start=\"2\">\n<li> 流量控制</li>\n<li> 差错控制</li>\n<li> 拥塞控制</li>\n</ol>\n<ul>\n<li>若所有结点都来不及接收分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采取一定措施，缓解这种拥塞。</li>\n</ul>\n<p>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p>\n\n        <h4 id=\"数据链路层\"   >\n          <a href=\"#数据链路层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h4>\n      <p>主要任务是把网络层传下来的数据报<strong>组装成帧</strong>。</p>\n<p>数据链路层/链路层的传输单位是<strong>帧</strong>。</p>\n<p>功能：</p>\n<ol>\n<li> 成帧(定义帧的开始和结束)</li>\n<li> 差错控制  帧错+位错</li>\n</ol>\n<ul>\n<li>根据出错情况，决定是检错还是丢</li>\n</ul>\n<ol start=\"3\">\n<li> 流量控制</li>\n</ol>\n<ul>\n<li> 根据缓存情况确定，缓存快满了会被要求降速</li>\n</ul>\n<ol start=\"4\">\n<li> 访问（接入）控制</li>\n</ol>\n<ul>\n<li> 控制对共享信道的访问</li>\n</ul>\n<p>主要协议：SDLC、HDLC、PPP、STP</p>\n\n        <h4 id=\"物理层\"   >\n          <a href=\"#物理层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h4>\n      <p>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>。<br>物理层传输单位是<strong>比特</strong>。</p>\n<p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在连路上传送。</p>\n<p>功能：</p>\n<ol>\n<li>定义接口特性</li>\n<li>定义传输模式<ul>\n<li> 单工：只可以发送或接收</li>\n<li> 半双工：可发送也可接收，但不能同时进行</li>\n<li> 双工：可以同时发送和接收</li>\n</ul>\n</li>\n<li> 定义传输速率</li>\n<li> 比特同步</li>\n<li> 比特编码</li>\n</ol>\n<p>主要协议：Rj45、802.3</p>\n\n        <h3 id=\"3-TCP-IP参考模型和5层参考模型\"   >\n          <a href=\"#3-TCP-IP参考模型和5层参考模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-TCP-IP参考模型和5层参考模型\" class=\"headerlink\" title=\"3. TCP/IP参考模型和5层参考模型\"></a>3. TCP/IP参考模型和5层参考模型</h3>\n      <p>TCP/IP参考模型是现有实践，后有的模型</p>\n<p>TCP/IP参考模型：<br>4. 应用层<br>3. 传输层<br>2. 网际层</p>\n<ol>\n<li>网络接口层</li>\n</ol>\n<p>TCP/IP协议栈：<br>4. HTTP|FTP|DNS<br>3. TCP|UDP<br>2. IP</p>\n<ol>\n<li>Ethernet|ATM|Frame Relay</li>\n</ol>\n\n        <h4 id=\"OSI和TCP-IP参考模型相同点\"   >\n          <a href=\"#OSI和TCP-IP参考模型相同点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#OSI和TCP-IP参考模型相同点\" class=\"headerlink\" title=\"OSI和TCP/IP参考模型相同点\"></a>OSI和TCP/IP参考模型相同点</h4>\n      <ol>\n<li>都分层</li>\n<li>基于独立的协议栈概念</li>\n<li>可以实现异构网络互连</li>\n</ol>\n\n        <h4 id=\"OSI模型与TCP-IP模型的不同点\"   >\n          <a href=\"#OSI模型与TCP-IP模型的不同点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#OSI模型与TCP-IP模型的不同点\" class=\"headerlink\" title=\"OSI模型与TCP/IP模型的不同点\"></a>OSI模型与TCP/IP模型的不同点</h4>\n      <ol>\n<li>OSI定义三点：服务、协议、接口</li>\n<li>OSI先出现，参考模型先于协议发明，不偏向特定协议</li>\n<li>TCP/IP设计之初就考虑到异构网互连问题，将IP作为重要层次。</li>\n</ol>\n<ul>\n<li>网络层-IP协议<ul>\n<li>ISO/OSI参考模型<ul>\n<li>无连接</li>\n<li>面向连接</li>\n</ul>\n</li>\n<li>TCP/IP模型<ul>\n<li>无连接</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>传输层<ul>\n<li>ISO/OSI参考模型<ul>\n<li>面向连接</li>\n</ul>\n</li>\n<li>TCP/IP模型<ul>\n<li>无连接</li>\n<li>面向连接</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>面向连接：</p>\n<ol>\n<li>建立连接：发送建立连接请求。</li>\n<li>传输：擦混输数据</li>\n<li>释放连接：切断建立的连接。</li>\n</ol>\n<p>无连接：</p>\n<ol>\n<li>直接传输数据</li>\n</ol>\n\n        <h4 id=\"5层参考模型\"   >\n          <a href=\"#5层参考模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5层参考模型\" class=\"headerlink\" title=\"5层参考模型\"></a>5层参考模型</h4>\n      <ol start=\"5\">\n<li>网络层：支持各种网络应用 FTP、SMTP、HTTP</li>\n<li>传输层：进程-进程之间的数据传输 TCP、UDP</li>\n<li>网络成：源主机到目的主机的数据分组路由与转发 IP、ICMP、OSPE等</li>\n<li>数据链路层： 把网络层传下来的数据报组装成帧 Ethernet、PPP</li>\n<li>物理层：比特传输</li>\n</ol>\n\n        <h1 id=\"第2章——物理层\"   >\n          <a href=\"#第2章——物理层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第2章——物理层\" class=\"headerlink\" title=\"第2章——物理层\"></a>第2章——物理层</h1>\n      \n        <h2 id=\"2-1-通信基础\"   >\n          <a href=\"#2-1-通信基础\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-通信基础\" class=\"headerlink\" title=\"2.1 通信基础\"></a>2.1 通信基础</h2>\n      <ol>\n<li>通信基础</li>\n<li>两个公式 lim <em>重点</em></li>\n<li>看图说话</li>\n<li>传输介质</li>\n<li>物理层设备</li>\n<li>\n        <h3 id=\"1-物理层的基本概念\"   >\n          <a href=\"#1-物理层的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-物理层的基本概念\" class=\"headerlink\" title=\"1. 物理层的基本概念\"></a>1. 物理层的基本概念</h3>\n      </li>\n</ol>\n<p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的差UN属媒体。</p>\n<p>物理层主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性，规格等</p>\n<p>特性：</p>\n<ol>\n<li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、借口形状、引线数目、引脚数量和排列情况。</li>\n<li>电气特性：规定传输二进制位时，线路上信号的<strong>电压范围</strong>、阻抗匹配、传输<strong>速率</strong>和<strong>距离</strong>限制等。</li>\n<li>功能特性：指明某条线上出现的某一<strong>电平表示何种意义</strong>，就扣不见得信号线的用途。</li>\n<li>过程特性（过程特性）：定义各条物理线路的工作<strong>规程和时序</strong>关系。</li>\n</ol>\n\n        <h3 id=\"2-数据通信基础知识\"   >\n          <a href=\"#2-数据通信基础知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-数据通信基础知识\" class=\"headerlink\" title=\"2. 数据通信基础知识\"></a>2. 数据通信基础知识</h3>\n      \n        <h4 id=\"数据通信相关术语\"   >\n          <a href=\"#数据通信相关术语\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据通信相关术语\" class=\"headerlink\" title=\"数据通信相关术语\"></a>数据通信相关术语</h4>\n      <p>通信的目的是<strong>传送消息</strong>。</p>\n<p>数据：传送信息的实体。通常是有意义的符号序列。</p>\n<p>信号：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong>。</p>\n<ul>\n<li>数字信号：代表消息的参数取值是离散的。</li>\n<li>模拟信号：代表消息的参数取值是连续的。</li>\n</ul>\n<p>信源：产生和发送数据的源头。</p>\n<p>信宿：接收数据的重点。</p>\n<p>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p>\n<ul>\n<li>传输信号<ul>\n<li>模拟信道</li>\n<li>梳子信道</li>\n</ul>\n</li>\n<li>传输介质<ul>\n<li>无线信道</li>\n<li>有线信道</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"三种通信方式\"   >\n          <a href=\"#三种通信方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三种通信方式\" class=\"headerlink\" title=\"三种通信方式\"></a>三种通信方式</h4>\n      <ol>\n<li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道。</li>\n<li>半双工通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要<strong>两条</strong>信道。这两条信道都是既可以做发送方也可以做接收方。</li>\n<li>全双工通信：通信双方可以同时发送和接收信息，也需要<strong>两条</strong>信道。</li>\n</ol>\n\n        <h4 id=\"两种数据传输方式\"   >\n          <a href=\"#两种数据传输方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#两种数据传输方式\" class=\"headerlink\" title=\"两种数据传输方式\"></a>两种数据传输方式</h4>\n      <ul>\n<li>串行传输<ul>\n<li>单线程，单信道</li>\n<li>速度慢、费用低、适合远距离</li>\n</ul>\n</li>\n<li>并行传输<ul>\n<li>多线程，多信道</li>\n<li>速度快、费用高、适合计算机内部传输</li>\n<li>打印机、扫描仪的插口就是<strong>并口</strong>（并行传输）</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"3-码元、波特、速率、带宽\"   >\n          <a href=\"#3-码元、波特、速率、带宽\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-码元、波特、速率、带宽\" class=\"headerlink\" title=\"3. 码元、波特、速率、带宽\"></a>3. 码元、波特、速率、带宽</h3>\n      \n        <h4 id=\"码元\"   >\n          <a href=\"#码元\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#码元\" class=\"headerlink\" title=\"码元\"></a>码元</h4>\n      <p><strong>码元</strong>是指一个<strong>固定时长</strong>的<strong>信号波形</strong>(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。</p>\n<p><strong>1码元可以携带多个比特的信息量</strong>。例如，再使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p>\n\n        <h4 id=\"速率、波特、带宽\"   >\n          <a href=\"#速率、波特、带宽\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#速率、波特、带宽\" class=\"headerlink\" title=\"速率、波特、带宽\"></a>速率、波特、带宽</h4>\n      <p>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。</p>\n<ol>\n<li>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可以称为<strong>脉冲个数或信号变化的次数</strong>)，单位是<strong>波特</strong>。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</li>\n<li>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特/秒(b/s)。<ul>\n<li>关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M X b bit/s。</li>\n</ul>\n</li>\n</ol>\n<p>带宽：表示在单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p>\n\n        <h3 id=\"4-奈氏准则和香农定理\"   >\n          <a href=\"#4-奈氏准则和香农定理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-奈氏准则和香农定理\" class=\"headerlink\" title=\"4. 奈氏准则和香农定理\"></a>4. 奈氏准则和香农定理</h3>\n      <p>在这两个定理中带宽用Hz。</p>\n\n        <h4 id=\"失真\"   >\n          <a href=\"#失真\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#失真\" class=\"headerlink\" title=\"失真\"></a>失真</h4>\n      <p>现实中的信道因为带宽受限、有噪声、干扰让信号波形走形</p>\n<p>有的失真仍能被识别，但有的失真无法被识别</p>\n<p>影响失真程度的因素： </p>\n<ol>\n<li> 码元传输速率</li>\n</ol>\n<ul>\n<li> 传输越快，失真程度越严重</li>\n</ul>\n<ol start=\"2\">\n<li> 信号传输距离</li>\n<li> 噪声干扰</li>\n<li> 传输媒体质量</li>\n</ol>\n\n        <h4 id=\"失真的一种现象——码间串扰\"   >\n          <a href=\"#失真的一种现象——码间串扰\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#失真的一种现象——码间串扰\" class=\"headerlink\" title=\"失真的一种现象——码间串扰\"></a>失真的一种现象——码间串扰</h4>\n      <p><strong>信道带宽</strong>是信道能通过的<strong>最高频率和最低频率之差</strong>。</p>\n<p>低带宽会和噪音融合，无法识别，高带宽会造成码间串扰。</p>\n<p>码间串扰：<strong>接收端</strong>收到的信号波形<strong>失去了码元之间清晰界限</strong>的现象。</p>\n\n        <h4 id=\"奈氏准侧-奈奎斯特定理\"   >\n          <a href=\"#奈氏准侧-奈奎斯特定理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#奈氏准侧-奈奎斯特定理\" class=\"headerlink\" title=\"奈氏准侧(奈奎斯特定理)\"></a>奈氏准侧(奈奎斯特定理)</h4>\n      <p>奈氏准则：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p>\n<p>理想低通信道下<code>极限数据传输率=2Wlog2 V(b/s)</code>，其中<code>W</code>是<code>带宽(HZ)</code>,<code>V</code>是<code>几种码元/码元的离散电平数目</code>。</p>\n<ol>\n<li>在任何信道中，<strong>码元传输的速率是有上线的</strong>。若传输速率超过此上线，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li>\n<li>信道的<strong>频带越宽</strong>(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。</li>\n<li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出了限制。</li>\n<li>由于码元的传输速率受奈氏准则的制约，所以要提高数据传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</li>\n</ol>\n\n        <h4 id=\"香农定理\"   >\n          <a href=\"#香农定理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#香农定理\" class=\"headerlink\" title=\"香农定理\"></a>香农定理</h4>\n      <p><strong>噪声</strong>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬间值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的音响是相对的，若信号较强，那么噪声影响相对较小。因此，<strong>信噪比</strong>就很重要。</p>\n<p><code>信噪比 = 信号的平均功率/噪声的平均功率</code>，常记为S/N，应用分贝(dB)作为度量单位，即：<code>信噪比(dB) = 10log10 (S/N)</code> <em>数值等价</em></p>\n<p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</p>\n<p><code>信道的极限数据传输速率 = Wlog2 (1+S/N) (b/s)</code></p>\n<ol>\n<li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong>。</li>\n<li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</li>\n<li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现<strong>无差错的传输</strong>。</li>\n<li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li>\n<li>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限(不可能)，那么新到的极限信息传输速率也就没有上限。</li>\n</ol>\n\n        <h4 id=\"奈氏和香农如何选择\"   >\n          <a href=\"#奈氏和香农如何选择\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#奈氏和香农如何选择\" class=\"headerlink\" title=\"奈氏和香农如何选择\"></a>奈氏和香农如何选择</h4>\n      <ul>\n<li>奈氏准则<ul>\n<li>内忧</li>\n<li>带宽受限无噪声条件下，为了避免码间串扰，码元传输速率的上限<code>2W</code>波特。</li>\n<li>理想低通信道下<code>极限数据传输率 = 2Wlog2 V</code></li>\n<li>想要提高数据率，就要提高带宽/采用更好的编码技术</li>\n</ul>\n</li>\n<li>香农定理<ul>\n<li>外患</li>\n<li>带宽受限有噪声条件下的信息传输速率。</li>\n<li><code>信道的极限数据传输速率 = Wlog2 (1+S/N)</code></li>\n<li>要想提高数据率，就要提高带宽/信噪比</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"5-编码-amp-调制\"   >\n          <a href=\"#5-编码-amp-调制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-编码-amp-调制\" class=\"headerlink\" title=\"5. 编码&amp;调制\"></a>5. 编码&amp;调制</h3>\n      \n        <h4 id=\"基带信号与宽带信号\"   >\n          <a href=\"#基带信号与宽带信号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基带信号与宽带信号\" class=\"headerlink\" title=\"基带信号与宽带信号\"></a>基带信号与宽带信号</h4>\n      <p>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p>\n<ul>\n<li>传输信号<ul>\n<li>模拟信道(传送模拟信号)</li>\n<li>数字信道(传送数字信号)</li>\n</ul>\n</li>\n<li>介质传输<ul>\n<li>无线信道</li>\n<li>有限信道</li>\n</ul>\n</li>\n</ul>\n<p>信道上传送的信号：</p>\n<ul>\n<li><p>基带信号</p>\n<ul>\n<li>将数字信号1和0直接用两种不用的电压表示，再传送到<strong>数字信道</strong>上去传输(基带传输)。<strong>来自信源</strong>的信号，想计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。</li>\n</ul>\n</li>\n<li><p>宽带信号</p>\n<ul>\n<li>将基带信号进行调制后形成的频分复用模拟信号，再传送到<strong>模拟信道</strong>上去传输(宽带传输)。把基带信号经过<strong>载波调制</strong>后，吧信号的<strong>频率范围搬移</strong>到<strong>较高的频段</strong>以便在信道中传输(即仅在一段频率范围内能够通过信道)。</li>\n</ul>\n</li>\n<li><p>在传输距离较近时，计算机网络采用<strong>基带传输</strong>方式(近距离衰减小，从而信号内容不易发生变化)</p>\n</li>\n<li><p>在传输距离较远时，计算机网络采用<strong>宽带传输</strong>方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</p>\n</li>\n</ul>\n\n        <h4 id=\"编码与调制\"   >\n          <a href=\"#编码与调制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#编码与调制\" class=\"headerlink\" title=\"编码与调制\"></a>编码与调制</h4>\n      <ul>\n<li><p>数据<strong>编码</strong>为数字信号</p>\n</li>\n<li><p>数据<strong>调制</strong>为模拟信号</p>\n</li>\n<li><p>数字数据</p>\n<ul>\n<li>通过<strong>数字发送器</strong>转换为数字信号 <em>编码</em></li>\n<li>通过<strong>调制器</strong>转换为模拟信号 <em>调制</em></li>\n</ul>\n</li>\n<li><p>模拟数据</p>\n<ul>\n<li>通过<strong>PCM编码器</strong>转换为数字信号  <em>编码</em></li>\n<li>通过<strong>放大器调制器</strong>转换为模拟信号 <em>调制</em></li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"数字数据编码为数字信号\"   >\n          <a href=\"#数字数据编码为数字信号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数字数据编码为数字信号\" class=\"headerlink\" title=\"数字数据编码为数字信号\"></a>数字数据编码为数字信号</h4>\n      <ol>\n<li>非归零编码(NRZ)<ul>\n<li>高1低0</li>\n<li>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方<strong>难以保持同步</strong>。</li>\n</ul>\n</li>\n<li>曼彻斯特编码<ul>\n<li>将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1；码元0则账号相反。也可以采用相反的规定。该编码的特点是在每一个马院的中间出现电平跳变，位中间的跳变既作时钟信号(可用于同步)，又作数据信号，但它所占的频带宽度是原始基带宽度的两倍。</li>\n<li>每一个码元都被调成两个电平，所以<strong>数据传输速率只有调制速率的二分之一</strong>。</li>\n</ul>\n</li>\n<li>差分曼彻斯特编码<ul>\n<li>前高后低为1</li>\n<li>常用于局域网传输，其规则是：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是。在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。</li>\n</ul>\n</li>\n<li>归零编码(RZ)<ul>\n<li>信号电平在一个码元之内都要恢复到零的这种编码成编码方式。</li>\n</ul>\n</li>\n<li>反向不归零编码(NRZI)<ul>\n<li>信号电平翻转表示0，信号电平不变表示1。</li>\n</ul>\n</li>\n<li>4B/5B编码<ul>\n<li>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%。</li>\n<li>只采用16种对应16种不同的4位码，其他的16种作为控制码(帧的开始和结束，线路的状态信息等)或保留。</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"数字信号调制为模拟信号\"   >\n          <a href=\"#数字信号调制为模拟信号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数字信号调制为模拟信号\" class=\"headerlink\" title=\"数字信号调制为模拟信号\"></a>数字信号调制为模拟信号</h4>\n      <p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制过程和解调过程。</p>\n<ul>\n<li>2ASK调幅<ul>\n<li>0无波1有波。</li>\n</ul>\n</li>\n<li>2FSK调频<ul>\n<li>0低频1高频。</li>\n</ul>\n</li>\n<li>2PSK调相<ul>\n<li>0余弦1正弦。</li>\n</ul>\n</li>\n<li>QAM正交振幅调制(调幅+调相)</li>\n</ul>\n\n        <h4 id=\"模拟数据编码为数字信号\"   >\n          <a href=\"#模拟数据编码为数字信号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#模拟数据编码为数字信号\" class=\"headerlink\" title=\"模拟数据编码为数字信号\"></a>模拟数据编码为数字信号</h4>\n      <p>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现<strong>音频数字化</strong>)。</p>\n<p>最典型的例子就是对音频信号进行编码的脉码调制(<strong>PCM</strong>)，在计算机应用中，能够达到<strong>最高保真水平</strong>的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD\\DVD以及我们常见的WAV文件中均有应用。他主要包括三步：抽样、量化、编码。</p>\n<ol>\n<li>抽样：对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：<code>f采样频率 = 2f信号最高频率</code></li>\n<li>量化：把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</li>\n<li>编码：把量化的结果转换为与之对应的二进制编码。</li>\n</ol>\n\n        <h4 id=\"模拟数据调制为模拟信号\"   >\n          <a href=\"#模拟数据调制为模拟信号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#模拟数据调制为模拟信号\" class=\"headerlink\" title=\"模拟数据调制为模拟信号\"></a>模拟数据调制为模拟信号</h4>\n      <p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。</p>\n\n        <h2 id=\"2-2-物理层传输介质\"   >\n          <a href=\"#2-2-物理层传输介质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-物理层传输介质\" class=\"headerlink\" title=\"2.2 物理层传输介质\"></a>2.2 物理层传输介质</h2>\n      \n        <h3 id=\"传输介质及分类\"   >\n          <a href=\"#传输介质及分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#传输介质及分类\" class=\"headerlink\" title=\"传输介质及分类\"></a>传输介质及分类</h3>\n      <p>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p>\n<p>传输媒体并不是物理层</p>\n<p>传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了<strong>电气特性</strong>，因此能够识别所传送的比特流。</p>\n<ul>\n<li>传输介质<ul>\n<li>导向性传输介质：电磁波被导向沿着固体媒体(铜线/光纤)传播。</li>\n<li>非导向性传播介质：自由空间，介质可以是空气、真空、海水等。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"导向性传输介质——双绞线\"   >\n          <a href=\"#导向性传输介质——双绞线\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#导向性传输介质——双绞线\" class=\"headerlink\" title=\"导向性传输介质——双绞线\"></a>导向性传输介质——双绞线</h3>\n      <p>双绞线是古老、又最常用的传输介质，它用<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的<strong>铜导线</strong>组成。</p>\n<p><strong>绞合可以减少对相邻导线的电磁干扰。</strong></p>\n<ul>\n<li>无屏蔽双绞线</li>\n<li>屏蔽双绞线</li>\n</ul>\n<p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<strong>金属丝</strong>编织成的屏蔽层，这就是**屏蔽双绞线(STP)<strong>，无屏蔽层的双绞线就称为</strong>非屏蔽双绞线(UTP)**。</p>\n<p>双绞线夹克便宜，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，去通信距离一般为几公里到数十公里。距离太原市，对于<strong>模拟信号</strong>，要用<strong>放大器</strong>放大衰减的信号；对于<strong>数字信号</strong>，要用<strong>中继器</strong>将失真的信号整形。</p>\n\n        <h3 id=\"导向性传输介质——同轴电缆\"   >\n          <a href=\"#导向性传输介质——同轴电缆\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#导向性传输介质——同轴电缆\" class=\"headerlink\" title=\"导向性传输介质——同轴电缆\"></a>导向性传输介质——同轴电缆</h3>\n      <p>同轴电缆由<strong>导体铜制芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>组成。按特性阻抗数值不同，通常将同轴电缆分为两类：50欧同轴电缆和75欧同轴电缆。其中，50欧同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用；75欧同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统。</p>\n\n        <h3 id=\"导向性传输介质——光纤\"   >\n          <a href=\"#导向性传输介质——光纤\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#导向性传输介质——光纤\" class=\"headerlink\" title=\"导向性传输介质——光纤\"></a>导向性传输介质——光纤</h3>\n      <p>光纤主要由<strong>纤芯(实心)<strong>和</strong>包层</strong>构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角度将大于入射角。因此，如果入射角足够大，就会出现<strong>全反射</strong>，即光线碰到包层时就会折射回纤芯，这个过程不断重复，光也就沿着光纤传输下去。</p>\n<ul>\n<li>多模光纤<ul>\n<li>易失真，适合近距离传输</li>\n</ul>\n</li>\n<li>单模光纤<ul>\n<li>损耗小，适合远距离传输</li>\n</ul>\n</li>\n</ul>\n<p>光纤易折，一般将数十数百跟光纤捆至一起，形成<strong>光缆</strong>。</p>\n<p>光纤的特点：</p>\n<ol>\n<li>传输损耗小，中继距离长，对远距离传输特别经济。</li>\n<li>抗雷电和电磁干扰性能好。</li>\n<li>无串音干扰，保密性好，也不容易被窃听或截取数据。</li>\n<li>体积小，重量轻。</li>\n</ol>\n\n        <h3 id=\"非导向性传输介质\"   >\n          <a href=\"#非导向性传输介质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#非导向性传输介质\" class=\"headerlink\" title=\"非导向性传输介质\"></a>非导向性传输介质</h3>\n      <ul>\n<li>无线电波<ul>\n<li>较强穿透能力，可远距离传输，广泛用于通信领域(如手机通信)</li>\n<li>信号向<strong>所有方向</strong>传播</li>\n</ul>\n</li>\n<li>微波<ul>\n<li>微波通信频率较高，频段范围宽，因此数据率很高<ul>\n<li>地面微波接力通信</li>\n<li>卫星通信<ul>\n<li>优点<ol>\n<li> 通信容量大</li>\n<li> 距离远</li>\n<li> 覆盖广</li>\n<li> 广播通信和多址通信</li>\n</ol>\n</li>\n<li> 缺点</li>\n</ul>\n<ol>\n<li>传播时延长(250-270ms)</li>\n<li>受气候影响大(eg:强风太阳黑子爆发、日凌)</li>\n<li>误码率较高</li>\n<li>成本高</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>信号<strong>固定方向</strong>传播</li>\n</ul>\n</li>\n<li>红外线、激光<ul>\n<li>把药传输的信号分别<strong>转换为各自的信号格式</strong>，即红外光信号和激光信号，再在空间中传播。</li>\n<li>信号<strong>固定方向</strong>传播</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"2-3-物理层设备\"   >\n          <a href=\"#2-3-物理层设备\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-3-物理层设备\" class=\"headerlink\" title=\"2.3 物理层设备\"></a>2.3 物理层设备</h2>\n      \n        <h3 id=\"中继器\"   >\n          <a href=\"#中继器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#中继器\" class=\"headerlink\" title=\"中继器\"></a>中继器</h3>\n      <p>诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p>\n<p>中继器的功能：对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p>\n<p>中继器的两端：</p>\n<ul>\n<li>两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类</strong>网络的互连，且两个网段速率要相同。</li>\n<li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</li>\n<li>两端可连相同媒体，也可连不同媒体。</li>\n<li>中继器两端的网段一定要是同一个协议。(中继器不会存储转发)</li>\n</ul>\n<p>5-4-3规则：</p>\n<ul>\n<li>网络标准中对信号的延迟范围做了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</li>\n<li>5：最多涉及5个网段</li>\n<li>4：最多经过4个中继器</li>\n<li>3：最多3个段可以挂工作站</li>\n</ul>\n\n        <h3 id=\"集线器-多口中继器\"   >\n          <a href=\"#集线器-多口中继器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#集线器-多口中继器\" class=\"headerlink\" title=\"集线器(多口中继器)\"></a>集线器(多口中继器)</h3>\n      <p>再生，放大信号</p>\n<p>集线器的功能：对信号进行<strong>再生放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p>\n<p>遇到同时两个端口发生碰撞的现象则随机延时后再次通信。</p>\n<p>集线器不能分隔冲突域，所以连在集线器上的工作主机平分带宽。</p>\n\n        <h1 id=\"第3章——数据链路层\"   >\n          <a href=\"#第3章——数据链路层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第3章——数据链路层\" class=\"headerlink\" title=\"第3章——数据链路层\"></a>第3章——数据链路层</h1>\n      \n        <h2 id=\"3-1-数据链路层功能概述\"   >\n          <a href=\"#3-1-数据链路层功能概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-1-数据链路层功能概述\" class=\"headerlink\" title=\"3.1 数据链路层功能概述\"></a>3.1 数据链路层功能概述</h2>\n      <ol>\n<li>链路层的功能</li>\n<li>链路层的两种信道</li>\n<li>局域网、广域网</li>\n<li>链路层的设备</li>\n</ol>\n\n        <h3 id=\"数据链路层基本概述\"   >\n          <a href=\"#数据链路层基本概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据链路层基本概述\" class=\"headerlink\" title=\"数据链路层基本概述\"></a>数据链路层基本概述</h3>\n      <ul>\n<li>结点：主机、路由器</li>\n<li>链路：网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</li>\n<li>数据链路：网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据传输<strong>协议</strong>的硬件和软件加到链路上就构成数据链路。</li>\n<li>帧：链路层的协议数据单元，封装网络层数据报。</li>\n</ul>\n<p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p>\n<p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据<strong>可靠</strong>地传输到相邻结点的目标机网络层。其主要作用是<strong>加强网络层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路。</p>\n<p>功能：</p>\n<ol>\n<li>为网络层提供服务：<ul>\n<li>无确认无连接服务</li>\n<li>有确认无连接服务</li>\n<li>有确认面向连接服务</li>\n</ul>\n</li>\n<li>链路管理：<ul>\n<li>建立</li>\n<li>维持</li>\n<li>释放</li>\n</ul>\n</li>\n<li>组帧</li>\n<li>流量控制</li>\n<li>差错控制(帧错/位错)</li>\n</ol>\n\n        <h2 id=\"3-2-封装成帧和透明传输\"   >\n          <a href=\"#3-2-封装成帧和透明传输\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-2-封装成帧和透明传输\" class=\"headerlink\" title=\"3.2 封装成帧和透明传输\"></a>3.2 封装成帧和透明传输</h2>\n      <p>由于字节计算法中<code>Count</code>字段的脆弱性(其值若有差错将导致灾难性后果)及字符填充实现上的复杂性和不兼容性，目前普遍使用的帧同步法是<strong>比特填充</strong>和<strong>违规编码法</strong>。</p>\n\n        <h3 id=\"封装成帧\"   >\n          <a href=\"#封装成帧\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#封装成帧\" class=\"headerlink\" title=\"封装成帧\"></a>封装成帧</h3>\n      <p><strong>封装成帧</strong>就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p>\n<p>首部和尾部包含许多的控制信息，他们的一个重要作用：<strong>帧定界</strong>(确定帧的界限)。</p>\n<p>帧同步：<strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止。</p>\n<p>组帧的四种方法：</p>\n<ol>\n<li>字符计算法</li>\n<li>字符填充法</li>\n<li>零比特填充法</li>\n<li>违规编码法</li>\n</ol>\n\n        <h3 id=\"透明传输\"   >\n          <a href=\"#透明传输\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#透明传输\" class=\"headerlink\" title=\"透明传输\"></a>透明传输</h3>\n      <p><strong>透明传输</strong>是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。</p>\n<p>当所传输数据中的比特组合恰巧与某一个控制信息完全一样时，就必须才去适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p>\n\n        <h3 id=\"1-字符计算法\"   >\n          <a href=\"#1-字符计算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-字符计算法\" class=\"headerlink\" title=\"1. 字符计算法\"></a>1. 字符计算法</h3>\n      <p>帧首部使用一个计数字段(第一个<strong>字节</strong>，八位)来表明帧内字符数。</p>\n<p>缺点：第一个字符错，整个就错了。</p>\n\n        <h3 id=\"2-字符填充法\"   >\n          <a href=\"#2-字符填充法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-字符填充法\" class=\"headerlink\" title=\"2. 字符填充法\"></a>2. 字符填充法</h3>\n      <p><code>00000001</code>是开始字节，<code>00000100</code>是结束字节</p>\n<p>当传送的帧时由文本文件组成时(文本文件的字符都是从键盘上输入的，都是ASCII码)。不管从键盘上输入什么字符都可以放在帧里传过去，即<strong>透明传输</strong>。</p>\n<p>当传送的帧时由非ASCII码的文本文件组成时(二进制代码的程序或图像等)。就要<strong>采用字符填充方法实现透明传输</strong>。</p>\n<p>使用<code>转义字符ESC</code>在与控制字符<code>SOT、EOT</code>相同的数据转义，就不会造成冲突。</p>\n\n        <h3 id=\"3-零比特填充法\"   >\n          <a href=\"#3-零比特填充法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-零比特填充法\" class=\"headerlink\" title=\"3. 零比特填充法\"></a>3. 零比特填充法</h3>\n      <ol>\n<li>在头尾插入<code>01111110</code></li>\n<li>在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0</li>\n<li>在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删除。</li>\n</ol>\n<p><strong>保证了透明传输：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</strong></p>\n\n        <h3 id=\"4-违规编码\"   >\n          <a href=\"#4-违规编码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-违规编码\" class=\"headerlink\" title=\"4. 违规编码\"></a>4. 违规编码</h3>\n      <p>用不符合规则的编码来界定帧</p>\n<p>如：曼彻斯特编码使用“高-高”、“低-低”的编码充当开始和结束。</p>\n\n        <h2 id=\"3-3-差错控制\"   >\n          <a href=\"#3-3-差错控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-差错控制\" class=\"headerlink\" title=\"3.3 差错控制\"></a>3.3 差错控制</h2>\n      \n        <h3 id=\"3-3-1-检错编码\"   >\n          <a href=\"#3-3-1-检错编码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-1-检错编码\" class=\"headerlink\" title=\"3.3.1 检错编码\"></a>3.3.1 检错编码</h3>\n      \n        <h4 id=\"差错从何而来？\"   >\n          <a href=\"#差错从何而来？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#差错从何而来？\" class=\"headerlink\" title=\"差错从何而来？\"></a>差错从何而来？</h4>\n      <p>概括来说，传输中的差错都是由于噪声引起的。</p>\n<ul>\n<li><p>全局性：</p>\n<ul>\n<li>由于线路本身的电气特性所产生的**随机噪声(热噪声)**，是信道固有的，随机存在的。</li>\n<li>解决办法：提高信噪比来减少或避免干扰(对传感器下手)。</li>\n</ul>\n</li>\n<li><p>局部性：</p>\n<ul>\n<li>外界特定的端在原因造成的<strong>冲击噪声</strong>，是产生差错的主要原因。</li>\n<li>解决办法：通常利用编码技术来解决。</li>\n</ul>\n</li>\n<li><p>差错</p>\n<ul>\n<li>位错<ul>\n<li>比特位出错，1变0，,变1.</li>\n</ul>\n</li>\n<li>帧错<ul>\n<li>丢失</li>\n<li>重复</li>\n<li>失序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>差错控制(比特错)</p>\n<ul>\n<li>检错编码<ul>\n<li>奇偶校验码</li>\n<li>循环冗余码CRC</li>\n</ul>\n</li>\n<li>纠错编码<ul>\n<li>海明码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>编码VS编码：物理链路层编码和物理层的数据编码与调制<strong>不同</strong>物理层编码针对的是<strong>单个比特</strong>，解决传输过程中比特的同步问题，如曼彻斯特编码，而数据链路层的编码针对的是<strong>一组比特</strong>，它通过冗余码的技术实现一组二进制比特串在传输过程是否出现差错。</p>\n<p>冗余编码：在数据发送之前，先按某种关系<strong>附加</strong>上一定的<strong>冗余位</strong>，构成一个符合某一规则的码字后再发送。当然发送的有效数据变化时，相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到码字是否仍符合原则，从而判断是否出错。</p>\n\n        <h4 id=\"奇偶校验码\"   >\n          <a href=\"#奇偶校验码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#奇偶校验码\" class=\"headerlink\" title=\"奇偶校验码\"></a>奇偶校验码</h4>\n      <ul>\n<li>奇偶校验码<ul>\n<li>奇校验码<ul>\n<li>“1”的个数为<strong>奇数</strong>。</li>\n<li>只能检查出<strong>奇数个比特错误</strong>，检错能力为50%。</li>\n</ul>\n</li>\n<li>偶校验码<ul>\n<li>“1”的个数为<strong>偶数</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"CRC循环冗余码\"   >\n          <a href=\"#CRC循环冗余码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#CRC循环冗余码\" class=\"headerlink\" title=\"CRC循环冗余码\"></a>CRC循环冗余码</h4>\n      <p>我操这个数学运算的过程我没法记呀，看到这里就百度吧！</p>\n<p>在数据链路层仅仅使用循环冗余检验CRC差错检测奇数，只能做到对帧的无差错接收，即“凡是接收端数据链路层接受的帧，我们都以非常接近于1的概率认为这些帧再传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”。</p>\n<p>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输，因为有帧被丢弃了。</p>\n\n        <h3 id=\"3-3-2-纠错编码\"   >\n          <a href=\"#3-3-2-纠错编码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-3-2-纠错编码\" class=\"headerlink\" title=\"3.3.2 纠错编码\"></a>3.3.2 纠错编码</h3>\n      \n        <h4 id=\"海明码\"   >\n          <a href=\"#海明码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#海明码\" class=\"headerlink\" title=\"海明码\"></a>海明码</h4>\n      <p>发现双比特错，纠正单比特错</p>\n<p>工作原理：动一发而牵全身</p>\n<p>工作流程：</p>\n<ol>\n<li>确定校验码位数r<ul>\n<li>海明不等式<ul>\n<li><code>2^r &gt;= k+r+1</code></li>\n<li>r为冗余信息位，k为信息位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>确定校验码和数据的位置<ul>\n<li>各位校验码放置至2的n次方位置</li>\n</ul>\n</li>\n<li>求出校验码的值<ul>\n<li>从低位开始取，取所有相应低位为1的数据位的值进行异或</li>\n<li>令所有要校验的为异或=0</li>\n</ul>\n</li>\n<li>检错并纠正<ul>\n<li>正向运算，将结果转成十进制就是出错的位数</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"3-4-流量控制与可靠传输机制\"   >\n          <a href=\"#3-4-流量控制与可靠传输机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-4-流量控制与可靠传输机制\" class=\"headerlink\" title=\"3.4 流量控制与可靠传输机制\"></a>3.4 流量控制与可靠传输机制</h2>\n      \n        <h3 id=\"3-4-1-流量控制与可靠传输机制\"   >\n          <a href=\"#3-4-1-流量控制与可靠传输机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-4-1-流量控制与可靠传输机制\" class=\"headerlink\" title=\"3.4.1 流量控制与可靠传输机制\"></a>3.4.1 流量控制与可靠传输机制</h3>\n      \n        <h4 id=\"数据链路层的流量控制\"   >\n          <a href=\"#数据链路层的流量控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据链路层的流量控制\" class=\"headerlink\" title=\"数据链路层的流量控制\"></a>数据链路层的流量控制</h4>\n      <p><strong>较高的发送速率</strong>和<strong>较低的接受能力</strong>不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p>\n<p>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</p>\n<p>数据链路层流量控制手段：接收方收不下就不回复确认。</p>\n<p>传输层流量控制手段：接收端给发送端一个窗口公告。</p>\n\n        <h4 id=\"流量控制方法\"   >\n          <a href=\"#流量控制方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流量控制方法\" class=\"headerlink\" title=\"流量控制方法\"></a>流量控制方法</h4>\n      <ol>\n<li>停止-等待协议<ul>\n<li>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</li>\n<li>发送窗口大小=1，接收窗口大小=1</li>\n</ul>\n</li>\n<li>滑动窗口协议<ol>\n<li>后退N帧协议(GBN)<ul>\n<li> 发送窗口&gt;=1，接收窗口&gt;=1</li>\n</ul>\n</li>\n<li>选择重传协议(SR)<ul>\n<li>发送窗口&gt;1，接收窗口&gt;1</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n\n        <h4 id=\"可靠传输、滑动窗口、流量控制\"   >\n          <a href=\"#可靠传输、滑动窗口、流量控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#可靠传输、滑动窗口、流量控制\" class=\"headerlink\" title=\"可靠传输、滑动窗口、流量控制\"></a>可靠传输、滑动窗口、流量控制</h4>\n      <p>可靠传输：发送端发啥，接收端收啥</p>\n<p>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧</p>\n<p>滑动窗口解决：</p>\n<ul>\n<li>流量控制<ul>\n<li>收不下就不给确认，想发也发不了</li>\n</ul>\n</li>\n<li>可靠传输<ul>\n<li>发送方自动重传</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"3-4-2-停止等待协议\"   >\n          <a href=\"#3-4-2-停止等待协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-4-2-停止等待协议\" class=\"headerlink\" title=\"3.4.2 停止等待协议\"></a>3.4.2 停止等待协议</h3>\n      \n        <h4 id=\"停止等待协议\"   >\n          <a href=\"#停止等待协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h4>\n      <ol>\n<li>为什么要有停止-等待协议<ul>\n<li>除了比特出差错，底层通信还会出现丢包问题。</li>\n<li>为了实现流量控制</li>\n</ul>\n</li>\n<li>研究停等协议的前提<ul>\n<li>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据(发送方)，一方接收数据(接收方)。</li>\n<li>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。</li>\n<li>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</li>\n</ul>\n</li>\n<li>停等协议有几种应用情况？<ul>\n<li>无差错</li>\n<li>有差错</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"无差错情况\"   >\n          <a href=\"#无差错情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#无差错情况\" class=\"headerlink\" title=\"无差错情况\"></a>无差错情况</h4>\n      <ol>\n<li>数据帧丢失或检测到帧出错<ul>\n<li>超时计时器：每次发送一个帧就启动一个计时器。</li>\n<li>超时计时器设置的重传时间应当比帧传输的平均RTT更长一些。</li>\n<li>发送完一个帧后，必须保留它的副本。</li>\n<li>数据帧和确认帧必须编号。</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"有差错情况\"   >\n          <a href=\"#有差错情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#有差错情况\" class=\"headerlink\" title=\"有差错情况\"></a>有差错情况</h4>\n      <ol>\n<li>ACK丢失<ul>\n<li>超时计时器到时重传，接收方丢弃重复的帧再次发送确认帧</li>\n</ul>\n</li>\n<li>ACK迟到<ul>\n<li>丢弃迟到的确认帧</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"停等协议性能分析\"   >\n          <a href=\"#停等协议性能分析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#停等协议性能分析\" class=\"headerlink\" title=\"停等协议性能分析\"></a>停等协议性能分析</h4>\n      <ol>\n<li>简单</li>\n<li>信道利用率太低</li>\n<li><code>信道利用率U = Td / (Td + RTT + Ta)</code></li>\n</ol>\n\n        <h4 id=\"信道利用率\"   >\n          <a href=\"#信道利用率\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#信道利用率\" class=\"headerlink\" title=\"信道利用率\"></a>信道利用率</h4>\n      <p>发送方在一个发送周期内，有效的发送数据所需要的时间占整个发送周期的比率。</p>\n<p>信道利用率 = (L/C)/T</p>\n<ul>\n<li>L：T内发送L比特数据</li>\n<li>C：发送方数据传输率</li>\n<li>T：发送周期(从开始发送数据，到手刀第一个确认帧为止)</li>\n</ul>\n<p>信道吞吐率 = 信道利用率 * 发送方的发送速率</p>\n\n        <h3 id=\"3-4-3-选择重传协议-SR\"   >\n          <a href=\"#3-4-3-选择重传协议-SR\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-4-3-选择重传协议-SR\" class=\"headerlink\" title=\"3.4.3 选择重传协议(SR)\"></a>3.4.3 选择重传协议(SR)</h3>\n      \n        <h4 id=\"GBN协议的弊端\"   >\n          <a href=\"#GBN协议的弊端\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#GBN协议的弊端\" class=\"headerlink\" title=\"GBN协议的弊端\"></a>GBN协议的弊端</h4>\n      <ul>\n<li>累积确认导致批量重传</li>\n</ul>\n<p>解决办法：设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p>\n\n        <h4 id=\"选择重传协议中的滑动窗口\"   >\n          <a href=\"#选择重传协议中的滑动窗口\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#选择重传协议中的滑动窗口\" class=\"headerlink\" title=\"选择重传协议中的滑动窗口\"></a>选择重传协议中的滑动窗口</h4>\n      \n        <h4 id=\"SR发送方必须响应的三件事\"   >\n          <a href=\"#SR发送方必须响应的三件事\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#SR发送方必须响应的三件事\" class=\"headerlink\" title=\"SR发送方必须响应的三件事\"></a>SR发送方必须响应的三件事</h4>\n      <ol>\n<li>上层的调用<ul>\n<li>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；否则就像GBN一样，要么将数据<strong>缓存</strong>，要么<strong>返回给上层</strong>之后再传输。</li>\n</ul>\n</li>\n<li>收到了一个ACK<ul>\n<li>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界，则窗口向前移动到具有最小序号的未确认帧出。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。</li>\n</ul>\n</li>\n<li>超时事件<ul>\n<li>每个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧</strong>。</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"SR接收方要做的事\"   >\n          <a href=\"#SR接收方要做的事\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#SR接收方要做的事\" class=\"headerlink\" title=\"SR接收方要做的事\"></a>SR接收方要做的事</h4>\n      <p>来者不拒：SR接收方将确认一个正确接收的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧的确认帧【收谁确认谁】，知道所有帧(即序号更小的帧)皆被收到为止，这时才可以将一批帧按序交付给上层，然后<strong>向前移动滑动窗口</strong>。</p>\n\n        <h4 id=\"滑动窗口长度\"   >\n          <a href=\"#滑动窗口长度\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#滑动窗口长度\" class=\"headerlink\" title=\"滑动窗口长度\"></a>滑动窗口长度</h4>\n      <p>接收方不知道同一个0帧是下一个新帧还是重发的旧帧</p>\n<p>发送窗口最好等于接收窗口。(大了会溢出，小了没意义)</p>\n<ul>\n<li>GBN协议中，滑动窗口的最大值是编号数量减一</li>\n<li>SR协议中，滑动窗口的最大值是编号数量的一半</li>\n</ul>\n\n        <h4 id=\"SR协议重点总结\"   >\n          <a href=\"#SR协议重点总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#SR协议重点总结\" class=\"headerlink\" title=\"SR协议重点总结\"></a>SR协议重点总结</h4>\n      <ol>\n<li>对数据帧逐一确认，收一个确认一个</li>\n<li>只重传出错帧</li>\n<li>接收方有缓存</li>\n<li><code>Wtmax = Wrmax = 2^(n-1)</code></li>\n</ol>\n\n        <h3 id=\"3-4-4-后退N帧协议-GBN\"   >\n          <a href=\"#3-4-4-后退N帧协议-GBN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-4-4-后退N帧协议-GBN\" class=\"headerlink\" title=\"3.4.4 后退N帧协议(GBN)\"></a>3.4.4 后退N帧协议(GBN)</h3>\n      <p>流水线技术</p>\n<ol>\n<li>必须增加序号范围</li>\n<li>发送方需要缓存多个分组</li>\n</ol>\n\n        <h4 id=\"后退N帧协议中的滑动窗口\"   >\n          <a href=\"#后退N帧协议中的滑动窗口\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#后退N帧协议中的滑动窗口\" class=\"headerlink\" title=\"后退N帧协议中的滑动窗口\"></a>后退N帧协议中的滑动窗口</h4>\n      <p>发送窗口：发送方维持一组连续的允许发送的帧的序号。</p>\n<p>接收窗口：接收方维持一组连续的允许接收帧的序号</p>\n\n        <h4 id=\"GBN发送方必须相应的三件事\"   >\n          <a href=\"#GBN发送方必须相应的三件事\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#GBN发送方必须相应的三件事\" class=\"headerlink\" title=\"GBN发送方必须相应的三件事\"></a>GBN发送方必须相应的三件事</h4>\n      <ol>\n<li>上层的调用<ul>\n<li>上层要发送数据时，发送方先检查发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧并将其发送；如果<strong>窗口已满</strong>，发送方只需要将数据返回给上层，暗示上层窗口已满。上层等一会再发送。(实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧)。</li>\n</ul>\n</li>\n<li>收到了一个ACK<ul>\n<li>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧。</li>\n</ul>\n</li>\n<li>超时事件<ul>\n<li>协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"GBN接收方要做的事\"   >\n          <a href=\"#GBN接收方要做的事\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#GBN接收方要做的事\" class=\"headerlink\" title=\"GBN接收方要做的事\"></a>GBN接收方要做的事</h4>\n      <p>如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。<br>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息:expectedseqnum(下一个按序接收的帧序号)</p>\n\n        <h4 id=\"滑动窗口长度-1\"   >\n          <a href=\"#滑动窗口长度-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#滑动窗口长度-1\" class=\"headerlink\" title=\"滑动窗口长度\"></a>滑动窗口长度</h4>\n      <p>若采用n个比特对帧编号，那么发送窗口的尺寸Wt应满足<code>1 &lt;= Wt &lt;= 2^(n-1)</code>。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</p>\n\n        <h4 id=\"GBN协议重点总结\"   >\n          <a href=\"#GBN协议重点总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#GBN协议重点总结\" class=\"headerlink\" title=\"GBN协议重点总结\"></a>GBN协议重点总结</h4>\n      <ol>\n<li>累积确认(偶尔捎带确认)</li>\n<li>接收方值按顺序接收帧，不按序无情丢弃</li>\n<li>确认序列号最大的、按序到达的帧</li>\n<li>发送窗口最大为<code>2^(n-1)，接收窗口大小为1</code></li>\n</ol>\n\n        <h2 id=\"3-5-介质访问控制\"   >\n          <a href=\"#3-5-介质访问控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-5-介质访问控制\" class=\"headerlink\" title=\"3.5 介质访问控制\"></a>3.5 介质访问控制</h2>\n      \n        <h3 id=\"3-5-1-信道划分介质访问控制\"   >\n          <a href=\"#3-5-1-信道划分介质访问控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-5-1-信道划分介质访问控制\" class=\"headerlink\" title=\"3.5.1 信道划分介质访问控制\"></a>3.5.1 信道划分介质访问控制</h3>\n      \n        <h4 id=\"传输数据使用的两种链路\"   >\n          <a href=\"#传输数据使用的两种链路\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#传输数据使用的两种链路\" class=\"headerlink\" title=\"传输数据使用的两种链路\"></a>传输数据使用的两种链路</h4>\n      <ul>\n<li>点对点链路<ul>\n<li>两个相邻节点通过一个链路相连，没有第三者。</li>\n</ul>\n</li>\n<li>广播式链路<ul>\n<li>所有主机共享通信介质。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"介质访问控制\"   >\n          <a href=\"#介质访问控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#介质访问控制\" class=\"headerlink\" title=\"介质访问控制\"></a>介质访问控制</h4>\n      <p>介质访问控制的内容就是，采取一定的措施，使得两对节点之间的通信不会发生相互干扰的情况。</p>\n<ul>\n<li>静态划分信道——信道划分介质访问控制<ul>\n<li>频分多路复用FDM</li>\n<li>时分多路复用TDM</li>\n<li>波分多路复用WDM</li>\n<li>码分多路复用CDM</li>\n</ul>\n</li>\n<li>动态分配信道<ul>\n<li>轮询访问介质控制<ul>\n<li>令牌传递协议</li>\n</ul>\n</li>\n<li>随机访问介质访问控制<ul>\n<li>ALOHA协议</li>\n<li>CSMA协议</li>\n<li>CSMA/CD协议</li>\n<li>CSMA/CA协议</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"信道划分介质访问控制\"   >\n          <a href=\"#信道划分介质访问控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#信道划分介质访问控制\" class=\"headerlink\" title=\"信道划分介质访问控制\"></a>信道划分介质访问控制</h4>\n      <p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离开</strong>，把<strong>时域和频域资源</strong>合理地分配给网络上的设备。</p>\n<p>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备<strong>共享信道资源</strong>，提高信道利用率。</p>\n<p>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，<strong>实际就是把广播信道转变为点对点通信</strong>。</p>\n\n        <h4 id=\"频分多路复用FDM\"   >\n          <a href=\"#频分多路复用FDM\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#频分多路复用FDM\" class=\"headerlink\" title=\"频分多路复用FDM\"></a>频分多路复用FDM</h4>\n      <p>用户分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽(频率带宽)资源</strong>。 </p>\n<p>充分利用传输介质带宽，系统<strong>效率较高</strong>；由于技术比较成熟，实现也比较<strong>容易</strong>。</p>\n\n        <h4 id=\"时分多路复用TDM\"   >\n          <a href=\"#时分多路复用TDM\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#时分多路复用TDM\" class=\"headerlink\" title=\"时分多路复用TDM\"></a>时分多路复用TDM</h4>\n      <p>将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用<strong>固定序号的时隙</strong>，所有用户轮流占用信道。</p>\n<p>TDM帧是在物理层传送的比特流所划分的帧，标志一个周期。</p>\n<ul>\n<li>频分复用——并行</li>\n<li>时分复用——并发</li>\n</ul>\n\n        <h4 id=\"统计时分多路复用STDM\"   >\n          <a href=\"#统计时分多路复用STDM\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#统计时分多路复用STDM\" class=\"headerlink\" title=\"统计时分多路复用STDM\"></a>统计时分多路复用STDM</h4>\n      <p>每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的<strong>输入缓存</strong>，然后集中器按顺序依次扫描输入缓存，吧缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。STDM帧不是固定分配时隙，而是按需动态分配时隙。</p>\n\n        <h4 id=\"波分多路复用WDM\"   >\n          <a href=\"#波分多路复用WDM\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#波分多路复用WDM\" class=\"headerlink\" title=\"波分多路复用WDM\"></a>波分多路复用WDM</h4>\n      <p>波分多路复用就是<strong>光的频分多路复用</strong>，在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p>\n\n        <h4 id=\"码分多路复用CDM\"   >\n          <a href=\"#码分多路复用CDM\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#码分多路复用CDM\" class=\"headerlink\" title=\"码分多路复用CDM\"></a>码分多路复用CDM</h4>\n      <ul>\n<li>码分多址CDMA<ul>\n<li>是码分复用的一种方式<ul>\n<li>1个比特分为多个码片/芯片，每一个站点被指定一个唯一的m位的芯片序列。</li>\n<li>发送1时站点发送芯片序列，发送0时发送芯片序列反码(通常把0写成-1)</li>\n<li>如何不打架：多个站点同时发送数据时，要求各个站点芯片序列相互正交</li>\n<li>如何合并：各路数据在信道中被线性相加</li>\n<li>如何分离：合并的数据和源站规格化内积</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>利用了正交的向量内积为0，向量和本身内积为模的特征</p>\n\n        <h3 id=\"3-5-2-ALOHA协议\"   >\n          <a href=\"#3-5-2-ALOHA协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-5-2-ALOHA协议\" class=\"headerlink\" title=\"3.5.2 ALOHA协议\"></a>3.5.2 ALOHA协议</h3>\n      <p>动态分配信道——动态媒体接入控制/多点接入</p>\n<p>特点：信道并非在用户通信时固定分配给用户</p>\n<p>所有用户可随机发送信息</p>\n<p>发送信息时占<strong>全部带宽</strong></p>\n<ul>\n<li>纯ALOHA协议<ul>\n<li>不监听信道，不按时间槽发送，随机重发。</li>\n<li>如果发生冲突，接收方在就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突。</li>\n<li>超时后等一随机时间再重传</li>\n</ul>\n</li>\n<li>时隙ALOHA协议<ul>\n<li>把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信息，若发生冲突，则必须等到下一个时间片开始时刻再发送。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li>\n<li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发。</li>\n</ol>\n\n        <h3 id=\"3-5-3-CSMA协议\"   >\n          <a href=\"#3-5-3-CSMA协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-5-3-CSMA协议\" class=\"headerlink\" title=\"3.5.3 CSMA协议\"></a>3.5.3 CSMA协议</h3>\n      <p>载波监听多路访问协议CSMA(carrier sence multiple access)</p>\n<p>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p>\n<p>当几个站同时在总线上发送数据时，总线上的信号<strong>电压摆动值</strong>将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p>\n<p>MA：多点接入：表示许多计算机以多点接入的方式连接在一根总线上。</p>\n<p>协议思想：发送之前，监听信道</p>\n<ul>\n<li>监听结果<ul>\n<li>信道空闲：发送完整帧<ul>\n<li>1-坚持CSMA</li>\n<li>非坚持CSMA</li>\n<li>p-坚持CSMA</li>\n</ul>\n</li>\n<li>信道忙：推迟发送</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"1-坚持CSMA\"   >\n          <a href=\"#1-坚持CSMA\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-坚持CSMA\" class=\"headerlink\" title=\"1-坚持CSMA\"></a>1-坚持CSMA</h4>\n      <p>坚持指的是对于监听信道忙之后的坚持。</p>\n<p>1-坚持CSMA思想：如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，不必等待。忙则一直监听，直到空闲马上传输。如果有冲突(一段时间未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程。</p>\n<p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。</p>\n<p>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p>\n\n        <h4 id=\"非坚持CSMA\"   >\n          <a href=\"#非坚持CSMA\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#非坚持CSMA\" class=\"headerlink\" title=\"非坚持CSMA\"></a>非坚持CSMA</h4>\n      <p>非坚持指的是监听信道忙之后就不继续监听。</p>\n<p>非坚持CSMA思想：如果一个主机要发送消息，那么它先监听信道。</p>\n<p>空闲则直接传输，不必等待</p>\n<p>忙则等待一个随机的时间之后再进行监听发</p>\n<p>优点：采用随机的重发延时时间可以减少冲突发生的可能性。</p>\n<p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。</p>\n\n        <h4 id=\"p-坚持CSMA\"   >\n          <a href=\"#p-坚持CSMA\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#p-坚持CSMA\" class=\"headerlink\" title=\"p-坚持CSMA\"></a>p-坚持CSMA</h4>\n      <p>p-坚持指的是对于监听信道空闲的处理。</p>\n<p>思想：如果一个主机要发送消息，那么它先监听信道。</p>\n<p>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽在传输。</p>\n<p>忙则等待一个随机的时间之后再进行监听。</p>\n<p>优点：既能像非坚持算法那样减小冲突，又能像1-坚持算法那样减小媒体空闲时间的这种方案。</p>\n<p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p>\n\n        <h3 id=\"3-5-4-轮询访问介质访问控制\"   >\n          <a href=\"#3-5-4-轮询访问介质访问控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-5-4-轮询访问介质访问控制\" class=\"headerlink\" title=\"3.5.4 轮询访问介质访问控制\"></a>3.5.4 轮询访问介质访问控制</h3>\n      <ul>\n<li>介质访问控制：<ul>\n<li>信道划分介质访问控制(MAC)协议：<ul>\n<li>基于多路复用技术划分资源。</li>\n<li>网络负载重：共享信道效率高，且公平</li>\n<li>网络负载轻：共享信道效率低</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>随机访问MAC协议：<ul>\n<li>用户根据意愿随机发送信息，发送信息时可独占信道带宽</li>\n<li>网络负载重：产生冲突开销</li>\n<li>网络负载轻：共享信道效率高，单个结点可利用信道全部带宽</li>\n</ul>\n</li>\n<li>轮询访问MAC协议/轮流协议/轮转访问MAC协议：<ul>\n<li>既要不产生冲突，又要发送时<strong>占全部带宽</strong>。</li>\n<li>轮训协议</li>\n<li>令牌传递协议</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"轮询协议\"   >\n          <a href=\"#轮询协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#轮询协议\" class=\"headerlink\" title=\"轮询协议\"></a>轮询协议</h4>\n      <p>主节点轮流“邀请”从属结点发送数据.</p>\n<ul>\n<li>问题:<ul>\n<li>轮询开销</li>\n<li>等待延迟</li>\n<li>单点故障</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"令牌传递协议\"   >\n          <a href=\"#令牌传递协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#令牌传递协议\" class=\"headerlink\" title=\"令牌传递协议\"></a>令牌传递协议</h4>\n      <p>令牌环网</p>\n<p>TCU转发器</p>\n<p>令牌:一个特殊格式的MAC控制帧,不含任何信息。</p>\n<p>控制信道的使用,确保同一时刻只有一个结点独占信道。</p>\n<p>令牌环网无碰撞。</p>\n<p>每个结点都可以在一定的时间内(令牌持有时间)获得发送数据的权利，并不是无限制地持有令牌，</p>\n<ul>\n<li>问题：<ul>\n<li>令牌开销</li>\n<li>等待延迟</li>\n<li>单点故障</li>\n</ul>\n</li>\n</ul>\n<p>采用令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中。</p>\n\n        <h3 id=\"3-5-5-CSMA-CA协议\"   >\n          <a href=\"#3-5-5-CSMA-CA协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-5-5-CSMA-CA协议\" class=\"headerlink\" title=\"3.5.5 CSMA-CA协议\"></a>3.5.5 CSMA-CA协议</h3>\n      <ul>\n<li>CSMA-CD是对碰撞的检测<ul>\n<li>使用在总线式以太网</li>\n</ul>\n</li>\n<li>CSMA-CA是对碰撞的避免<ul>\n<li>使用在无线局域网</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"CSMA-CA协议工作原理\"   >\n          <a href=\"#CSMA-CA协议工作原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#CSMA-CA协议工作原理\" class=\"headerlink\" title=\"CSMA/CA协议工作原理\"></a>CSMA/CA协议工作原理</h4>\n      <p>名称：载波监听多点接入/碰撞避免</p>\n<p>发送数据前，先检测信道是否空闲</p>\n<p>空闲则发出**RTS(request to send)**，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</p>\n<p>接收端收到RTS后，将响应**CTS(clear to send)**。</p>\n<p>发送端收到CTS后，开始发送数据帧(同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据)。</p>\n<p>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应<strong>ACK帧</strong>。</p>\n<p>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止(采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间)。</p>\n<ul>\n<li>基本方法：<ul>\n<li>预约信道</li>\n<li>ACK帧</li>\n<li>RTS/CTS帧(可选)</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"CSMA-CD与CSMA-CA\"   >\n          <a href=\"#CSMA-CD与CSMA-CA\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#CSMA-CD与CSMA-CA\" class=\"headerlink\" title=\"CSMA/CD与CSMA/CA\"></a>CSMA/CD与CSMA/CA</h4>\n      <ul>\n<li>相同点<ul>\n<li>都需要先监听</li>\n</ul>\n</li>\n<li>不同点<ul>\n<li>传输介质不同</li>\n<li>载波检测方式不同</li>\n<li>目的不同</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"3-6-局域网\"   >\n          <a href=\"#3-6-局域网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-6-局域网\" class=\"headerlink\" title=\"3.6 局域网\"></a>3.6 局域网</h2>\n      \n        <h3 id=\"3-6-1-局域网基本概念和体系结构\"   >\n          <a href=\"#3-6-1-局域网基本概念和体系结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-6-1-局域网基本概念和体系结构\" class=\"headerlink\" title=\"3.6.1 局域网基本概念和体系结构\"></a>3.6.1 局域网基本概念和体系结构</h3>\n      \n        <h4 id=\"局域网\"   >\n          <a href=\"#局域网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#局域网\" class=\"headerlink\" title=\"局域网\"></a>局域网</h4>\n      <p>简称LAN，是指在某一区域内由多态计算机互联成的计算机组，使用<strong>广播信道</strong>。</p>\n<ul>\n<li>特点：<ul>\n<li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一坐或集中的建筑群内</li>\n<li>使用专门铺设的传输介质(双绞线、同轴电缆)进行联网，数据传输速率高(10Mb/s~10Gb/s)。</li>\n<li>通信延迟时间短。误码率低，可靠性较高。</li>\n<li>各站为平等关系，共享传输信道。</li>\n<li>多采用分布式控制和广播式通信，能够进行广播和组播。</li>\n</ul>\n</li>\n</ul>\n<p>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。</p>\n\n        <h4 id=\"局域网拓扑结构\"   >\n          <a href=\"#局域网拓扑结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#局域网拓扑结构\" class=\"headerlink\" title=\"局域网拓扑结构\"></a>局域网拓扑结构</h4>\n      <ul>\n<li>星型拓扑</li>\n<li>总线型拓扑</li>\n<li>环型拓扑</li>\n<li>树型拓扑</li>\n</ul>\n\n        <h4 id=\"局域网传输介质\"   >\n          <a href=\"#局域网传输介质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#局域网传输介质\" class=\"headerlink\" title=\"局域网传输介质\"></a>局域网传输介质</h4>\n      <ul>\n<li>有线局域网<ul>\n<li>双绞线</li>\n<li>同轴电缆</li>\n<li>光纤</li>\n</ul>\n</li>\n<li>无线局域网<ul>\n<li>电磁波</li>\n<li>微博</li>\n<li>激光</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"局域网介质访问控制方法\"   >\n          <a href=\"#局域网介质访问控制方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#局域网介质访问控制方法\" class=\"headerlink\" title=\"局域网介质访问控制方法\"></a>局域网介质访问控制方法</h4>\n      <ol>\n<li>CSMA/CD<ul>\n<li> 常用于<strong>总线型局域网</strong>，也用于树型网络</li>\n</ul>\n</li>\n<li>令牌总线<ul>\n<li>常用于<strong>总线型局域网</strong>，也用于树型网络</li>\n<li>逻辑环</li>\n</ul>\n</li>\n<li>令牌环<ul>\n<li>用于环形局域网</li>\n<li>物理拓扑可能是星型的</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"局域网的分类\"   >\n          <a href=\"#局域网的分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#局域网的分类\" class=\"headerlink\" title=\"局域网的分类\"></a>局域网的分类</h4>\n      <ol>\n<li>以太网<ul>\n<li>以太网是应用最为广泛的局域网，包括标准以太网(10Mbps)、快速以太网(100Mbps)、千兆以太网(1000Mbps)和10G以太网，它们都符合IEEE802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA/CD</li>\n</ul>\n</li>\n<li>令牌环网<ul>\n<li>物理上采用了星形拓扑结构，逻辑上是环形拓扑结构。</li>\n</ul>\n</li>\n<li>FDDI网<ul>\n<li>物理上采用了双环拓扑结构，逻辑上是环形拓扑结构。</li>\n</ul>\n</li>\n<li>ATM网<ul>\n<li>较新型的单元交换技术，使用53字节固定长度的单元进行交换。</li>\n</ul>\n</li>\n<li>无线局域网<ul>\n<li>采用IEEE 802.11标准</li>\n</ul>\n</li>\n</ol>\n\n        <h4 id=\"IEEE-802标准\"   >\n          <a href=\"#IEEE-802标准\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IEEE-802标准\" class=\"headerlink\" title=\"IEEE 802标准\"></a>IEEE 802标准</h4>\n      <ul>\n<li>IEEE 802.3-以太网介质访问控制协议及物理层技术规范</li>\n<li>IEEE 802.5-令牌环网的介质访问控制协议及物理层技术规范</li>\n<li>IEEE 802.8-光纤技术咨询组，提供有关光纤联网的技术咨询</li>\n<li>IEEE 802.11-无线局域网的介质访问控制协议及物理层技术规范</li>\n</ul>\n\n        <h4 id=\"MAC子层和LLC子层\"   >\n          <a href=\"#MAC子层和LLC子层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#MAC子层和LLC子层\" class=\"headerlink\" title=\"MAC子层和LLC子层\"></a>MAC子层和LLC子层</h4>\n      <p>IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的<strong>数据链路层与物理层</strong>，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC层。</p>\n<p>LLC负责识别网络层协议，然后对他们进行封装。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。为网络层提供服务：无确认无连接、面向连接、带确认无连接、高速传输。</p>\n<p>MAC子层的主要功能包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性。</p>\n\n        <h3 id=\"3-6-2-以太网\"   >\n          <a href=\"#3-6-2-以太网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-6-2-以太网\" class=\"headerlink\" title=\"3.6.2 以太网\"></a>3.6.2 以太网</h3>\n      \n        <h4 id=\"以太网概述\"   >\n          <a href=\"#以太网概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#以太网概述\" class=\"headerlink\" title=\"以太网概述\"></a>以太网概述</h4>\n      <p>以太网指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准。以太网使用<strong>CSMA/CD</strong>(载波监听多路访问及冲突检测)技术。</p>\n<ul>\n<li>以太网在局域网各种技术中占<strong>统治性</strong>低位：</li>\n</ul>\n<ol>\n<li>造价低廉(以太网网卡不到100块)；</li>\n<li>是应用最广泛的局域网技术；</li>\n<li>比令牌环网、ATM网便宜，简单；</li>\n<li>满足网络速率要求：10Mb/s-10Hb/s</li>\n</ol>\n\n        <h4 id=\"以太网两个标准\"   >\n          <a href=\"#以太网两个标准\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#以太网两个标准\" class=\"headerlink\" title=\"以太网两个标准\"></a>以太网两个标准</h4>\n      <p>DIX Ethernet V2：第一个局域网产品(以太网)规约。</p>\n<p>IEEE 802.3：IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动)</p>\n\n        <h4 id=\"以太网提供无连接、不可靠的服务\"   >\n          <a href=\"#以太网提供无连接、不可靠的服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#以太网提供无连接、不可靠的服务\" class=\"headerlink\" title=\"以太网提供无连接、不可靠的服务\"></a>以太网提供无连接、不可靠的服务</h4>\n      <ul>\n<li>无连接：发送方和接收方之间无“握手过程”。</li>\n<li>不可靠：不对发送方的数据帧<strong>编号</strong>，接收方不向发送方进行<strong>确认</strong>，差错帧直接丢弃，差错纠正由高层负责。</li>\n</ul>\n<p>以太网只实现无差错接收，不实现可靠传输。</p>\n\n        <h4 id=\"以太网传输介质与拓扑结构的发展\"   >\n          <a href=\"#以太网传输介质与拓扑结构的发展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#以太网传输介质与拓扑结构的发展\" class=\"headerlink\" title=\"以太网传输介质与拓扑结构的发展\"></a>以太网传输介质与拓扑结构的发展</h4>\n      <p>粗同轴电缆-&gt;细同轴电缆-&gt;双绞线+集线器</p>\n<p>总线型-&gt;集线器星型</p>\n<p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。</p>\n<p>以太网拓扑：逻辑上总线型，物理上星型。</p>\n\n        <h4 id=\"10BASE-T以太网\"   >\n          <a href=\"#10BASE-T以太网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#10BASE-T以太网\" class=\"headerlink\" title=\"10BASE-T以太网\"></a>10BASE-T以太网</h4>\n      <p>10BASE-T是传送<strong>基带信号</strong>的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是<strong>无屏蔽双绞线</strong>(UTP)，传输速率是10Mb/s。</p>\n<p>物理上采用星型结构，逻辑上总线型，每段双绞线最长为1000m。</p>\n<p>采用曼彻斯特编码。</p>\n<p>采用CSMA/CD介质介质访问控制。</p>\n\n        <h4 id=\"适配器与MAC地址\"   >\n          <a href=\"#适配器与MAC地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#适配器与MAC地址\" class=\"headerlink\" title=\"适配器与MAC地址\"></a>适配器与MAC地址</h4>\n      <p>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。</p>\n<ul>\n<li>网络接口板</li>\n<li>网络接口卡NIC(Network Interface Card)</li>\n<li>现在，不再使用单独网卡。</li>\n<li>适配器上装有处理器和存储器(包括RAM和ROM)</li>\n<li>ROM上有计算机硬件地址<strong>MAC地址</strong>。</li>\n</ul>\n<p>在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符】</p>\n<p>MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家(由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8c-e4-b1-21.</p>\n<p>可以通过MAC地址查生产厂商，可以用来鉴别苹果是不是正品。</p>\n\n        <h4 id=\"以太网MAC帧\"   >\n          <a href=\"#以太网MAC帧\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#以太网MAC帧\" class=\"headerlink\" title=\"以太网MAC帧\"></a>以太网MAC帧</h4>\n      <p>最常用的MAC帧是以太网V2的格式</p>\n<p>数据的范围是46-1500字节。</p>\n<ul>\n<li>与IEEE 802.3的区别：<ol>\n<li>第三个字段时长度/类型</li>\n<li>当长度/类型字段值小于0x0600时，数据字段必须装入LLC子层。</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"高速以太网\"   >\n          <a href=\"#高速以太网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#高速以太网\" class=\"headerlink\" title=\"高速以太网\"></a>高速以太网</h4>\n      <p>速率&gt;=100Mb/s的以太网称为高速以太网。</p>\n<ol>\n<li>100BASE-T以太网<ul>\n<li>在双绞线上传送100Mb/s<strong>基带信号</strong>的<strong>星型</strong>拓扑以太网，仍使用IEEE802.3的<strong>CSMA/CD</strong>协议。支持<strong>全双工</strong>和<strong>半双工</strong>，可以在全双工方式下工作而无冲突。</li>\n</ul>\n</li>\n<li>吉比特以太网<ul>\n<li>在<strong>光纤或双绞线</strong>上传送<strong>1Gb/s信号</strong>。</li>\n<li>支持<strong>全双工</strong>和<strong>半双工</strong>，可在全双工方式下工作而无冲突。</li>\n</ul>\n</li>\n<li>10吉比特<ul>\n<li>10吉比特以太网在<strong>光纤</strong>上传送10Gb/s信号。</li>\n<li>只支持<strong>全双工</strong>，无争用问题。</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"3-6-3-无线局域网\"   >\n          <a href=\"#3-6-3-无线局域网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-6-3-无线局域网\" class=\"headerlink\" title=\"3.6.3 无线局域网\"></a>3.6.3 无线局域网</h3>\n      \n        <h4 id=\"IEEE-802-11\"   >\n          <a href=\"#IEEE-802-11\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IEEE-802-11\" class=\"headerlink\" title=\"IEEE 802.11\"></a>IEEE 802.11</h4>\n      <p>IEEE802.11是<strong>无线局域网</strong>通用的标准，它是由IEEE所定义的无线网络通信的标准</p>\n\n        <h4 id=\"802-11的MAC帧头格式\"   >\n          <a href=\"#802-11的MAC帧头格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#802-11的MAC帧头格式\" class=\"headerlink\" title=\"802.11的MAC帧头格式\"></a>802.11的MAC帧头格式</h4>\n      <ul>\n<li>地址1：RA接收端</li>\n<li>地址2：TA发送端</li>\n<li>地址3：目的地址</li>\n<li>地址4：SA源地址</li>\n</ul>\n\n        <h4 id=\"无线局域网的分类\"   >\n          <a href=\"#无线局域网的分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#无线局域网的分类\" class=\"headerlink\" title=\"无线局域网的分类\"></a>无线局域网的分类</h4>\n      <ol>\n<li>有固定基础设施无线局域网</li>\n<li>无固定基础设施无线局域网的自组织网络</li>\n</ol>\n\n        <h3 id=\"3-6-4-CSMA-CD协议\"   >\n          <a href=\"#3-6-4-CSMA-CD协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-6-4-CSMA-CD协议\" class=\"headerlink\" title=\"3.6.4 CSMA/CD协议\"></a>3.6.4 CSMA/CD协议</h3>\n      <p>载波监听多点接入/碰撞检测CSMA/CD(carrier sense multiple access with collision detection)</p>\n<p>CS：载波侦听/监听，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>都要检测一下总线上是否有其他计算机在发送数据。</p>\n<p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上，总线型网络。</p>\n<p>CD：碰撞检测(冲突检测)，“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。半双工网络</p>\n\n        <h4 id=\"为什么先听后发还会冲突？\"   >\n          <a href=\"#为什么先听后发还会冲突？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#为什么先听后发还会冲突？\" class=\"headerlink\" title=\"为什么先听后发还会冲突？\"></a>为什么先听后发还会冲突？</h4>\n      <p>因为电磁波在总线上总是以有限的速率传播，</p>\n\n        <h4 id=\"传播时延对载波监听的影响\"   >\n          <a href=\"#传播时延对载波监听的影响\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#传播时延对载波监听的影响\" class=\"headerlink\" title=\"传播时延对载波监听的影响\"></a>传播时延对载波监听的影响</h4>\n      <p>最多是两倍的总线端到端的传播时延(2τ)</p>\n<p>总线的端到端往返传播时延</p>\n<p>争用期/冲突窗口/碰撞窗口</p>\n<p>只要经过2τ时间还没有检测到碰撞，就肯定这次发送不会发生碰撞。</p>\n\n        <h4 id=\"如何确定碰撞后的重传时机\"   >\n          <a href=\"#如何确定碰撞后的重传时机\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何确定碰撞后的重传时机\" class=\"headerlink\" title=\"如何确定碰撞后的重传时机\"></a>如何确定碰撞后的重传时机</h4>\n      <ul>\n<li>截断二进制指数规避算法<ol>\n<li>确定基本退避(推迟)时间为争用期2τ</li>\n<li>定义参数k，它等于<strong>重传次数</strong>，但k不超过10，即k=min[重传次数,10]。当重传次数不超过10时，k等于重传次数；当重传次数大于10时，k就不再增大而一直等于10。</li>\n<li>从离散的整数集合[0,1,……,2^K-1]中随机取出一个数r,重传所需要退避的时间就是<strong>r倍的基本退避时间</strong>，即2rτ。</li>\n<li>当重传达<strong>16次</strong>仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li>\n</ol>\n</li>\n</ul>\n<p>若连续多次发生冲突，就表明可能有<strong>较多的站参与争用</strong>信道。使用此算法可使重传需要推迟的平均时间随重传次数的增大而增大，因而减小发生碰撞的概率，有利于整个系统的稳定。</p>\n\n        <h4 id=\"最小帧长问题\"   >\n          <a href=\"#最小帧长问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最小帧长问题\" class=\"headerlink\" title=\"最小帧长问题\"></a>最小帧长问题</h4>\n      <p>帧的传输时延至少要两倍于信号在总线中的传输时延</p>\n<p>最小帧长 = 总线传播时延X数据传输速率X2</p>\n<p>2τ X 数据传输速率</p>\n<p>以太网规定2τ=51.2μs，对于10Mb/s的以太网，最短帧长=64B</p>\n<p>以太网规定最短帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧。</p>\n\n        <h2 id=\"3-7-PPP协议和HDLC协议\"   >\n          <a href=\"#3-7-PPP协议和HDLC协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-7-PPP协议和HDLC协议\" class=\"headerlink\" title=\"3.7 PPP协议和HDLC协议\"></a>3.7 PPP协议和HDLC协议</h2>\n      \n        <h3 id=\"广域网\"   >\n          <a href=\"#广域网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#广域网\" class=\"headerlink\" title=\"广域网\"></a>广域网</h3>\n      <p>广域网(WAN)，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个州并能提供远距离通信，形成国际性的远程网络。</p>\n<p>广域网的通信子网主要使用<strong>分组交换</strong>技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<strong>资源共享</strong>的目的。如因特网是世界范围内最大的广域网。</p>\n\n        <h3 id=\"PPP协议\"   >\n          <a href=\"#PPP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#PPP协议\" class=\"headerlink\" title=\"PPP协议\"></a>PPP协议</h3>\n      <p>点对点协议PPP是目前使用最广泛的数据层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。</p>\n<p>只支持全双工链路</p>\n\n        <h4 id=\"PPP协议应满足的要求\"   >\n          <a href=\"#PPP协议应满足的要求\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#PPP协议应满足的要求\" class=\"headerlink\" title=\"PPP协议应满足的要求\"></a>PPP协议应满足的要求</h4>\n      <ul>\n<li>简单<ul>\n<li>对于链路层的帧，无需纠错，无需序号，无需流量控制</li>\n</ul>\n</li>\n<li>封装成帧<ul>\n<li>帧定界符</li>\n</ul>\n</li>\n<li>透明传输<ul>\n<li>与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充。</li>\n</ul>\n</li>\n<li>多种网络层协议<ul>\n<li>封装的IP数据报可以采用多种协议</li>\n</ul>\n</li>\n<li>多种类型链路<ul>\n<li>串行/并行，同步/异步，电/光……</li>\n</ul>\n</li>\n<li>差错检测<ul>\n<li>错就丢弃。</li>\n</ul>\n</li>\n<li>检测连接状态<ul>\n<li>链路是否正常工作</li>\n</ul>\n</li>\n<li>最大传输单元<ul>\n<li>数据部分最大长度MTU。</li>\n</ul>\n</li>\n<li>网络层地址协商<ul>\n<li>知道通信双方的网络层地址。</li>\n</ul>\n</li>\n<li>数据压缩协商</li>\n</ul>\n\n        <h4 id=\"PPP协议无需满足的要求\"   >\n          <a href=\"#PPP协议无需满足的要求\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#PPP协议无需满足的要求\" class=\"headerlink\" title=\"PPP协议无需满足的要求\"></a>PPP协议无需满足的要求</h4>\n      <ul>\n<li>纠错</li>\n<li>流量控制</li>\n<li>序号</li>\n<li>不支持多点线路</li>\n</ul>\n\n        <h4 id=\"PPP协议的三个组成部分\"   >\n          <a href=\"#PPP协议的三个组成部分\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#PPP协议的三个组成部分\" class=\"headerlink\" title=\"PPP协议的三个组成部分\"></a>PPP协议的三个组成部分</h4>\n      <ol>\n<li>一个将IP数据报封装到串行链路(同步串行/异步串行)的方法。</li>\n<li>链路控制协议LCP：建立并维护数据链路连接。身份验证</li>\n<li>网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li>\n</ol>\n\n        <h3 id=\"HDLC协议\"   >\n          <a href=\"#HDLC协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HDLC协议\" class=\"headerlink\" title=\"HDLC协议\"></a>HDLC协议</h3>\n      <p>高级数据链路控制，是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议，它是由国际标准化组织根据IBM公司的SDLC协议扩展开发而成的。</p>\n<p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现。</p>\n<p>采用全双工通信。</p>\n<p>所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高。</p>\n\n        <h4 id=\"HDLC的站\"   >\n          <a href=\"#HDLC的站\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HDLC的站\" class=\"headerlink\" title=\"HDLC的站\"></a>HDLC的站</h4>\n      <ol>\n<li>主站 <ul>\n<li>发送命令(包括数据信息)帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</li>\n</ul>\n</li>\n<li>从站<ul>\n<li>从站的主要功能是接收由主站发来的命令帧，由主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li>\n</ul>\n</li>\n<li>复合站<ul>\n<li>复合站的主要功能是既能发送，又能接收命令帧和相应帧，并且负责整个链路的控制。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>三种数据的操作方式：<ol>\n<li>正常响应方式</li>\n<li>异步平衡方式</li>\n<li>异步响应方式</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"HDLC的帧格式\"   >\n          <a href=\"#HDLC的帧格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HDLC的帧格式\" class=\"headerlink\" title=\"HDLC的帧格式\"></a>HDLC的帧格式</h4>\n      <ol>\n<li>信息帧(I)第一位用0，用来<strong>传输数据信息</strong>，或使用捎带技术对数据进行确认。</li>\n<li>监督帧(S)10，用于<strong>流量控制和差错控制</strong>，执行对信息帧的确认、请求重发和请求暂停发送等功能。</li>\n<li>无编号帧(U)111用于提供对<strong>链路</strong>的建立、拆除等多种控制功能。</li>\n</ol>\n<p>无奸细</p>\n\n        <h3 id=\"PPP协议-amp-HDLC协议\"   >\n          <a href=\"#PPP协议-amp-HDLC协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#PPP协议-amp-HDLC协议\" class=\"headerlink\" title=\"PPP协议&amp;HDLC协议\"></a>PPP协议&amp;HDLC协议</h3>\n      <p>HDLC、PPP只支持<strong>全双工</strong>链路。</p>\n<p>都可以实现透明传输</p>\n<p>都可以实现差错检测，但不纠正差错</p>\n<p>PPP协议是面向字节的，HDLC协议是面向比特的。</p>\n<p>PPP协议无序号和确认机制，HDLC协议有编号和确认机制。</p>\n<p>PPP协议不可靠，HDLC协议可靠</p>\n\n        <h2 id=\"3-8-链路层设备\"   >\n          <a href=\"#3-8-链路层设备\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-8-链路层设备\" class=\"headerlink\" title=\"3.8 链路层设备\"></a>3.8 链路层设备</h2>\n      \n        <h3 id=\"物理层扩展以太网\"   >\n          <a href=\"#物理层扩展以太网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#物理层扩展以太网\" class=\"headerlink\" title=\"物理层扩展以太网\"></a>物理层扩展以太网</h3>\n      \n        <h3 id=\"链路层扩展以太网\"   >\n          <a href=\"#链路层扩展以太网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#链路层扩展以太网\" class=\"headerlink\" title=\"链路层扩展以太网\"></a>链路层扩展以太网</h3>\n      <p><strong>网桥</strong>根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后在确定将该帧转发到哪一个接口，或者把它丢弃(即过滤)。</p>\n<p>网段：一般指一个计算机网络中使用同一物理设备(传输介质，中继器，集线器等)能够直接通讯的那一部分。</p>\n<ul>\n<li>网桥优点<ol>\n<li>过滤通信量，增大吞吐量</li>\n<li>扩大了物理传输范围</li>\n<li>提高了可靠性</li>\n<li>可互联不同物理层、不同MAC子层和不同速率的以太网。</li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"网桥分类——透明网桥\"   >\n          <a href=\"#网桥分类——透明网桥\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网桥分类——透明网桥\" class=\"headerlink\" title=\"网桥分类——透明网桥\"></a>网桥分类——透明网桥</h3>\n      <p>透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——自学习。</p>\n\n        <h3 id=\"网桥分类——源路由网桥\"   >\n          <a href=\"#网桥分类——源路由网桥\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网桥分类——源路由网桥\" class=\"headerlink\" title=\"网桥分类——源路由网桥\"></a>网桥分类——源路由网桥</h3>\n      <p>源路由网桥：在发送帧时，吧详细的最佳路由信息(路由最少/时间最短)放在帧的首部中。</p>\n<p>方法：源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong>。</p>\n\n        <h4 id=\"多接口网桥——以太网交换机\"   >\n          <a href=\"#多接口网桥——以太网交换机\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#多接口网桥——以太网交换机\" class=\"headerlink\" title=\"多接口网桥——以太网交换机\"></a>多接口网桥——以太网交换机</h4>\n      <p>独占媒体带宽</p>\n\n        <h4 id=\"以太网交换机的两种交换方式\"   >\n          <a href=\"#以太网交换机的两种交换方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#以太网交换机的两种交换方式\" class=\"headerlink\" title=\"以太网交换机的两种交换方式\"></a>以太网交换机的两种交换方式</h4>\n      <ul>\n<li>直通式交换机<ul>\n<li>查完目的地址(6B)就立刻转发</li>\n<li>延迟小，可靠性低，无法支持具有不同速率的端口的交换</li>\n</ul>\n</li>\n<li>存储转发式交换机<ul>\n<li>将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃。</li>\n<li>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"冲突域和广播域\"   >\n          <a href=\"#冲突域和广播域\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#冲突域和广播域\" class=\"headerlink\" title=\"冲突域和广播域\"></a>冲突域和广播域</h4>\n      <p>冲突域：在同一个冲突域中的每一个结点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。</p>\n<p>广播域：网络中能接收任意设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为一个广播域.</p>\n\n        <h1 id=\"第4章——网络层\"   >\n          <a href=\"#第4章——网络层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第4章——网络层\" class=\"headerlink\" title=\"第4章——网络层\"></a>第4章——网络层</h1>\n      \n        <h2 id=\"4-1-网络层的功能\"   >\n          <a href=\"#4-1-网络层的功能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-网络层的功能\" class=\"headerlink\" title=\"4.1 网络层的功能\"></a>4.1 网络层的功能</h2>\n      \n        <h3 id=\"4-1-1-网络层功能概述\"   >\n          <a href=\"#4-1-1-网络层功能概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-1-网络层功能概述\" class=\"headerlink\" title=\"4.1.1 网络层功能概述\"></a>4.1.1 网络层功能概述</h3>\n      <p>主要任务是把<strong>分组</strong>从源端传送到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是<strong>数据报</strong>。</p>\n<ul>\n<li>功能一：路由选择与分组转发<ul>\n<li>最佳路径</li>\n</ul>\n</li>\n<li>功能二：异构网络互连</li>\n<li>功能三：拥塞控制<ul>\n<li>若所有结点都来不及接收分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态，因此要采取一定措施，缓解这种拥塞。<ul>\n<li>开环控制(静态)</li>\n<li>闭环控制(动态)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"4-1-2-电路交换、报文交换与分组交换\"   >\n          <a href=\"#4-1-2-电路交换、报文交换与分组交换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-2-电路交换、报文交换与分组交换\" class=\"headerlink\" title=\"4.1.2 电路交换、报文交换与分组交换\"></a>4.1.2 电路交换、报文交换与分组交换</h3>\n      <ol>\n<li>电路交换<ul>\n<li>电话网络</li>\n<li>建立连接-&gt;通信-&gt;释放连接</li>\n<li>独占资源</li>\n<li>优点：<ul>\n<li>通信时延小</li>\n<li>有序传输</li>\n<li>没有冲突</li>\n<li>实时性强</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>建立连接时间长</li>\n<li>线路独占，使用效率低</li>\n<li>灵活性差</li>\n<li>无差错控制能力</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>报文交换<ul>\n<li>报文：源应用发送的信息整体</li>\n<li>优点：<ul>\n<li>无需建立连接</li>\n<li>存储转发，动态分配线路</li>\n<li>线路可靠性较高</li>\n<li>线路利用率较高</li>\n<li>多目标服务</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>有存储转发时延</li>\n<li>报文大小不定，需要网络结点有较大缓存空间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>分组交换<ul>\n<li>分组：把大的数据块分隔成小的数据块</li>\n<li>优点：<ul>\n<li>无需建立连接</li>\n<li>存储转发，动态分配线路</li>\n<li>线路可靠性较高</li>\n<li>线路利用率较高</li>\n<li>相对于报文交换，存储管理更容易</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>有存储转发时延</li>\n<li>需要传输额外的信息量</li>\n<li>乱序到目的主机时，要对分组排序重组</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>计算题中要注意的几点：</p>\n<ol>\n<li>单位换算 1B=8b</li>\n<li>是否考虑传播延迟</li>\n<li>时间至少是多少——选择最少跳数</li>\n<li>起始时间</li>\n<li>是否有分组头部大小的开销</li>\n<li>报文交换时延更长，分组交换时延可能不是整数</li>\n</ol>\n\n        <h4 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4>\n      <ol>\n<li>报文交换和分组交换都采用存储转发</li>\n<li>传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。</li>\n<li>从信道利用率看，报文交换和分组交换优于电路交换，其中分组交换时延更小。</li>\n</ol>\n\n        <h3 id=\"4-1-3-数据报与虚电路\"   >\n          <a href=\"#4-1-3-数据报与虚电路\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-1-3-数据报与虚电路\" class=\"headerlink\" title=\"4.1.3 数据报与虚电路\"></a>4.1.3 数据报与虚电路</h3>\n      <ul>\n<li><p>数据报方式为网络层提供<strong>无连接服务</strong></p>\n</li>\n<li><p>虚电路方式为网络层提供<strong>连接服务</strong></p>\n</li>\n<li><p>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>\n</li>\n<li><p>连接服务：首先为分子的传输确定传输路径(建立连接)，然后烟该路径(连接)传输系列分组，系列分子传输路径相同，传输结束后超出连接。</p>\n</li>\n</ul>\n\n        <h4 id=\"几种传输单元名词辨析\"   >\n          <a href=\"#几种传输单元名词辨析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#几种传输单元名词辨析\" class=\"headerlink\" title=\"几种传输单元名词辨析\"></a>几种传输单元名词辨析</h4>\n      <ul>\n<li>应用层：报文</li>\n<li>传输层：报文段</li>\n<li>网络层：IP数据报，并在IP数据报过大时进行切割，形成分组。包含IP源地址和目的地址</li>\n<li>数据链路层：帧。加头加尾</li>\n<li>物理层：比特流</li>\n</ul>\n\n        <h4 id=\"数据报\"   >\n          <a href=\"#数据报\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#数据报\" class=\"headerlink\" title=\"数据报\"></a>数据报</h4>\n      <p>无连接</p>\n<p>每个分组携带源和目的地址</p>\n<p>路由器根据分组的目的地址转发分组：基于路由协议/算法构建转发表；检索转发表；每个分组独立选路。</p>\n\n        <h4 id=\"虚电路\"   >\n          <a href=\"#虚电路\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#虚电路\" class=\"headerlink\" title=\"虚电路\"></a>虚电路</h4>\n      <p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点。</p>\n<p>虚电路：一张源主机到目的主机类似于网络的路径(逻辑连接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路信息。</p>\n<ol>\n<li>建立连接(虚电路建立)<ul>\n<li>每个分组携带<strong>虚电路号</strong>，而非目的地址。源主机发送“呼叫请求”分组并收到“呼叫应答”分组后才算建立连接。</li>\n</ul>\n</li>\n<li>数据传输<ul>\n<li>全双工通信</li>\n</ul>\n</li>\n<li>释放连接(虚电路释放)<ul>\n<li>源主机发送“释放请求”分组以拆除虚电路。</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"4-2-路由算法与路由协议概述\"   >\n          <a href=\"#4-2-路由算法与路由协议概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-2-路由算法与路由协议概述\" class=\"headerlink\" title=\"4.2 路由算法与路由协议概述\"></a>4.2 路由算法与路由协议概述</h3>\n      \n        <h4 id=\"路由算法\"   >\n          <a href=\"#路由算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#路由算法\" class=\"headerlink\" title=\"路由算法\"></a>路由算法</h4>\n      <p>最佳路由：“最佳”只能是相对于某一特定要求下的出的较为合理的选择而已。</p>\n\n        <h4 id=\"路由算法分类\"   >\n          <a href=\"#路由算法分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#路由算法分类\" class=\"headerlink\" title=\"路由算法分类\"></a>路由算法分类</h4>\n      <ul>\n<li><p>静态路由算法</p>\n<ul>\n<li>非自适应路由算法</li>\n<li>管理员手工配置路由信息</li>\n<li>简单、可靠，在复合稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。</li>\n<li>路由更新慢，不适用于大型网络</li>\n</ul>\n</li>\n<li><p>动态路由算法</p>\n<ul>\n<li>自适应路由算法</li>\n<li>路由器之间彼此交换信息，按照路由算法优化出路由表项</li>\n<li>路由更新快，使用大型网络，及时响应链路费用或网络拓扑变化。</li>\n<li>算法复杂，增加网络负担。</li>\n</ul>\n</li>\n<li><p>动态路由算法</p>\n<ul>\n<li>全局性<ul>\n<li>链路状态路由算法 OSPF</li>\n<li>所有路由器掌握完整的网络拓扑和链路费用信息。</li>\n</ul>\n</li>\n<li>分散性<ul>\n<li>距离向量算法 RIP</li>\n<li>路由器只掌握物理相连的邻居及路由费用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"分层次的路由选择协议\"   >\n          <a href=\"#分层次的路由选择协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分层次的路由选择协议\" class=\"headerlink\" title=\"分层次的路由选择协议\"></a>分层次的路由选择协议</h4>\n      <ol>\n<li>因特网规模很大</li>\n<li>许多单位不想让外界知道自己的路由选择协议，但还想炼乳因特网</li>\n</ol>\n<p>自制系统AS：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由协议和共同的度量以确定分组在该AS内的路由，同时还是用一种AS之间的路由协议以确定在AS之间的路由</p>\n<p>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。</p>\n<ul>\n<li>路由选择协议<ul>\n<li>内部网关协议IGP<ul>\n<li>RIP、OSPF</li>\n</ul>\n</li>\n<li>外部网关协议EGP<ul>\n<li>BGP</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"4-3-IPv4\"   >\n          <a href=\"#4-3-IPv4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-IPv4\" class=\"headerlink\" title=\"4.3 IPv4\"></a>4.3 IPv4</h3>\n      \n        <h3 id=\"4-3-1-IP数据报格式\"   >\n          <a href=\"#4-3-1-IP数据报格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-1-IP数据报格式\" class=\"headerlink\" title=\"4.3.1 IP数据报格式\"></a>4.3.1 IP数据报格式</h3>\n      \n        <h4 id=\"TCP-IP协议栈\"   >\n          <a href=\"#TCP-IP协议栈\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP-IP协议栈\" class=\"headerlink\" title=\"TCP/IP协议栈\"></a>TCP/IP协议栈</h4>\n      \n        <h3 id=\"4-3-2-IP数据报分片\"   >\n          <a href=\"#4-3-2-IP数据报分片\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-2-IP数据报分片\" class=\"headerlink\" title=\"4.3.2 IP数据报分片\"></a>4.3.2 IP数据报分片</h3>\n      <p>数据链路帧可封装数据的上限。</p>\n<p>以太网的MTU是1500字节。</p>\n<p>超过了1500字节就要分片。</p>\n<ul>\n<li>中间位DF：<ul>\n<li>DF = 1，禁止分片</li>\n<li>DF = 0，允许分片</li>\n</ul>\n</li>\n<li>最低位MF：<ul>\n<li>MF = 1,后面“还有分片”</li>\n<li>MF = 0，代表最后一片了，后面没有分片</li>\n</ul>\n</li>\n</ul>\n<p>片偏移：指出较长分组分片后，某片以原分组中的相对位置，以8B为单位。</p>\n<p>除了最后一个片，每个分片长度一定是8B的整数倍。</p>\n\n        <h3 id=\"4-3-3-IPv4地址\"   >\n          <a href=\"#4-3-3-IPv4地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-3-IPv4地址\" class=\"headerlink\" title=\"4.3.3 IPv4地址\"></a>4.3.3 IPv4地址</h3>\n      \n        <h4 id=\"IP编址的历史阶段\"   >\n          <a href=\"#IP编址的历史阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IP编址的历史阶段\" class=\"headerlink\" title=\"IP编址的历史阶段\"></a>IP编址的历史阶段</h4>\n      <ul>\n<li>分类的IP地址</li>\n<li>子网的划分</li>\n<li>构成超网</li>\n</ul>\n\n        <h4 id=\"分类的IP地址\"   >\n          <a href=\"#分类的IP地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#分类的IP地址\" class=\"headerlink\" title=\"分类的IP地址\"></a>分类的IP地址</h4>\n      <p>IP地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口</p>\n<p>IP地址::={&lt;网络号&gt;,&lt;主机号&gt;}</p>\n<ul>\n<li>A类：第一个字节是网络号，第一位是0</li>\n<li>B类：前两个字节是网络号，开头是10</li>\n<li>C类：前三个字节是网络号，前三位是110</li>\n<li>D类：多播地址，前四位是1110</li>\n<li>E类：保留为今后使用</li>\n</ul>\n\n        <h4 id=\"私有IP地址\"   >\n          <a href=\"#私有IP地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#私有IP地址\" class=\"headerlink\" title=\"私有IP地址\"></a>私有IP地址</h4>\n      <p>其实就是内网IP地址==、</p>\n\n        <h3 id=\"4-3-4-网络地址转化NAT\"   >\n          <a href=\"#4-3-4-网络地址转化NAT\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-4-网络地址转化NAT\" class=\"headerlink\" title=\"4.3.4 网络地址转化NAT\"></a>4.3.4 网络地址转化NAT</h3>\n      <p>路由器对目的地址是私有IP地址的数据报一律不进行转发</p>\n<p>网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路路由器叫做<strong>NAT路由器</strong>，它至少有一个有效的外部全球IP地址。</p>\n<p>路由器中存在一个NAT转换表。使用端口号对应网内终端。</p>\n\n        <h3 id=\"4-3-5-子网划分与子网掩码\"   >\n          <a href=\"#4-3-5-子网划分与子网掩码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-5-子网划分与子网掩码\" class=\"headerlink\" title=\"4.3.5 子网划分与子网掩码\"></a>4.3.5 子网划分与子网掩码</h3>\n      <ul>\n<li>分类的IP地址的缺点：<ul>\n<li>IP地址空间的利用率有时很低</li>\n<li>两级IP地址不够灵活</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"子网划分\"   >\n          <a href=\"#子网划分\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#子网划分\" class=\"headerlink\" title=\"子网划分\"></a>子网划分</h4>\n      <p>某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分。</p>\n<p>子网号能否全0全1要看情况</p>\n<p>主机号不能全0或全1</p>\n\n        <h4 id=\"子网掩码\"   >\n          <a href=\"#子网掩码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h4>\n      <p>只要是网络号就全1，主机号就全0</p>\n<p>子网掩码与IP地址诸位相与，就得到子网网络地址。</p>\n\n        <h4 id=\"使用子网时分组的转发\"   >\n          <a href=\"#使用子网时分组的转发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#使用子网时分组的转发\" class=\"headerlink\" title=\"使用子网时分组的转发\"></a>使用子网时分组的转发</h4>\n      <ul>\n<li><p>路由表中：</p>\n<ol>\n<li>目的网路地址</li>\n<li>目的网络子网掩码</li>\n<li>下一跳地址</li>\n</ol>\n</li>\n<li><p>路由器转发分组算法</p>\n<ol>\n<li>提取目的IP地址</li>\n<li>是否直接交付</li>\n<li>特定主机路由</li>\n<li>检测路由表中有无路径</li>\n<li>默认路由0.0.0.0</li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"4-3-6-无分类标志CIDR\"   >\n          <a href=\"#4-3-6-无分类标志CIDR\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-6-无分类标志CIDR\" class=\"headerlink\" title=\"4.3.6 无分类标志CIDR\"></a>4.3.6 无分类标志CIDR</h3>\n      <ul>\n<li>无分类域间路由选择CIDR:<ol>\n<li>消除了传统的A类，B类和C类以及划分子网的概念<ol>\n<li>CIDR记法：IP地址后加上<code>/</code>，然后写上网络前缀(可以任意长度)的位数。</li>\n</ol>\n</li>\n<li>融合子网地址与子网掩码，方便子网划分<ol>\n<li>CIDR吧网络前缀都相同的联系的IP地址组成一个<code>CIDR地址块</code></li>\n<li>不能指派最小地址和最大地址</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n\n        <h4 id=\"构成超网\"   >\n          <a href=\"#构成超网\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#构成超网\" class=\"headerlink\" title=\"构成超网\"></a>构成超网</h4>\n      <p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p>\n<p>方法：将网络前缀缩短</p>\n\n        <h4 id=\"最长前缀匹配\"   >\n          <a href=\"#最长前缀匹配\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最长前缀匹配\" class=\"headerlink\" title=\"最长前缀匹配\"></a>最长前缀匹配</h4>\n      <p>使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。</p>\n\n        <h3 id=\"4-3-7-ARP协议\"   >\n          <a href=\"#4-3-7-ARP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-7-ARP协议\" class=\"headerlink\" title=\"4.3.7 ARP协议\"></a>4.3.7 ARP协议</h3>\n      <p>IP地址与MAC地址的映射</p>\n<p>广播ARP请求分组</p>\n<p>交换机没有MAC地址</p>\n\n        <h4 id=\"ARP协议\"   >\n          <a href=\"#ARP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h4>\n      <p>由于在实际网络的链路上传送数据帧时，最终必需使用MAC地址。</p>\n<p>ARP协议：完成主机或路由器IP地址MAC地址的映射——解决下一跳走哪的问题。</p>\n<p>ARP协议使用过程：检查ARO高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机的收到该请求后回想源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存(10-20min更新一次)。</p>\n<ul>\n<li>ARP协议4中典型情况：<ol>\n<li>主机A发给本网络上的主机B：用ARO找到主机B的硬件地址；</li>\n<li>主机A发送给另一网络上的主机B：用ARP找到本网络上的一个路由器(网关)的硬件地址；</li>\n<li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址；</li>\n<li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址。</li>\n</ol>\n</li>\n</ul>\n<p>ARP协议是自动进行的。</p>\n\n        <h3 id=\"4-3-8-DHCP协议\"   >\n          <a href=\"#4-3-8-DHCP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-8-DHCP协议\" class=\"headerlink\" title=\"4.3.8 DHCP协议\"></a>4.3.8 DHCP协议</h3>\n      <ul>\n<li>主机如何获得IP地址？<ul>\n<li>静态配置<ul>\n<li>IP地址</li>\n<li>子网掩码</li>\n<li>默认网关</li>\n</ul>\n</li>\n<li>动态配置</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"DHCP协议\"   >\n          <a href=\"#DHCP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#DHCP协议\" class=\"headerlink\" title=\"DHCP协议\"></a>DHCP协议</h4>\n      <p>动态主机配置协议DHCP是<strong>应用层</strong>协议，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于<strong>UDP</strong>。DHCP提供<strong>即插即用</strong>联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许<strong>地址复用</strong>，支持<strong>移动用户加入网络</strong>，支持<strong>在用地址续租</strong>。</p>\n<ol>\n<li>主机广播DHCP发现报文<ul>\n<li>试图找到网络中的服务器，服务器获得一个IP地址。</li>\n</ul>\n</li>\n<li>DHCP服务器广播DHCP提供报文<ul>\n<li>服务器拟分配给主机一个IP地址及相关配置，先到先得。</li>\n</ul>\n</li>\n<li>主机广播DHCP请求报文<ul>\n<li>主机向服务器请求提供IP地址</li>\n</ul>\n</li>\n<li>DHCP服务器广播DHCP确认报文<ul>\n<li>正式将IP地址分配给主机</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"4-3-9-ICMP协议\"   >\n          <a href=\"#4-3-9-ICMP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-3-9-ICMP协议\" class=\"headerlink\" title=\"4.3.9 ICMP协议\"></a>4.3.9 ICMP协议</h3>\n      <p>网际控制报文协议ICMP</p>\n<ul>\n<li>ICMP协议支持主机或路由器：<ul>\n<li>差错(或异常)报告 -&gt;发送特定ICMP报文</li>\n<li>网络探寻</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"ICMP差错报告报文\"   >\n          <a href=\"#ICMP差错报告报文\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#ICMP差错报告报文\" class=\"headerlink\" title=\"ICMP差错报告报文\"></a>ICMP差错报告报文</h4>\n      <ol>\n<li>终点不可达：当路由器或主机不能交付数据报时就向源点发送重点不可达报文。</li>\n<li>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</li>\n<li>时间超时：当路由器收到生存时间TTL=0的数据报时，出丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li>\n<li>参数问题：当路由器或目的主机收到的数据包的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li>\n<li>改变路由(重定向)：路由器把改变路由报文发送给主机，让主机知道下次应该将数据报发送给另外的路由器(可通过更好的路由)。</li>\n</ol>\n\n        <h4 id=\"不应发送ICMP差错报文的情况\"   >\n          <a href=\"#不应发送ICMP差错报文的情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#不应发送ICMP差错报文的情况\" class=\"headerlink\" title=\"不应发送ICMP差错报文的情况\"></a>不应发送ICMP差错报文的情况</h4>\n      <ol>\n<li>对ICMP差错报告报文不再发送ICMP差错报告报文。</li>\n<li>对第一个分片的数据报文的所有后续数据报片都不发送ICMP差错报告报文。</li>\n<li>对具有组播的数据报都不发送CIMP差错报告报文。</li>\n<li>对具有特殊地址的数据包不发送ICMP差错报告报文</li>\n</ol>\n\n        <h4 id=\"ICMP询问报文\"   >\n          <a href=\"#ICMP询问报文\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#ICMP询问报文\" class=\"headerlink\" title=\"ICMP询问报文\"></a>ICMP询问报文</h4>\n      <ol>\n<li>回送请求和回答报文<ul>\n<li>主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP会送回答报文。</li>\n<li>测试目的站是否科大以及了解其相关状态。</li>\n</ul>\n</li>\n<li>时间戳请求和回答报文<ul>\n<li>请某个主机或路由器回答当前的日期和时间</li>\n<li>用来进行时钟同步和测量时间</li>\n</ul>\n</li>\n<li>掩码地址请求和回答报文<ul>\n<li>不再使用了</li>\n</ul>\n</li>\n<li>路由器询问和通告报文<ul>\n<li>不再使用了</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>PING<ul>\n<li>测试两个主机之间的连通性，使用了ICMP回送请求和回答报文</li>\n</ul>\n</li>\n<li>Traceroute<ul>\n<li>跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"4-4-IPv6\"   >\n          <a href=\"#4-4-IPv6\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-4-IPv6\" class=\"headerlink\" title=\"4.4 IPv6\"></a>4.4 IPv6</h2>\n      <p>从根本上解决地址耗尽问题</p>\n<p>改进首部格式</p>\n<p>快速处理/转发数据报</p>\n<p>支持QoS</p>\n\n        <h3 id=\"IPv6数据报格式\"   >\n          <a href=\"#IPv6数据报格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IPv6数据报格式\" class=\"headerlink\" title=\"IPv6数据报格式\"></a>IPv6数据报格式</h3>\n      \n        <h3 id=\"IPv6和IPv4\"   >\n          <a href=\"#IPv6和IPv4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IPv6和IPv4\" class=\"headerlink\" title=\"IPv6和IPv4\"></a>IPv6和IPv4</h3>\n      <ol>\n<li>IPv6将地址从32位扩大到128位，更大的地址空间</li>\n<li>IPv6将IPv4的校验和字段彻底移除，一间小每跳的处理时间。</li>\n<li>IPv6将IPv4的可选字段移除首部，变成了扩展首部，称为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li>\n<li>IPv6支持即插即用，不需要DHCP协议</li>\n<li>IPv6首部长度必须是<strong>8B</strong>的整数，IPv4首部是4B的整数倍</li>\n<li>IPv6只能在主机处切片，IPv4可以在路由器和主机处分片</li>\n<li>ICMPv6：附加报文类型“分组过大”</li>\n<li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用。</li>\n<li>IPv6取消了协议字段，改成下一个首部字段</li>\n<li>IPv6取消了总长度字段，改用有效载荷长度字段</li>\n<li>IPv6取消了服务类型字段</li>\n</ol>\n\n        <h3 id=\"IPv6地址表示形式\"   >\n          <a href=\"#IPv6地址表示形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IPv6地址表示形式\" class=\"headerlink\" title=\"IPv6地址表示形式\"></a>IPv6地址表示形式</h3>\n      <ul>\n<li>一般形式：冒号十六进制记法</li>\n<li>压缩形式：合零删零</li>\n<li>零压缩：一连串连续的0可以被一堆冒号取代</li>\n</ul>\n\n        <h3 id=\"IPv6基本地址类型\"   >\n          <a href=\"#IPv6基本地址类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IPv6基本地址类型\" class=\"headerlink\" title=\"IPv6基本地址类型\"></a>IPv6基本地址类型</h3>\n      <ul>\n<li>单播：<ul>\n<li>一对一通信</li>\n<li>可做源地址+目的地址</li>\n</ul>\n</li>\n<li>多播<ul>\n<li>一对多通信</li>\n<li>可做目的地址</li>\n</ul>\n</li>\n<li>任播<ul>\n<li>一对多中的一个通信</li>\n<li>可做目的地址</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"IPv6向IPv4过渡的策略\"   >\n          <a href=\"#IPv6向IPv4过渡的策略\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IPv6向IPv4过渡的策略\" class=\"headerlink\" title=\"IPv6向IPv4过渡的策略\"></a>IPv6向IPv4过渡的策略</h3>\n      <ul>\n<li>双栈协议<ul>\n<li>同时启用IPv4协议栈和IPv6协议栈</li>\n</ul>\n</li>\n<li>隧道技术<ul>\n<li>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包<strong>重新封装</strong>然后通过隧道发送。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"4-5-路由协议\"   >\n          <a href=\"#4-5-路由协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-5-路由协议\" class=\"headerlink\" title=\"4.5 路由协议\"></a>4.5 路由协议</h2>\n      \n        <h3 id=\"4-5-1-RIP协议与距离向量算法\"   >\n          <a href=\"#4-5-1-RIP协议与距离向量算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-5-1-RIP协议与距离向量算法\" class=\"headerlink\" title=\"4.5.1 RIP协议与距离向量算法\"></a>4.5.1 RIP协议与距离向量算法</h3>\n      \n        <h4 id=\"RIP协议\"   >\n          <a href=\"#RIP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RIP协议\" class=\"headerlink\" title=\"RIP协议\"></a>RIP协议</h4>\n      <p>RIP是一种分布式基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单</p>\n<p>RIP协议要求网络中每一个路由器都维护从他自己到其他每一个目的网络的唯一最佳距离(即一组距离)。</p>\n<p>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1.特别的，从已路由器到直接连接的网络距离为1.RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达。</p>\n<p>RIP协议指适用于小互联网。</p>\n\n        <h4 id=\"RIP协议和谁交换？多久交换一次？交换什么？\"   >\n          <a href=\"#RIP协议和谁交换？多久交换一次？交换什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RIP协议和谁交换？多久交换一次？交换什么？\" class=\"headerlink\" title=\"RIP协议和谁交换？多久交换一次？交换什么？\"></a>RIP协议和谁交换？多久交换一次？交换什么？</h4>\n      <ol>\n<li>仅和相邻路由器交换信息</li>\n<li>路由器交换的信息是自己的路由表</li>\n<li>没30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己的路由表。</li>\n</ol>\n<p>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也之和数目非常有限的相邻路由器交换并更新路由信息。</p>\n<p>经过若干次更新后，所有路由器最终都会知道到达本自制系统任何一个网络的最短距离和下一跳路由器的肚地址，即<strong>“收敛”</strong>。</p>\n\n        <h4 id=\"距离向量算法\"   >\n          <a href=\"#距离向量算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#距离向量算法\" class=\"headerlink\" title=\"距离向量算法\"></a>距离向量算法</h4>\n      <ol>\n<li>修改相邻路路由器发来的RIP报文中所有表项。<ul>\n<li>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的“距离”+1。</li>\n</ul>\n</li>\n<li>对修改后的RIP报文中的每一项目，进行以下步骤<ol>\n<li>R1路由表中若没有Net3，则把该项目填入R1路由表</li>\n<li>R1路由器中若有Net3，则查看下一跳路由器地址<ol>\n<li>若下一跳是X，则用收到的羡慕低缓源路由表中的项目；</li>\n<li>若下一跳不是X，原来距离比X走的距离远则更新，否则不作处理</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16</li>\n<li>返回</li>\n</ol>\n\n        <h4 id=\"RIP协议好消息传得快，坏消息传的慢\"   >\n          <a href=\"#RIP协议好消息传得快，坏消息传的慢\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RIP协议好消息传得快，坏消息传的慢\" class=\"headerlink\" title=\"RIP协议好消息传得快，坏消息传的慢\"></a>RIP协议好消息传得快，坏消息传的慢</h4>\n      <p>RIP的特点：当网络层出现故障时，要经过比较长的时间(例如数分钟)才能将此信息传送到所有的路由器。“慢收敛”。</p>\n\n        <h3 id=\"4-5-2-OSPF协议与链路状态算法\"   >\n          <a href=\"#4-5-2-OSPF协议与链路状态算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-5-2-OSPF协议与链路状态算法\" class=\"headerlink\" title=\"4.5.2 OSPF协议与链路状态算法\"></a>4.5.2 OSPF协议与链路状态算法</h3>\n      <p>开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的：“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。</p>\n<p>OSPF最主要的特征就是使用分布式的链路状态协议。</p>\n<ul>\n<li>OSPF的特点：<ul>\n<li>使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个路由器又再次将此信息发往其所有的相邻路由器。最终整个区域内所有路由器都得到了这个信息的一个副本。</li>\n<li>发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>(本路由器和哪些路由器相邻，以及链路的度量/代价——费用、距离、时延、带宽等)。</li>\n<li>只有当<strong>链路发生变化时</strong>，路由器才向所有路由器泛洪发送此信息。</li>\n<li>最后，所有路由器都能建立一个<strong>链路状态数据库</strong>，即全网拓扑图。</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"链路状态路由算法\"   >\n          <a href=\"#链路状态路由算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#链路状态路由算法\" class=\"headerlink\" title=\"链路状态路由算法\"></a>链路状态路由算法</h4>\n      <ol>\n<li>每个路由器发现它的邻居结点【HELLO问候分组】，并了解节点的网络地址。</li>\n<li>设置到它的每个邻居的成本低量metric。</li>\n<li>构造【DD数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状项目的摘要信息。</li>\n<li>如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR链路状态请求分组】请求自己没有的和比自己更新的信息。</li>\n<li>收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新。</li>\n<li>更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行确认。</li>\n<li>使用Dijkstra根据自己的链路状态数据库构造到其他结点间的最短路径。</li>\n</ol>\n<ul>\n<li>只要一个路由器的链路状态发生变化：</li>\n</ul>\n<ol>\n<li>泛洪法送【LSU链路状态更新分组】进行更新。</li>\n<li>更新完毕后，其他站返回一个【LSAck链路状态确认分组】进行确认。</li>\n</ol>\n\n        <h4 id=\"OSPF的区域\"   >\n          <a href=\"#OSPF的区域\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#OSPF的区域\" class=\"headerlink\" title=\"OSPF的区域\"></a>OSPF的区域</h4>\n      <p>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域。</p>\n<p>每一个区域都有一个32位的区域标识符(用点分十进制表示)。</p>\n<p>区域也不能太大，在一个区域内的路由器最好不超过200个。</p>\n\n        <h4 id=\"OSPF分组\"   >\n          <a href=\"#OSPF分组\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#OSPF分组\" class=\"headerlink\" title=\"OSPF分组\"></a>OSPF分组</h4>\n      <p>OSPF直接用IP数据报传送</p>\n\n        <h4 id=\"OSPF其他特点\"   >\n          <a href=\"#OSPF其他特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#OSPF其他特点\" class=\"headerlink\" title=\"OSPF其他特点\"></a>OSPF其他特点</h4>\n      <ol>\n<li>每隔30min，要刷新一次数据库中的链路状态</li>\n<li>由于一个路由器的链路状态值设计到与相邻漏气的连通状态，因而与整个互联网的规模并无直接关系。因此当<strong>互联网规模很大</strong>时，OSPF协议要比距离向量协议RIP好得多。</li>\n<li>OSPF不存在坏消息传的慢的问题，它的<strong>收敛速度很快</strong>。</li>\n</ol>\n\n        <h3 id=\"4-5-3-BGP协议\"   >\n          <a href=\"#4-5-3-BGP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-5-3-BGP协议\" class=\"headerlink\" title=\"4.5.3 BGP协议\"></a>4.5.3 BGP协议</h3>\n      <ul>\n<li>和谁交换：与其他AS的邻站BGP发言人交换信息。</li>\n<li>交换什么：交换网络可达性的信息，即要到达某个网络所要经过的一系列AS。</li>\n<li>多久交换：发生变化时更新有变化的部分。</li>\n</ul>\n\n        <h4 id=\"BGP协议交换信息的过程\"   >\n          <a href=\"#BGP协议交换信息的过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#BGP协议交换信息的过程\" class=\"headerlink\" title=\"BGP协议交换信息的过程\"></a>BGP协议交换信息的过程</h4>\n      <p>BGO所交换的网络可达性的信息就是要<strong>到达某个网络所要经过的一系列AS</strong>。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。</p>\n\n        <h4 id=\"BGP协议报文格式\"   >\n          <a href=\"#BGP协议报文格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#BGP协议报文格式\" class=\"headerlink\" title=\"BGP协议报文格式\"></a>BGP协议报文格式</h4>\n      <p>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要先建立TCP连接，即通过TCP传送，然后再次连接上交换BGP报文以建立BGP会话，利用BGP会话交换路由信息。</p>\n<p>BGP是<strong>应用层</strong>协议，借助<strong>TCP</strong>传送。</p>\n\n        <h4 id=\"BGP协议特点\"   >\n          <a href=\"#BGP协议特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#BGP协议特点\" class=\"headerlink\" title=\"BGP协议特点\"></a>BGP协议特点</h4>\n      <p>BGP支持<strong>CIDR</strong>，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p>\n<p>在BUG刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在<strong>发生变化时更新有变化的部分</strong>。这样做对节省网络带宽和减小路由器的处理开销都有好处。</p>\n\n        <h4 id=\"BGP-4的四种报文\"   >\n          <a href=\"#BGP-4的四种报文\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#BGP-4的四种报文\" class=\"headerlink\" title=\"BGP-4的四种报文\"></a>BGP-4的四种报文</h4>\n      <ol>\n<li>OPEN(打开)报文：用来与相邻的另一个BGO发言人建立关系，并认证发送方。</li>\n<li>UPDATE(更新)报文：通告新路径或撤销原路径。</li>\n<li>KEEPALIVE(保活)报文：在无UPDATE时，周期性正式邻站的连通性；也作为OPEN的确认。</li>\n<li>NOTIFICATION(通知)报文：报告先前报文的差错；也被用于关闭连接。</li>\n</ol>\n\n        <h4 id=\"三种路由协议比较\"   >\n          <a href=\"#三种路由协议比较\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三种路由协议比较\" class=\"headerlink\" title=\"三种路由协议比较\"></a>三种路由协议比较</h4>\n      <p>RIP是一种分布式的基于距离向量的内部网关路由选择协议，通过广播UDP报文来交换路由信息。</p>\n<p>OSPF是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议(如UDP或TCP)，而是直接采用IP。</p>\n<p>BGP是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用TCP。</p>\n\n        <h2 id=\"4-6-IP组播\"   >\n          <a href=\"#4-6-IP组播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-6-IP组播\" class=\"headerlink\" title=\"4.6 IP组播\"></a>4.6 IP组播</h2>\n      \n        <h3 id=\"IP数据报的三种传输方式\"   >\n          <a href=\"#IP数据报的三种传输方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IP数据报的三种传输方式\" class=\"headerlink\" title=\"IP数据报的三种传输方式\"></a>IP数据报的三种传输方式</h3>\n      <ul>\n<li>单播<ul>\n<li>单播用于发送数据包到单个目的地址，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式。</li>\n</ul>\n</li>\n<li>广播<ul>\n<li>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种<strong>点对多点</strong>的传输方式。</li>\n</ul>\n</li>\n<li>组播(多播)<ul>\n<li>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播发送树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种<strong>点对多点</strong>传输。</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"IP组播地址\"   >\n          <a href=\"#IP组播地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IP组播地址\" class=\"headerlink\" title=\"IP组播地址\"></a>IP组播地址</h2>\n      <p>IP组播地址让源设备能够分组发送给一组设备。属于多播组的设备将被分配一个组播IP地址(一群共同需求主机的相同标识)。</p>\n<p>组播地址范围为224.0.0.0~239.255.255.255，一个D类地址表示一个组播组。只能用作分组的<strong>目的地址</strong>。源地址总是为单播地址。</p>\n<ol>\n<li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP。</li>\n<li>对组播数据报不产生ICMP差错报文。</li>\n<li>并非所有D类地址都可以作为组播地址。</li>\n</ol>\n\n        <h3 id=\"硬件组播\"   >\n          <a href=\"#硬件组播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#硬件组播\" class=\"headerlink\" title=\"硬件组播\"></a>硬件组播</h3>\n      <p>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制值01-00-5E打头，余下的6个十六进制位是根据IP组播组地址的最后23位转换得到的。</p>\n<p>收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p>\n\n        <h3 id=\"IGMP协议与组播路由选择协议\"   >\n          <a href=\"#IGMP协议与组播路由选择协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IGMP协议与组播路由选择协议\" class=\"headerlink\" title=\"IGMP协议与组播路由选择协议\"></a>IGMP协议与组播路由选择协议</h3>\n      \n        <h3 id=\"网际组管理协议IGMP\"   >\n          <a href=\"#网际组管理协议IGMP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网际组管理协议IGMP\" class=\"headerlink\" title=\"网际组管理协议IGMP\"></a>网际组管理协议IGMP</h3>\n      <p>IGMP协议让路由器知道本局域网上**是否有主机(的进程)**参加或退出了某个组播组。</p>\n<p>ICMP和IGMP都使用IP数据报传递报文。</p>\n\n        <h3 id=\"IGMP工作的两个阶段\"   >\n          <a href=\"#IGMP工作的两个阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IGMP工作的两个阶段\" class=\"headerlink\" title=\"IGMP工作的两个阶段\"></a>IGMP工作的两个阶段</h3>\n      <p>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员。</p>\n<p>本地组播服务器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p>\n<p>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</p>\n<p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果胫骨哦几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不会把这组的成员关系发送给其他的组播路由器。</p>\n<p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p>\n\n        <h3 id=\"组播路由选择协议\"   >\n          <a href=\"#组播路由选择协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#组播路由选择协议\" class=\"headerlink\" title=\"组播路由选择协议\"></a>组播路由选择协议</h3>\n      <p>组播路由选择协议的目的是找出以源主机为根节点的组播转发树。</p>\n<p>构造树可以避免在路由器之间兜圈子。</p>\n<p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</p>\n<ul>\n<li>组播路由选择协议常使用的三种算法<ul>\n<li>基于链路状态的路由选择</li>\n<li>基于距离-向量的路由选择</li>\n<li>协议无关的组播(稀疏/密集)</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"4-7-移动IP\"   >\n          <a href=\"#4-7-移动IP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-7-移动IP\" class=\"headerlink\" title=\"4.7 移动IP\"></a>4.7 移动IP</h2>\n      <p>移动IP技术是移动结点(计算机/服务器等)以<strong>固定的网络IP地址</strong>，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p>\n<p>移动结点：具有永久IP地址的移动设备</p>\n<p>归属代理(本地代理)：一个移动结点拥有的就“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</p>\n<p>外部代理(外地代理)：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</p>\n<p>永久地址(归属地址/主地址)：移动站点在归属网络中的原始地址。</p>\n<p>转交地址(辅地址)：移动站点在外部网络使用的临时地址。</p>\n\n        <h2 id=\"4-8-网络层设备\"   >\n          <a href=\"#4-8-网络层设备\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-8-网络层设备\" class=\"headerlink\" title=\"4.8 网络层设备\"></a>4.8 网络层设备</h2>\n      \n        <h3 id=\"路由器\"   >\n          <a href=\"#路由器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#路由器\" class=\"headerlink\" title=\"路由器\"></a>路由器</h3>\n      <p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。</p>\n<p>根据选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。</p>\n<p>交换结构：根据转发表对分组进行转发</p>\n<p>若收到RIP/OSPF分组等，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出。</p>\n\n        <h3 id=\"输入端口对线路上收到的分组处理\"   >\n          <a href=\"#输入端口对线路上收到的分组处理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入端口对线路上收到的分组处理\" class=\"headerlink\" title=\"输入端口对线路上收到的分组处理\"></a>输入端口对线路上收到的分组处理</h3>\n      <p>输入端口中的查找和转发功能在路由器的交换功能中是最重要的</p>\n\n        <h3 id=\"输出端口将交换结构传送来的分组发送到线路\"   >\n          <a href=\"#输出端口将交换结构传送来的分组发送到线路\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输出端口将交换结构传送来的分组发送到线路\" class=\"headerlink\" title=\"输出端口将交换结构传送来的分组发送到线路\"></a>输出端口将交换结构传送来的分组发送到线路</h3>\n      <p>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</p>\n<p>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</p>\n\n        <h3 id=\"三层设备的区别\"   >\n          <a href=\"#三层设备的区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#三层设备的区别\" class=\"headerlink\" title=\"三层设备的区别\"></a>三层设备的区别</h3>\n      <ul>\n<li>路由器：可以互连两个不同网络层协议的网段</li>\n<li>网桥：可以互联两个物理层和链路层不同的设备</li>\n<li>集线器：不能互连两个物理层不同的网段。</li>\n</ul>\n\n        <h3 id=\"路由表与路由转发\"   >\n          <a href=\"#路由表与路由转发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#路由表与路由转发\" class=\"headerlink\" title=\"路由表与路由转发\"></a>路由表与路由转发</h3>\n      <p>路由表根据<strong>路由选择算法</strong>得出的，主要用途是路由选择，总用软件来实现。</p>\n<p>转发表由<strong>路由表</strong>得来，可以用软件实现，也可以用特殊的硬件来实现。转发表必须包含完成转发功能所必须的信息，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息的映射。</p>\n\n        <h1 id=\"第5章——传输层\"   >\n          <a href=\"#第5章——传输层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第5章——传输层\" class=\"headerlink\" title=\"第5章——传输层\"></a>第5章——传输层</h1>\n      \n        <h2 id=\"5-1-传输层概述\"   >\n          <a href=\"#5-1-传输层概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-1-传输层概述\" class=\"headerlink\" title=\"5.1 传输层概述\"></a>5.1 传输层概述</h2>\n      <p>只有主机才有的层次</p>\n<p>为应用层提供通信服务，使用网络层的服务</p>\n<ul>\n<li>传输层的功能：<ul>\n<li>传输层提供进程和进程之间的逻辑通信<ul>\n<li>网络层提供主机和主机之间的逻辑通信</li>\n</ul>\n</li>\n<li>复用和分用</li>\n<li>传输层对收到的报文进行差错检测</li>\n<li>传输层的两种协议</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"传输层的两个协议\"   >\n          <a href=\"#传输层的两个协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#传输层的两个协议\" class=\"headerlink\" title=\"传输层的两个协议\"></a>传输层的两个协议</h3>\n      <ol>\n<li>TCP<ul>\n<li>面向连接的传输控制协议</li>\n<li>可靠传输</li>\n<li>传送数据之前必须建立连接，数据传送结束后释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。</li>\n<li>可靠，面向连接，饰演大，适用于大文件</li>\n</ul>\n</li>\n<li>UDP<ul>\n<li>无连接的用户数据报协议</li>\n<li>传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认</li>\n<li>不可靠。无连接，时延小，适用于小文件</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"传输层的寻址与端口\"   >\n          <a href=\"#传输层的寻址与端口\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#传输层的寻址与端口\" class=\"headerlink\" title=\"传输层的寻址与端口\"></a>传输层的寻址与端口</h3>\n      <ul>\n<li>复用：应用层所有的应用进程都可以通过传输层再传输到网络层</li>\n<li>分用：传输层从网络层收到数据后交付指明的应用进程。</li>\n</ul>\n<p>端口：是传输层的SAP，标识主机中的应用进程</p>\n<p>逻辑端口/软件端口</p>\n<p>端口号只在本地有意义，在因特网中不同计算机的相同端口是没有联系的</p>\n<p>端口号长度为16bit，能表示65535个不同的端口号。</p>\n<ul>\n<li>端口号<ul>\n<li>服务端端口号<ul>\n<li>熟知端口号(0-1023)<ul>\n<li>给TCP/IP最重要的一些应用程序，让所有用户都知道。</li>\n</ul>\n</li>\n<li>登记端口号(1024-49151)<ul>\n<li>为没有熟知端口号的应用程序使用的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客户端使用的端口号(49152-65535)<ul>\n<li>仅在客户进程运行时才动态选择</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。</p>\n\n        <h2 id=\"5-2-UDP协议\"   >\n          <a href=\"#5-2-UDP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-2-UDP协议\" class=\"headerlink\" title=\"5.2 UDP协议\"></a>5.2 UDP协议</h2>\n      \n        <h3 id=\"用户数据报协议UDP概述\"   >\n          <a href=\"#用户数据报协议UDP概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#用户数据报协议UDP概述\" class=\"headerlink\" title=\"用户数据报协议UDP概述\"></a>用户数据报协议UDP概述</h3>\n      <p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p>\n<ul>\n<li>UDP的主要特点：<ul>\n<li>无连接，减小了开销和时延</li>\n<li>不可靠交付</li>\n<li>面向报文的，适合一次性传输少量数据的网络应用</li>\n<li>UDP无拥塞控制，适合很多实时应用。</li>\n<li>UDP首部开销小，8B，TCP80B</li>\n</ul>\n</li>\n</ul>\n<p>流：流入到进程或从进程流出的字节序列。</p>\n<p>应用层给UDP多长的报文，UDP就照样发送，即一次发一整个报文。</p>\n\n        <h3 id=\"UDP校验\"   >\n          <a href=\"#UDP校验\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#UDP校验\" class=\"headerlink\" title=\"UDP校验\"></a>UDP校验</h3>\n      <p>伪首部：只有在计算机校验和时才出现，不向下传送也不向上递交。</p>\n<ul>\n<li>在发送端<ol>\n<li>填上伪首部</li>\n<li>全0填充检验和字段</li>\n<li>全0填充数据部分</li>\n<li>伪首部+首部+数据部分采用二进制反码求和</li>\n<li>把和求反码填入检验和字段</li>\n<li>去掉伪首部，发送。</li>\n</ol>\n</li>\n<li>在接收端：<ol>\n<li>填上伪首部</li>\n<li>伪首部+首部+数据部分采用二进制反码求和</li>\n<li>结果全为1则无差错，否则丢弃数据/交给应用程序附上差错的警告</li>\n</ol>\n</li>\n</ul>\n\n        <h2 id=\"5-3-TCP协议\"   >\n          <a href=\"#5-3-TCP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-3-TCP协议\" class=\"headerlink\" title=\"5.3 TCP协议\"></a>5.3 TCP协议</h2>\n      \n        <h3 id=\"5-3-1-TCP协议特点和TCP报文段格式\"   >\n          <a href=\"#5-3-1-TCP协议特点和TCP报文段格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-3-1-TCP协议特点和TCP报文段格式\" class=\"headerlink\" title=\"5.3.1 TCP协议特点和TCP报文段格式\"></a>5.3.1 TCP协议特点和TCP报文段格式</h3>\n      \n        <h4 id=\"TCP协议的特点\"   >\n          <a href=\"#TCP协议的特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP协议的特点\" class=\"headerlink\" title=\"TCP协议的特点\"></a>TCP协议的特点</h4>\n      <ol>\n<li>TCP是面向连接(虚连接)的传输层协议</li>\n<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li>\n<li>TCP提供可靠交付的服务，无差错，不丢失，不重复。按序到达</li>\n<li>TCP提供全双工通信<ol>\n<li>发送缓存：准备发送的数据&amp;已发送但尚未收到确认的数据</li>\n<li>接收缓存：按序到达但没有被接受应用程序读取的数据&amp;不按序到达的数据</li>\n</ol>\n</li>\n<li>TCP面向字节流：TCP吧应用程序交小来的数据看成仅仅是一连串的<strong>无结构的字节流</strong>。</li>\n</ol>\n\n        <h4 id=\"TCP报文段首部格式\"   >\n          <a href=\"#TCP报文段首部格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP报文段首部格式\" class=\"headerlink\" title=\"TCP报文段首部格式\"></a>TCP报文段首部格式</h4>\n      <ul>\n<li>六个控制位<ul>\n<li>紧急位URG</li>\n<li>确认位ACK</li>\n<li>推送位PSH</li>\n<li>复位RST</li>\n<li>同步位SYN</li>\n<li>终止位FIN</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"5-3-2-TCP连接管理\"   >\n          <a href=\"#5-3-2-TCP连接管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-3-2-TCP连接管理\" class=\"headerlink\" title=\"5.3.2 TCP连接管理\"></a>5.3.2 TCP连接管理</h3>\n      <p>TCP连接传输三个阶段：连接建立-&gt;数据传送-&gt;连接释放</p>\n<p>TCP连接的建立采用<strong>客户服务器方式</strong>，主动发起连接建立的应用程序叫做客户，而被动等待连接建立的应用程序交服务器。</p>\n\n        <h4 id=\"TCP的连接建立\"   >\n          <a href=\"#TCP的连接建立\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP的连接建立\" class=\"headerlink\" title=\"TCP的连接建立\"></a>TCP的连接建立</h4>\n      <ol>\n<li>客户端发送<strong>连接请求报文段</strong>，无应用层数据。</li>\n<li>服务器为该TCP连接<strong>分配缓存和变量</strong>，并向客户端返回<strong>确认报文段</strong>，允许连接，无应用层数据。</li>\n<li>客户端为该TCP连接<strong>分配缓存和变量</strong>，并向服务器端返回确认的确认，可以携带数据。</li>\n</ol>\n\n        <h4 id=\"SYN洪泛攻击\"   >\n          <a href=\"#SYN洪泛攻击\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#SYN洪泛攻击\" class=\"headerlink\" title=\"SYN洪泛攻击\"></a>SYN洪泛攻击</h4>\n      <p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的<strong>第一个数据包</strong>，而当服务器返回ACK后。该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器就收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p>\n\n        <h4 id=\"TCP的连接释放\"   >\n          <a href=\"#TCP的连接释放\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP的连接释放\" class=\"headerlink\" title=\"TCP的连接释放\"></a>TCP的连接释放</h4>\n      <p>参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”(缓存和变量)将被释放。</p>\n<ol>\n<li>客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭TCP连接。</li>\n<li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了。——半关闭状态。</li>\n<li>服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。</li>\n<li>客户端回送一个确认报文段，在等到时间等待计时器设置的2MSL(最长报文段寿命)后，连接彻底关闭</li>\n</ol>\n\n        <h3 id=\"5-3-3-TCP可靠传输\"   >\n          <a href=\"#5-3-3-TCP可靠传输\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-3-3-TCP可靠传输\" class=\"headerlink\" title=\"5.3.3 TCP可靠传输\"></a>5.3.3 TCP可靠传输</h3>\n      <p>可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一致的。</p>\n\n        <h4 id=\"序号\"   >\n          <a href=\"#序号\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#序号\" class=\"headerlink\" title=\"序号\"></a>序号</h4>\n      <p>一个字节占一个序号</p>\n<p><strong>序号字段</strong>指的是一个报文段第一个字节的序号。</p>\n\n        <h4 id=\"确认\"   >\n          <a href=\"#确认\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#确认\" class=\"headerlink\" title=\"确认\"></a>确认</h4>\n      \n        <h4 id=\"重传\"   >\n          <a href=\"#重传\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重传\" class=\"headerlink\" title=\"重传\"></a>重传</h4>\n      <p>确认重传不分家。TCP的发送方在规定的时间内没有收到确认就要重传以发送的报文段</p>\n<p>TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)</p>\n<ul>\n<li>冗余ACK(冗余确认)<ul>\n<li>每当比期望序号大的失序报文段到达时，发送一个<strong>冗余ACK</strong>，指明下一个期待字节的序号。</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"5-3-4-TCP流量控制\"   >\n          <a href=\"#5-3-4-TCP流量控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-3-4-TCP流量控制\" class=\"headerlink\" title=\"5.3.4 TCP流量控制\"></a>5.3.4 TCP流量控制</h3>\n      <p>流量控制：让<strong>发送方慢点</strong>要让接收方来得及接收。</p>\n<p>TCP利用滑动窗口机制实现流量控制。</p>\n<p>在通信过程中，接收方根据自己接收魂村的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方)，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p>\n<p>TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。</p>\n<p>若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>。接收方收到探测报文段时给出现在的窗口值。</p>\n<p>若窗口仍然是0，那么发送方就重新设置持续计时器。</p>\n\n        <h3 id=\"5-3-5-TCP拥塞控制\"   >\n          <a href=\"#5-3-5-TCP拥塞控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-3-5-TCP拥塞控制\" class=\"headerlink\" title=\"5.3.5 TCP拥塞控制\"></a>5.3.5 TCP拥塞控制</h3>\n      <p>出现拥塞的条件：对资源需求的总和&gt;可用资源</p>\n\n        <h4 id=\"拥塞控制四种算法\"   >\n          <a href=\"#拥塞控制四种算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#拥塞控制四种算法\" class=\"headerlink\" title=\"拥塞控制四种算法\"></a>拥塞控制四种算法</h4>\n      <ul>\n<li><p>慢开始</p>\n</li>\n<li><p>拥塞避免</p>\n</li>\n<li><p>快重传</p>\n</li>\n<li><p>快恢复</p>\n</li>\n<li><p>假定</p>\n<ol>\n<li>数据单方向传送，而另一个方向只传送确认</li>\n<li>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</li>\n</ol>\n<ul>\n<li>发送窗口 = Min{接收窗口rwnd，拥塞窗口cwnd}</li>\n</ul>\n</li>\n</ul>\n<p>接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反应接收方容量。</p>\n<p>拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反应网络当前容量</p>\n\n        <h4 id=\"慢开始和拥塞避免\"   >\n          <a href=\"#慢开始和拥塞避免\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#慢开始和拥塞避免\" class=\"headerlink\" title=\"慢开始和拥塞避免\"></a>慢开始和拥塞避免</h4>\n      <ul>\n<li>慢开始：指数级增长<ul>\n<li>一个传输轮次：发送了一批报文段并收到它们的确认时间</li>\n<li>一个往返时延RTT</li>\n<li>开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间。</li>\n</ul>\n</li>\n<li>拥塞避免：发生拥塞后，发送窗口调至一，重新慢开始直到达到拥塞窗口的一半后使用加法增大</li>\n</ul>\n\n        <h4 id=\"快重传和快恢复\"   >\n          <a href=\"#快重传和快恢复\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#快重传和快恢复\" class=\"headerlink\" title=\"快重传和快恢复\"></a>快重传和快恢复</h4>\n      <ul>\n<li>收到3个重复的确认执行快重传算法</li>\n<li>从拥塞窗口一半的数量进行拥塞避免加法增大。</li>\n</ul>\n\n        <h1 id=\"第6章——应用层\"   >\n          <a href=\"#第6章——应用层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#第6章——应用层\" class=\"headerlink\" title=\"第6章——应用层\"></a>第6章——应用层</h1>\n      \n        <h2 id=\"6-1-网络应用模型\"   >\n          <a href=\"#6-1-网络应用模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-1-网络应用模型\" class=\"headerlink\" title=\"6.1 网络应用模型\"></a>6.1 网络应用模型</h2>\n      \n        <h3 id=\"应用层概述\"   >\n          <a href=\"#应用层概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#应用层概述\" class=\"headerlink\" title=\"应用层概述\"></a>应用层概述</h3>\n      <p>应用层对应用程序的通信提供服务。</p>\n<ul>\n<li><p>应用层协议定义：</p>\n<ul>\n<li>应用程序交换的报文类型，请求还是响应？</li>\n<li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li>\n<li>字段的语义，即包含在字段中的信息的含义。</li>\n<li>进程何时、如何发送报文，以及对报文进行响应的规则。</li>\n</ul>\n</li>\n<li><p>应用层的功能：</p>\n<ul>\n<li>文件传输、访问和管理</li>\n<li>电子邮件</li>\n<li>虚拟终端</li>\n<li>查询服务和远程作业登录</li>\n</ul>\n</li>\n<li><p>应用层的重要协议：</p>\n<ul>\n<li>FTP</li>\n<li>SMTP、POP3</li>\n<li>HTTP</li>\n<li>DNS</li>\n</ul>\n</li>\n</ul>\n\n        <h3 id=\"网络应用模型\"   >\n          <a href=\"#网络应用模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网络应用模型\" class=\"headerlink\" title=\"网络应用模型\"></a>网络应用模型</h3>\n      <ul>\n<li>C/S<ul>\n<li>S:<ul>\n<li>提供计算机服务的设备</li>\n</ul>\n<ol>\n<li>永久提供服务</li>\n<li>永久性访问地址/域名</li>\n</ol>\n</li>\n<li>C:<ul>\n<li>请求计算服务的主机</li>\n</ul>\n<ol>\n<li>与服务器通信，使用服务器提供的服务</li>\n<li>间歇性接入网络</li>\n<li>可能使用动态IP地址</li>\n<li>不予其他客户机直接通信</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>P2P<ul>\n<li>不存在永远在线的服务器</li>\n<li>每个主机既可以提供服务，也可以请求服务</li>\n<li>任意端系统/结点之间可以直接通讯</li>\n<li>节点间歇性接入网络</li>\n<li>节点可能改变IP地址</li>\n<li>可扩展性好</li>\n<li>网络健壮性强</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"6-2-DNS解析系统\"   >\n          <a href=\"#6-2-DNS解析系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-2-DNS解析系统\" class=\"headerlink\" title=\"6.2 DNS解析系统\"></a>6.2 DNS解析系统</h2>\n      <ul>\n<li><p>顶级域名</p>\n<ul>\n<li>国际顶级域名</li>\n<li>通用顶级域名</li>\n<li>基础结构域名/反向域名</li>\n</ul>\n</li>\n<li><p>二级域名</p>\n<ul>\n<li>类别域名</li>\n<li>行政区域名</li>\n</ul>\n</li>\n<li><p>域名服务器</p>\n<ul>\n<li>根域名服务器</li>\n<li>顶级域名服务器<ul>\n<li>管理该顶级域名服务器注册的所有二级域名</li>\n</ul>\n</li>\n<li>权限域名服务器<ul>\n<li>负责一个区的域名服务器</li>\n</ul>\n</li>\n<li>本地域名服务器<ul>\n<li>当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>递归查询</p>\n</li>\n<li><p>迭代查询</p>\n</li>\n</ul>\n\n        <h2 id=\"6-3-文件传送协议FTP\"   >\n          <a href=\"#6-3-文件传送协议FTP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-3-文件传送协议FTP\" class=\"headerlink\" title=\"6.3 文件传送协议FTP\"></a>6.3 文件传送协议FTP</h2>\n      <ul>\n<li><p>文件传送协议FTP</p>\n<ul>\n<li>提供不同种类主机系统(硬、软件体系等都可以不同)之间文件传输能力</li>\n</ul>\n</li>\n<li><p>简单文件传送协议TFTP</p>\n</li>\n<li><p>TCP控制连接端口21</p>\n<ul>\n<li>控制连接始终保持</li>\n</ul>\n</li>\n<li><p>TCP数据连接端口20</p>\n<ul>\n<li>数据连接保持一会</li>\n</ul>\n</li>\n</ul>\n<p>是否使用TCP 20端口建立数据连接与传输模式有关</p>\n<p>主动方式使用TCP 20端口</p>\n<p>被动方式由服务器和客户端自行协商决定</p>\n<ul>\n<li>FTP传输模式<ul>\n<li>文本模式：ASCII模式，以文本序列传输数据；</li>\n<li>二进制模式：Binary模式，以二进制序列传输数据</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"6-4-电子邮件\"   >\n          <a href=\"#6-4-电子邮件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-4-电子邮件\" class=\"headerlink\" title=\"6.4 电子邮件\"></a>6.4 电子邮件</h2>\n      \n        <h3 id=\"简单邮件传送协议SMTP\"   >\n          <a href=\"#简单邮件传送协议SMTP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#简单邮件传送协议SMTP\" class=\"headerlink\" title=\"简单邮件传送协议SMTP\"></a>简单邮件传送协议SMTP</h3>\n      <p>SMTP规定在两个相互通信的SMTP进程之间应如何交换信息</p>\n<p>负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器</p>\n<p>SMTP规定了14条命令(几个字母)和21种应答信息(三位数字+简单文字说明)</p>\n<p>建立在TCP连接上的，端口号25.C/S</p>\n<ul>\n<li><p>SMTP通信三个阶段</p>\n<ul>\n<li>连接建立</li>\n<li>邮件传送</li>\n<li>连接释放</li>\n</ul>\n</li>\n<li><p>SMTP的缺点：</p>\n<ol>\n<li>SMTP不能传送可执行文件或其他二进制文件</li>\n<li>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字</li>\n<li>SMTP服务器会拒绝超过一定长度的邮件</li>\n</ol>\n</li>\n</ul>\n<p>通用因特网邮件扩充MIME：是电子邮件系统可以支持声音、图像、视频、多种国家语言等等。</p>\n\n        <h3 id=\"邮局协议POP3\"   >\n          <a href=\"#邮局协议POP3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#邮局协议POP3\" class=\"headerlink\" title=\"邮局协议POP3\"></a>邮局协议POP3</h3>\n      <p>TCP连接，端口号110，C/S</p>\n<ul>\n<li>工作方式<ul>\n<li>下载并保留</li>\n<li>下载并删除</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"网际报文存取协议IMAP\"   >\n          <a href=\"#网际报文存取协议IMAP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网际报文存取协议IMAP\" class=\"headerlink\" title=\"网际报文存取协议IMAP\"></a>网际报文存取协议IMAP</h4>\n      <p>IMAP协议比POP协议复杂。当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上。</p>\n<p>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分(先看正文，有WIFI的时候在下载附件)。</p>\n\n        <h2 id=\"6-5-万维网和HTTP协议\"   >\n          <a href=\"#6-5-万维网和HTTP协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-5-万维网和HTTP协议\" class=\"headerlink\" title=\"6.5 万维网和HTTP协议\"></a>6.5 万维网和HTTP协议</h2>\n      \n        <h3 id=\"万维网概述\"   >\n          <a href=\"#万维网概述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#万维网概述\" class=\"headerlink\" title=\"万维网概述\"></a>万维网概述</h3>\n      <p>万维网WW是一个大规模的联机式的信息储藏所/资源空间，是无数个网络站点和网页的集合。</p>\n<p>统一资源定位符URL</p>\n\n        <h3 id=\"超文本传输协议HTTP\"   >\n          <a href=\"#超文本传输协议HTTP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#超文本传输协议HTTP\" class=\"headerlink\" title=\"超文本传输协议HTTP\"></a>超文本传输协议HTTP</h3>\n      <p>HTTP协议定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p>\n<ul>\n<li>具体过程<ol>\n<li>浏览器分析URL</li>\n<li>浏览器向DNS请求解析地址</li>\n<li>DNS解析出IP地址</li>\n<li>浏览器与服务器建立TCP连接</li>\n<li>浏览器发出取文件命令</li>\n<li>服务器响应</li>\n<li>释放TCP连接</li>\n<li>浏览器显示</li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"HTTP协议的特点\"   >\n          <a href=\"#HTTP协议的特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP协议的特点\" class=\"headerlink\" title=\"HTTP协议的特点\"></a>HTTP协议的特点</h3>\n      <p>HTTP协议是无状态的</p>\n\n        <h1 id=\"完结\"   >\n          <a href=\"#完结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#完结\" class=\"headerlink\" title=\"完结\"></a>完结</h1>\n      ","categories":["考研学习","计算机网络"],"tags":["计算机网络","课堂笔记","考研学习"]},{"title":"【计算机操作系统】3-2-虚拟内存及页面置换","url":"/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8F%8A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/","content":"\n        <h1 id=\"虚拟内存的基本概念\"   >\n          <a href=\"#虚拟内存的基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#虚拟内存的基本概念\" class=\"headerlink\" title=\"虚拟内存的基本概念\"></a>虚拟内存的基本概念</h1>\n      <ul>\n<li>内存空间的分配与回收<ul>\n<li>连续分配<ul>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n<li>非连续分配<ul>\n<li>基本分页存储管理</li>\n<li>基本分段存储管理</li>\n<li>基本段页式存储管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内存空间的扩充<ul>\n<li>覆盖技术</li>\n<li>交换技术</li>\n<li>虚拟内存技术</li>\n</ul>\n</li>\n<li>地址转换</li>\n<li>存储保护</li>\n</ul>\n<p>在传统存储管理方式的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且能从逻辑上扩充内存容量。</p>\n<ul>\n<li>传动存储管理方式的特征、缺点</li>\n<li>局部性原理<ul>\n<li>时间局部性</li>\n<li>空间局部性</li>\n<li>高速缓存技术</li>\n</ul>\n</li>\n<li>虚拟内存的定义和特征</li>\n<li>如何实现虚拟内存技术</li>\n</ul>\n\n        <h2 id=\"传统存储管理方式的特征、缺点\"   >\n          <a href=\"#传统存储管理方式的特征、缺点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#传统存储管理方式的特征、缺点\" class=\"headerlink\" title=\"传统存储管理方式的特征、缺点\"></a>传统存储管理方式的特征、缺点</h2>\n      <ul>\n<li>连续分配<ul>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n<li>非连续分配<ul>\n<li>基本分页存储管理</li>\n<li>基本分段存储管理</li>\n<li>基本段页式存储管理</li>\n</ul>\n</li>\n</ul>\n<p>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高</p>\n<p>一次性：<strong>作业必须一次性全部装入内存后才能开始运行。</strong></p>\n<ul>\n<li>这会造成两个问题<ol>\n<li>作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong></li>\n<li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong>。</li>\n</ol>\n</li>\n</ul>\n<p>驻留性：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p>\n\n        <h2 id=\"局部性原理\"   >\n          <a href=\"#局部性原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h2>\n      <p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</p>\n<p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p>\n<p>高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中。</p>\n<p>快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中。</p>\n\n        <h2 id=\"虚拟内存的定义和特征\"   >\n          <a href=\"#虚拟内存的定义和特征\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#虚拟内存的定义和特征\" class=\"headerlink\" title=\"虚拟内存的定义和特征\"></a>虚拟内存的定义和特征</h2>\n      <p>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时不用的部分留在外存</strong>，就可以让程序开始执行。</p>\n<p>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。</p>\n<p>若内存空间不够，由<strong>操作系统负责</strong>将内存中<strong>暂时用不到的信息换出到外存</strong>。</p>\n<p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong></p>\n<p>操作系统虚拟性的一个体现，实际物理内存大小没有变，只是在逻辑上进行了扩充。</p>\n<ul>\n<li><p>易混知识点</p>\n<ul>\n<li>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构(CPU寻址范围)确定的</li>\n<li>虚拟内存的**实际容量=min(内存和外存容量的和，CPU寻址范围)</li>\n</ul>\n</li>\n<li><p>虚拟内存的三个主要特征：</p>\n<ul>\n<li>多次性：无需再作业运行时一次性全部装入内存而是允许被分成多次调入内存</li>\n<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li>\n<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"如何实现虚拟内存技术\"   >\n          <a href=\"#如何实现虚拟内存技术\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#如何实现虚拟内存技术\" class=\"headerlink\" title=\"如何实现虚拟内存技术\"></a>如何实现虚拟内存技术</h2>\n      <p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式基础上。</p>\n<ul>\n<li>传统的非连续分配存储管理<ul>\n<li>基本分页存储管理</li>\n<li>基本分段存储管理</li>\n<li>基本段页式存储管理</li>\n</ul>\n</li>\n<li>虚拟内存的实现<ul>\n<li>请求分页存储管理</li>\n<li>请求分段存储管理</li>\n<li>请求段页式存储管理</li>\n</ul>\n</li>\n</ul>\n<p>主要区别：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p>\n\n        <h2 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>传统存储管理方式的特征、缺点<ul>\n<li>一次性：作业数据必须一次全部调入内存</li>\n<li>驻留性：作业数据在整个运行期间都会常驻内存</li>\n</ul>\n</li>\n<li>局部性原理<ul>\n<li>时间局部性：现在访问的指令、数据在不久后可能会被再次访问</li>\n<li>空间局部性：现在访问的内存单元周围的内存空间，很可能在不久后会被访问</li>\n<li>高速缓存技术：使用频繁的数据放到更高速的存储器中</li>\n</ul>\n</li>\n<li>虚拟内存的定义和特征<ul>\n<li>程序不需全部装入如即可运行，运行时很具需要动态调入内存，若内存不够，还需换出一些数据</li>\n</ul>\n</li>\n<li>特征<ul>\n<li>多次性：无需再作业运行时一次性全部装入内存而是允许被分成多次调入内存</li>\n<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li>\n<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li>\n</ul>\n</li>\n<li>如何实现虚拟内存技术<ul>\n<li>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(请求调页功能)</li>\n<li>内存空间不够时，将内存中暂时用不到的信息换出到外存(页面置换功能)</li>\n<li>虚拟内存的实现<ul>\n<li>请求分页存储管理</li>\n<li>请求分段存储管理</li>\n<li>请求段页式存储管理</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"请求分页管理方式\"   >\n          <a href=\"#请求分页管理方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求分页管理方式\" class=\"headerlink\" title=\"请求分页管理方式\"></a>请求分页管理方式</h1>\n      <ul>\n<li>页表机制</li>\n<li>缺页中断机构</li>\n<li>地址变换机构</li>\n</ul>\n\n        <h2 id=\"页表机制\"   >\n          <a href=\"#页表机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#页表机制\" class=\"headerlink\" title=\"页表机制\"></a>页表机制</h2>\n      <p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存，如果还没导入，那么也需要知道该页面在外存中存放的位置。</p>\n<p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用浪费时间写会外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">页号</th>\n<th align=\"center\">内存块号</th>\n<th align=\"center\">状态位</th>\n<th align=\"center\">访问字段</th>\n<th align=\"center\">修改位</th>\n<th align=\"center\">外存地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">a</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">x</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">b</td>\n<td align=\"center\">1</td>\n<td align=\"center\">10</td>\n<td align=\"center\">0</td>\n<td align=\"center\">y</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">c</td>\n<td align=\"center\">1</td>\n<td align=\"center\">6</td>\n<td align=\"center\">4</td>\n<td align=\"center\">z</td>\n</tr>\n</tbody></table></div>\n\n        <h2 id=\"缺页中断机构\"   >\n          <a href=\"#缺页中断机构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#缺页中断机构\" class=\"headerlink\" title=\"缺页中断机构\"></a>缺页中断机构</h2>\n      <p>在请求分页系统中，每当要访问的<strong>页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的缺页<strong>终端处理程序处理中断</strong></p>\n<p>此时<strong>缺页的进程阻塞</strong>，放入阻塞队里，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</p>\n<p>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</p>\n<p>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过得页面不用写回外存。</p>\n<p><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此<strong>属于内中断</strong>。</p>\n<p>一条指令在执行期间，可能产生多次缺页中断。</p>\n<ul>\n<li>中断的分类<ul>\n<li>内中断(内部异常)<ul>\n<li>陷阱、陷入(trap)</li>\n<li>故障(fault)</li>\n<li>终止(abort)</li>\n</ul>\n</li>\n<li>外中断<ul>\n<li>I/O中断请求</li>\n<li>人工干预</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"地址变换机构\"   >\n          <a href=\"#地址变换机构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#地址变换机构\" class=\"headerlink\" title=\"地址变换机构\"></a>地址变换机构</h2>\n      <p><strong>请求分页</strong>存储管理与<strong>基本分页</strong>存储管理的主要区别：</p>\n<ol>\n<li>在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。</li>\n<li>若内存空间不够，由操作系统负责<strong>将内存中暂时用不到的信息换出到外存</strong>。</li>\n</ol>\n<p>快表中有的页面一定是在内存中的。若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面。</p>\n<ol>\n<li>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写会内存中的慢表。这样可以减少访存次数。</li>\n<li>和普通的中断处理一样，缺页中断仍然需要保留CPU现场。</li>\n<li>需要用某种“页面置换算法”来决定一个换出页面</li>\n<li>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销。</li>\n<li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中</li>\n</ol>\n<p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：</p>\n<ol>\n<li>查快表(未命中)</li>\n<li>查慢表(发现未调入内存)</li>\n<li>调页(调入的页面对应的表项会直接加入快表)</li>\n<li>查快表(命中)</li>\n<li>访问目标内存单元</li>\n</ol>\n\n        <h2 id=\"总结-1\"   >\n          <a href=\"#总结-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2>\n      <ul>\n<li>页表机制<ul>\n<li>在基本分页的基础上增加了几个表项</li>\n<li>状态位：表示页面是否已在内存中</li>\n<li>访问字段：记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</li>\n<li>修改位：表示页面调入内存后是否被修改过，只有修改过的页面才需在置换时写回外存。</li>\n<li>外存地址：页面在外存中存放的位置</li>\n</ul>\n</li>\n<li>缺页中断机构<ul>\n<li>找到页表项后检查页面是否已在内存，若没在内存，产生缺页中断</li>\n<li>缺页中断处理中，需要将目标页面调入内存，有必要还要换出页面</li>\n<li>缺页中断属于内中断，属于内中断的“故障”，即可能被系统修复的异常</li>\n<li>一条指令在执行过程中可能产生多次缺页中断</li>\n</ul>\n</li>\n<li>地址变换机构(重点灌注与基本分页不同的地方)<ul>\n<li>找到页表项是需要检查页面是否在内存中</li>\n<li>若页面不再内存中，需要请求调页</li>\n<li>若内存空间不够，还需换出页面</li>\n<li>页面调入内存后，需要修改相应页表项</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"页面置换算法\"   >\n          <a href=\"#页面置换算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h1>\n      <ul>\n<li><p>请求分页存储管理与基本分页存储管理的主要区别：</p>\n<ol>\n<li>在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外调入内存</strong>，然后继续执行程序。</li>\n<li>若内存空间不够，由操作系统负责<strong>将内存中暂时用不到的信息换出到外存</strong></li>\n</ol>\n</li>\n<li><p>最佳置换算法(OPT)</p>\n</li>\n<li><p>先进先出置换算法(FIFO)</p>\n</li>\n<li><p>最近最久未使用置换算法(LRU)</p>\n</li>\n<li><p>时钟置换算法(CLOCK)</p>\n</li>\n<li><p>改进型的时钟置换算法</p>\n</li>\n</ul>\n<p>页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该<strong>追求更少的缺页率</strong></p>\n\n        <h2 id=\"最佳置换算法-OPT\"   >\n          <a href=\"#最佳置换算法-OPT\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最佳置换算法-OPT\" class=\"headerlink\" title=\"最佳置换算法(OPT)\"></a>最佳置换算法(OPT)</h2>\n      <p>最佳置换算法(Optimal)：每次选择淘汰的页面将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p>\n<p>缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。</p>\n<p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列，因此<strong>最佳置换算法是无法实现的</strong>。</p>\n\n        <h2 id=\"先进先出置换算法-FIFO\"   >\n          <a href=\"#先进先出置换算法-FIFO\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#先进先出置换算法-FIFO\" class=\"headerlink\" title=\"先进先出置换算法(FIFO)\"></a>先进先出置换算法(FIFO)</h2>\n      <p>每次选择<strong>淘汰的页面</strong>时<strong>最早进入内存的页面</strong></p>\n<p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p>\n<ul>\n<li>Belady异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</li>\n</ul>\n<p><strong>只有FIFO算法会产生Belady异常</strong>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差</strong>。</p>\n\n        <h2 id=\"最近最久未使用置换算法-LRU\"   >\n          <a href=\"#最近最久未使用置换算法-LRU\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最近最久未使用置换算法-LRU\" class=\"headerlink\" title=\"最近最久未使用置换算法(LRU)\"></a>最近最久未使用置换算法(LRU)</h2>\n      <p>最近最久未使用置换算法(Least Recently Used)：每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></p>\n<p>实现方法：赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间t</strong></p>\n<p>当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>\n<p>|页面|内存块号|状态位|访问字段|修改位|外存地址|</p>\n<p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。<strong>在逆向扫描过程中最后一个出现的页号就是要淘汰的页面</strong></p>\n\n        <h2 id=\"时钟置换算法-CLOCK\"   >\n          <a href=\"#时钟置换算法-CLOCK\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#时钟置换算法-CLOCK\" class=\"headerlink\" title=\"时钟置换算法(CLOCK)\"></a>时钟置换算法(CLOCK)</h2>\n      <p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>\n<p>时钟置换算法是一种性能和开销较均衡的算法，又称<strong>CLOCK算法</strong>，或**最近未用算法(NRU,Not Recently Used)</p>\n<p>简单的CLOCK算法实现方式：为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针<strong>链接程一个循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过<strong>两轮扫描</strong>)</p>\n<p>|页号|内存块号|状态位|访问位|修改位|外存地址|</p>\n\n        <h2 id=\"改进型的时钟置换算法\"   >\n          <a href=\"#改进型的时钟置换算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#改进型的时钟置换算法\" class=\"headerlink\" title=\"改进型的时钟置换算法\"></a>改进型的时钟置换算法</h2>\n      <p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p>\n<p>最多进行四轮扫描</p>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【LFS】个性化Linux","url":"/%E3%80%90lfs%E3%80%91%E4%B8%AA%E6%80%A7%E5%8C%96linux/","content":"\n        <h1 id=\"教程和我的环境\"   >\n          <a href=\"#教程和我的环境\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#教程和我的环境\" class=\"headerlink\" title=\"教程和我的环境\"></a>教程和我的环境</h1>\n      <p>bilibili：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.bilibili.com/video/BV1TU4y1W7nV?p=1\" >一位UP的没有讲解的参考视频</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>LFS：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://bf.mengyan1223.wang/lfs/zh_CN/11.1/\" >LFS的官方中文文档</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"环境\"   >\n          <a href=\"#环境\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2>\n      <figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">宿主系统：CentOS-7-x86_64-DVD-2009.iso</span><br><span class=\"line\">两个硬盘：一个硬盘sda 20GB，一个硬盘sdb 100GB</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"初始化环境\"   >\n          <a href=\"#初始化环境\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#初始化环境\" class=\"headerlink\" title=\"初始化环境\"></a>初始化环境</h1>\n      <p>终端运行下面代码，生成环境检查文件</p>\n<figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; version-check.sh &lt;&lt; <span class=\"string\">&quot;EOF&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Simple script to list version numbers of critical development tools</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LC_ALL=C</span><br><span class=\"line\">bash --version | head -n1 | cut -d<span class=\"string\">&quot; &quot;</span> -f2-4</span><br><span class=\"line\">MYSH=$(readlink -f /bin/sh)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;/bin/sh -&gt; <span class=\"variable\">$MYSH</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$MYSH</span> | grep -q bash || <span class=\"built_in\">echo</span> <span class=\"string\">&quot;ERROR: /bin/sh does not point to bash&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">unset</span> MYSH</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;Binutils: &quot;</span>; ld --version | head -n1 | cut -d<span class=\"string\">&quot; &quot;</span> -f3-</span><br><span class=\"line\">bison --version | head -n1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -h /usr/bin/yacc ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;/usr/bin/yacc -&gt; `readlink -f /usr/bin/yacc`&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ -x /usr/bin/yacc ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> yacc is `/usr/bin/yacc --version | head -n1`</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;yacc not found&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;Coreutils: &quot;</span>; chown --version | head -n1 | cut -d<span class=\"string\">&quot;)&quot;</span> -f2</span><br><span class=\"line\">diff --version | head -n1</span><br><span class=\"line\">find --version | head -n1</span><br><span class=\"line\">gawk --version | head -n1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -h /usr/bin/awk ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;/usr/bin/awk -&gt; `readlink -f /usr/bin/awk`&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ -x /usr/bin/awk ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> awk is `/usr/bin/awk --version | head -n1`</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;awk not found&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">gcc --version | head -n1</span><br><span class=\"line\">g++ --version | head -n1</span><br><span class=\"line\">grep --version | head -n1</span><br><span class=\"line\">gzip --version | head -n1</span><br><span class=\"line\">cat /proc/version</span><br><span class=\"line\">m4 --version | head -n1</span><br><span class=\"line\">make --version | head -n1</span><br><span class=\"line\">patch --version | head -n1</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Perl `perl -V:version`</span><br><span class=\"line\">python3 --version</span><br><span class=\"line\">sed --version | head -n1</span><br><span class=\"line\">tar --version | head -n1</span><br><span class=\"line\">makeinfo --version | head -n1  <span class=\"comment\"># texinfo version</span></span><br><span class=\"line\">xz --version | head -n1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;int main()&#123;&#125;&#x27;</span> &gt; dummy.c &amp;&amp; g++ -o dummy dummy.c</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -x dummy ]</span><br><span class=\"line\">  <span class=\"keyword\">then</span> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;g++ compilation OK&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;g++ compilation failed&quot;</span>; <span class=\"keyword\">fi</span></span><br><span class=\"line\">rm -f dummy.c dummy</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></div></figure>\n\n<p>然后运行<code>bash version-check.sh</code>进行环境检查，发现有几个文件没有安装</p>\n<p>接下来安装这些文件</p>\n<figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum -y install bison</span><br><span class=\"line\">yum -y install python3</span><br><span class=\"line\">yum -y install gcc-c++.x86_64</span><br></pre></td></tr></table></div></figure>\n\n<p>在运行<code>bash version-check.sh</code>就会发现OK了</p>\n\n        <h1 id=\"硬盘分配\"   >\n          <a href=\"#硬盘分配\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#硬盘分配\" class=\"headerlink\" title=\"硬盘分配\"></a>硬盘分配</h1>\n      <p>我单独分了一块硬盘出来LFS，所以要初始化一下硬盘</p>\n<figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkfs -v -t ext4 /dev/sdb</span><br><span class=\"line\">mkdit /mnt/lfs</span><br><span class=\"line\"><span class=\"built_in\">export</span> LFS=/mnt/lfs</span><br><span class=\"line\">mount /dev/sdb <span class=\"variable\">$LFS</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"安装软件包和补丁\"   >\n          <a href=\"#安装软件包和补丁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#安装软件包和补丁\" class=\"headerlink\" title=\"安装软件包和补丁\"></a>安装软件包和补丁</h1>\n      <p>要下载<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://bf.mengyan1223.wang/lfs/zh_CN/11.1/wget-list\" >wget-list</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -v <span class=\"variable\">$LFS</span>/sources</span><br><span class=\"line\">chmod -v a+wt <span class=\"variable\">$LFS</span>/sources</span><br><span class=\"line\">wget --input-file=wget-list --<span class=\"built_in\">continue</span> --directory-prefix=<span class=\"variable\">$LFS</span>/sources</span><br></pre></td></tr></table></div></figure>\n\n<p>我这里虚拟机的CentOS 7连不上github，然后我配置了一个Clash，用了我自己的节点，进行的下载。如果你下载不了的话自己想办法吧，仁者见仁智者见智。</p>\n<p>好叭Clash配置也不好用，换了一个源</p>\n<p>下载<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.linux.cn/lfs/LFS-BOOK-7.7-systemd/wget-list-LFS7.7-systemd-USTC\" >wget-list-LFS7.7-systemd-USTC</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>感谢中科大提供的源！</p>\n<p>下载<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.linux.cn/lfs/LFS-BOOK-7.7-systemd/md5sums\" >md5sums</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>进行验证是否下载完成</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">md5sum -c md5sums</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"最后的准备工作\"   >\n          <a href=\"#最后的准备工作\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最后的准备工作\" class=\"headerlink\" title=\"最后的准备工作\"></a>最后的准备工作</h1>\n      <figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -v $LFS/tools</span><br><span class=\"line\">ln -sv $LFS/tools /</span><br></pre></td></tr></table></div></figure>\n\n<p>在执行第一个命令的时候不知道为什么全局变量$LFS失效了，在根目录生了tools文件夹，导致第二步一直不成功。把文件夹都删了重新来就行了。</p>\n<p>现在知道了，export设置的全局变量仅在当前终端有效，关了终端就没了，得重新设置！！！</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">groupadd lfs</span><br><span class=\"line\">useradd -s /bin/bash -g lfs -m -k /dev/null lfs</span><br><span class=\"line\">passwd lfs</span><br><span class=\"line\">//我设置成了123456</span><br><span class=\"line\">chown -v lfs $LFS/tools</span><br><span class=\"line\">chown -v lfs $LFS/sources</span><br><span class=\"line\">su - lfs//登录lfs</span><br></pre></td></tr></table></div></figure>\n\n<p>接着在bash下设置环境</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; ~/.bash_profile &lt;&lt; &quot;EOF&quot;</span><br><span class=\"line\">exec env -i HOME=$HOME TERM=$TERM PS1=&#x27;\\u:\\w\\$ &#x27; /bin/bash</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; ~/.bashrc &lt;&lt; &quot;EOF&quot;</span><br><span class=\"line\">set +h</span><br><span class=\"line\">umask 022</span><br><span class=\"line\">LFS=/mnt/lfs</span><br><span class=\"line\">LC_ALL=POSIX</span><br><span class=\"line\">LFS_TGT=$(uname -m)-lfs-linux-gnu</span><br><span class=\"line\">PATH=/tools/bin:/bin:/usr/bin</span><br><span class=\"line\">export LFS LC_ALL LFS_TGT PATH</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">source ~/.bash_profile</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"构建临时系统\"   >\n          <a href=\"#构建临时系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#构建临时系统\" class=\"headerlink\" title=\"构建临时系统\"></a>构建临时系统</h1>\n      <figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod 777 -R $LFS</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">//root下载texinfo</span><br><span class=\"line\">yum install -y texinfo</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd $LFS/sources/</span><br><span class=\"line\">tar -jxvf binutils-2.25.tar.bz2</span><br><span class=\"line\">cd ../binutils-2.25</span><br><span class=\"line\">sed -i &#x27;/k prot/agcc_cv_libc_provides_ssp=yes&#x27; gcc/configure</span><br><span class=\"line\">mkdir -v ../binutils-build</span><br><span class=\"line\">cd ../binutils-build</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">../binutils-2.25/configure     \\</span><br><span class=\"line\">    --prefix=/tools            \\</span><br><span class=\"line\">    --with-sysroot=$LFS        \\</span><br><span class=\"line\">    --with-lib-path=/tools/lib \\</span><br><span class=\"line\">    --target=$LFS_TGT          \\</span><br><span class=\"line\">    --disable-nls              \\</span><br><span class=\"line\">    --disable-werror</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ..</span><br><span class=\"line\">rm -rf binutils-build</span><br><span class=\"line\">rm -rf binutils-2.25</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">//root运行</span><br><span class=\"line\">chmod u+w /etc/sudoers</span><br><span class=\"line\">vi /etc/sudoers</span><br><span class=\"line\">//把lfs添加到sudoer</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -xf gmp-6.0.0a.tar.xz</span><br><span class=\"line\">cd gmp-6.0.0</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br><span class=\"line\"></span><br><span class=\"line\">cd ..</span><br><span class=\"line\">tar -xf mpfr-3.1.2.tar.xz</span><br><span class=\"line\">cd mpfr-3.1.2</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br><span class=\"line\"></span><br><span class=\"line\">cd ..</span><br><span class=\"line\">tar -xf mpc-1.0.2.tar.xz</span><br><span class=\"line\">cd mpc-1.0.2</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ..</span><br><span class=\"line\">tar -jxvf gcc-4.9.2.tar.bz2</span><br><span class=\"line\">mkdir -v gcc-build</span><br><span class=\"line\">cd gcc-build</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">../gcc-4.9.2/configure                             \\</span><br><span class=\"line\">    --target=$LFS_TGT                              \\</span><br><span class=\"line\">    --prefix=/tools                                \\</span><br><span class=\"line\">    --with-sysroot=$LFS                            \\</span><br><span class=\"line\">    --with-newlib                                  \\</span><br><span class=\"line\">    --without-headers                              \\</span><br><span class=\"line\">    --with-local-prefix=/tools                     \\</span><br><span class=\"line\">    --with-native-system-header-dir=/tools/include \\</span><br><span class=\"line\">    --disable-nls                                  \\</span><br><span class=\"line\">    --disable-shared                               \\</span><br><span class=\"line\">    --disable-multilib                             \\</span><br><span class=\"line\">    --disable-decimal-float                        \\</span><br><span class=\"line\">    --disable-threads                              \\</span><br><span class=\"line\">    --disable-libatomic                            \\</span><br><span class=\"line\">    --disable-libgomp                              \\</span><br><span class=\"line\">    --disable-libitm                               \\</span><br><span class=\"line\">    --disable-libquadmath                          \\</span><br><span class=\"line\">    --disable-libsanitizer                         \\</span><br><span class=\"line\">    --disable-libssp                               \\</span><br><span class=\"line\">    --disable-libvtv                               \\</span><br><span class=\"line\">    --disable-libcilkrts                           \\</span><br><span class=\"line\">    --disable-libstdc++-v3                         \\</span><br><span class=\"line\">    --enable-languages=c,c++</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ..</span><br><span class=\"line\">rm -rf gcc-4.9.2</span><br><span class=\"line\">tar -xf linux-3.19.tar.xz</span><br><span class=\"line\">make mrproper</span><br><span class=\"line\">make INSTALL_HDR_PATH=dest headers_install</span><br><span class=\"line\">sudo cp -rv dest/include/* /tools/include</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ..</span><br><span class=\"line\">rm -rf linux-3.19</span><br><span class=\"line\">tar -xf glibc-2.21.tar.xz</span><br><span class=\"line\">mkdir -v glibc-build</span><br><span class=\"line\">cd glibc-build</span><br></pre></td></tr></table></div></figure>\n","categories":["计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【LFS】lfs之站在巨人的肩膀上学习","url":"/%E3%80%90lfs%E3%80%91lfs%E4%B9%8B%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A%E5%AD%A6%E4%B9%A0/","content":"\n        <h1 id=\"资源\"   >\n          <a href=\"#资源\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1>\n      <p>巨人来源：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://neat-farmer-555.notion.site/LFS-sysv-11-1-v0-1-f3ba51dc3fe540a0b92463f28b579693\" >https://neat-farmer-555.notion.site/LFS-sysv-11-1-v0-1-f3ba51dc3fe540a0b92463f28b579693</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>官方文档：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://linuxfromscratch.org/\" >https://linuxfromscratch.org/</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>系统镜像：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.releases.ubuntu.com/20.04/ubuntu-20.04.4-desktop-amd64.iso\" >http://www.releases.ubuntu.com/20.04/ubuntu-20.04.4-desktop-amd64.iso</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h1 id=\"环境\"   >\n          <a href=\"#环境\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1>\n      <p>系统：Ubuntu 20.04</p>\n","categories":["考研学习","计算机操作系统"],"tags":["考研学习","计算机操作系统"]},{"title":"【C++】单例模式编程实验","url":"/Program-C-%E3%80%90c-%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/","content":"\n        <h1 id=\"任务\"   >\n          <a href=\"#任务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h1>\n      <p>任务：单件模式是一种用于确保整个应用程序中只有一个类实例的程序设<br>计方法。</p>\n<p>请编写程序，设计并实现单例类，以完成以下功能：</p>\n<ol>\n<li>外部不能够任意实例化该类的对象；</li>\n<li>只能够通过该类的静态成员函数 Singleton::GetInstance()获得该类的唯一<br>对象，换言之，在任何地方通过该静态成员函数获得对象指针都是指向同一个<br>对象。</li>\n<li>设计该类的成员变量 string name 以及相应的成员函数（set/get 函数）对<br>对象的唯一性进行验证。</li>\n</ol>\n\n        <h1 id=\"解答\"   >\n          <a href=\"#解答\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h1>\n      \n        <h2 id=\"main-cpp\"   >\n          <a href=\"#main-cpp\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#main-cpp\" class=\"headerlink\" title=\"main.cpp\"></a>main.cpp</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Singleton.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Singleton *s = Singleton::<span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">    s-&gt;<span class=\"built_in\">SetName</span>(<span class=\"string\">&quot;Bob&quot;</span>);<span class=\"comment\">//题目给定</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Singleton * t = Singleton:: <span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">t-&gt;<span class=\"built_in\">SetName</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">fun</span>();</span><br><span class=\"line\">cout&lt;&lt;t-&gt;<span class=\"built_in\">GetName</span>()&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//题目给定</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"Singleton-h\"   >\n          <a href=\"#Singleton-h\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Singleton-h\" class=\"headerlink\" title=\"Singleton.h\"></a>Singleton.h</h2>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">static</span> Singleton *<span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">string <span class=\"title\">GetName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Singleton *_instance;</span><br><span class=\"line\">        string name;</span><br><span class=\"line\">&#125;;<span class=\"comment\">//类的定义，string类型必须要引用string</span></span><br><span class=\"line\"></span><br><span class=\"line\">Singleton* Singleton::_instance=<span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"comment\">//类外初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">Singleton::<span class=\"built_in\">Singleton</span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::GetInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_instance == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        _instance = <span class=\"keyword\">new</span> Singleton;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _instance;</span><br><span class=\"line\">&#125;<span class=\"comment\">//查找_instance是否创建，没创建新建一个，创建了返回地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Singleton::SetName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span></span>&#123;</span><br><span class=\"line\">    name = s;</span><br><span class=\"line\">&#125;<span class=\"comment\">//更改类中name</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">Singleton::GetName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;<span class=\"comment\">//获取name</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"出现过问题\"   >\n          <a href=\"#出现过问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#出现过问题\" class=\"headerlink\" title=\"出现过问题\"></a>出现过问题</h1>\n      \n        <h2 id=\"判断写成了赋值\"   >\n          <a href=\"#判断写成了赋值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#判断写成了赋值\" class=\"headerlink\" title=\"判断写成了赋值\"></a>判断写成了赋值</h2>\n      <p>if判断中的<code>等于</code>判断<code>==</code>，失手写成了赋值<code>=</code></p>\n\n        <h2 id=\"错误的引用string\"   >\n          <a href=\"#错误的引用string\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#错误的引用string\" class=\"headerlink\" title=\"错误的引用string\"></a>错误的引用string</h2>\n      <p>报错：<code>声明与 &quot;&lt;error-type&gt; Singleton::GetName()&quot; (已声明 所在行数:27，所属文件:&quot;C:\\USERS\\FENG\\DESKTOP\\C++\\第二次实验\\Singleton.h&quot;) 不兼容</code></p>\n<p>在<code>Singleton.h</code>头文件中没有包含<code>&lt;string&gt;</code>和<code>using namespace std; </code></p>\n\n        <h2 id=\"没有进行类外初始化！\"   >\n          <a href=\"#没有进行类外初始化！\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#没有进行类外初始化！\" class=\"headerlink\" title=\"没有进行类外初始化！\"></a>没有进行类外初始化！</h2>\n      <p>报错：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Feng\\AppData\\Local\\Temp\\ccfhC9e4.o:main.cpp:(.rdata$.refptr._ZN9Singleton9_instanceE[.refptr._ZN9Singleton9_instanceE]+0x0): undefined reference to `Singleton::_instance&#x27;</span><br><span class=\"line\">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>一定要进行类外初始化！</strong></p>\n<p><code>static</code>静态成员一定要进行类外初始化！</p>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Singleton* Singleton::_instance=<span class=\"literal\">nullptr</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"为什么一定要初始化\"   >\n          <a href=\"#为什么一定要初始化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#为什么一定要初始化\" class=\"headerlink\" title=\"为什么一定要初始化\"></a>为什么一定要初始化</h3>\n      <p><code>static</code>数据成员在类外定义和初始化是为了<strong>保证只被定义和初始化一次</strong>,这样编译器就不必考虑类的函数里面第一个对<code>static</code>变量的<code>=</code>操作是赋值还是初始化了。 <code>static</code> <code>const</code> <code>int</code>可以在类里面初始化，是因为它既然是<code>const</code>的，那程序就不会再去试图初始化了。</p>\n\n        <h3 id=\"为什么一定要类外\"   >\n          <a href=\"#为什么一定要类外\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#为什么一定要类外\" class=\"headerlink\" title=\"为什么一定要类外\"></a>为什么一定要类外</h3>\n      <p>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，每次新建对象都会创建一个静态成员，导致每个对象都包含该静态成员，这是矛盾的！</p>\n","categories":["编程语言","C++","课堂笔记"],"tags":["编程语言","C++"]},{"title":"【C++】多态与RTTI实验","url":"/Program-C-%E3%80%90c-%E3%80%91%E5%A4%9A%E6%80%81%E4%B8%8Ertti%E5%AE%9E%E9%AA%8C/","content":"\n        <h1 id=\"项目要求\"   >\n          <a href=\"#项目要求\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#项目要求\" class=\"headerlink\" title=\"项目要求\"></a>项目要求</h1>\n      <ol>\n<li>要有相同的属性（成员变量）和行为（成员函数）。</li>\n<li>都可以实现某一功能，但是实现的细节不一样。</li>\n<li>两个子类要有完全不同的、各自特有的行为。</li>\n<li>在 main 函数中通过一个基类指针数组来指向所有的派生类对象，然后通过遍历该数组调用上述所有函数，并能显示构造函数、析构函数的调用细节。</li>\n</ol>\n<p><img src=\"./task.png\" alt=\"任务.png\"></p>\n\n        <h1 id=\"解题源码\"   >\n          <a href=\"#解题源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解题源码\" class=\"headerlink\" title=\"解题源码\"></a>解题源码</h1>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Animal.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>(string str) :<span class=\"built_in\">name</span>(str) &#123; cout &lt;&lt; <span class=\"string\">&quot;Creating Animal&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;<span class=\"comment\">//接口，图中斜体是接口，后面必须要填充，否则会报抽象类错误。</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Animal</span>();</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string name;<span class=\"comment\">//图中带#的是protected的</span></span><br><span class=\"line\">&#125;;<span class=\"comment\">//基类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> :</span><span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>(string str) : <span class=\"built_in\">Animal</span>(str) &#123; cout &lt;&lt; <span class=\"string\">&quot;Creating Dog named &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Dog</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> :</span><span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Bird</span>(string str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Fly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Bird</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Animal.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Animal.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Animal::Eat</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; eating&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Animal::Speak</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; speaking&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">Animal::~<span class=\"built_in\">Animal</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Destroying Animal&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dog::Speak</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; barking!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dog::Run</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; runing!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">Dog::~<span class=\"built_in\">Dog</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Destroying Dog named &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Bird::<span class=\"built_in\">Bird</span>(string str) :<span class=\"built_in\">Animal</span>(str) &#123; cout &lt;&lt; <span class=\"string\">&quot;Creating Bird named &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bird::Speak</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; speaking!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bird::Fly</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; flying!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">Bird::~<span class=\"built_in\">Bird</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Destroying Bird named &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;Animal.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));<span class=\"comment\">//根据时间生成随机数种子</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">4</span>;</span><br><span class=\"line\">\tAnimal* allAnimals[SIZE];<span class=\"comment\">//基类指针数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">rand</span>() % <span class=\"number\">2</span> == <span class=\"number\">0</span>)<span class=\"comment\">//随机一个数，根据单双数生成</span></span><br><span class=\"line\">\t\t\tallAnimals[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Dog</span>(<span class=\"string\">&quot;dog&quot;</span> + <span class=\"built_in\">to_string</span>(i));<span class=\"comment\">//堆中生成，名字后面加了序号。to_string()能直接把任意类型转成字符串。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tallAnimals[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Bird</span>(<span class=\"string\">&quot;bird&quot;</span> + <span class=\"built_in\">to_string</span>(i));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Animal* pa : allAnimals) &#123; <span class=\"comment\">//范围循环</span></span><br><span class=\"line\">\t\tpa-&gt;<span class=\"built_in\">Speak</span>();</span><br><span class=\"line\">\t\tpa-&gt;<span class=\"built_in\">Eat</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(*pa) == <span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(Dog)) &#123;<span class=\"comment\">//判断类型</span></span><br><span class=\"line\">\t\t\tDog* pd = <span class=\"keyword\">dynamic_cast</span>&lt;Dog*&gt;(pa);<span class=\"comment\">//把基类指针数组的类型转换成派生类，这样才会和堆中的数据对得上。</span></span><br><span class=\"line\">\t\t\tpd-&gt;<span class=\"built_in\">Run</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(*pa) == <span class=\"built_in\"><span class=\"keyword\">typeid</span></span>(Bird)) &#123;</span><br><span class=\"line\">\t\t\tBird* pb = <span class=\"keyword\">dynamic_cast</span>&lt;Bird*&gt;(pa);</span><br><span class=\"line\">\t\t\tpb-&gt;<span class=\"built_in\">Fly</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> allAnimals[i];<span class=\"comment\">//释放堆中数据。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"问题\"   >\n          <a href=\"#问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1>\n      <ol>\n<li>RTTI 的基本含义是什么，通过哪些命令可以实现？<ul>\n<li>RTTI是“运行时类型识别”，它使程序能够获取由基类指针(引用)所指向的成员的实际派生类型。</li>\n<li>命令<ul>\n<li><code>dynamic_cast&lt;type&gt;(expression)</code></li>\n<li><code>typeid(expression)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>当使用基类指针指向派生类对象时，调用函数的规则是什么？<ul>\n<li>先调用基类函数，后调用派生类函数</li>\n</ul>\n</li>\n<li>C++提供几种强制类型转换？什么是向上类型转换、向下类型转换，本项目中使用了哪一个？<ul>\n<li>4种。</li>\n<li>向上类型转换：将派生类转换成基类;向下类型转换：将基类转换为派生类</li>\n<li>本项目中使用了向下类型转换。</li>\n</ul>\n</li>\n<li>什么是多态，有几种类型的多态，各自的实现机制是什么？本项目中采用的是哪一种多态？<ul>\n<li>多态：调用同名函数却因上下文不同会有不同实现的一种机制。</li>\n<li>2种</li>\n<li>静态多态：通过编译完成多态;动态多态：通过查找虚函数表完成多态</li>\n<li>动态多态</li>\n</ul>\n</li>\n</ol>\n","categories":["编程语言","C++","课堂笔记"],"tags":["编程语言","C++"]},{"title":"【C++】字符串类实验","url":"/Program-C-%E3%80%90c-%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%AE%9E%E9%AA%8C/","content":"\n        <h1 id=\"目的\"   >\n          <a href=\"#目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1>\n      <ol>\n<li>   学习类的定义、实例化的方法 </li>\n<li>   学习运算符重载的使用方法 </li>\n<li>   学习使用异常处理的使用方法 </li>\n<li>   体会面向对象程序设计方法</li>\n</ol>\n\n        <h1 id=\"任务\"   >\n          <a href=\"#任务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h1>\n      <ol>\n<li>设计一个 CString类，并实现以下功能。</li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CString</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o, <span class=\"keyword\">const</span> CString&amp; s);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CString</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str = <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    ~<span class=\"built_in\">CString</span>();</span><br><span class=\"line\">    <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> pos);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* _s;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"2\">\n<li>当发生下标越界等异常时，能够进行异常处理。</li>\n</ol>\n\n        <h1 id=\"源码\"   >\n          <a href=\"#源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//CString.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CString</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o, <span class=\"keyword\">const</span> CString&amp; s);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">CString</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str = <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t~<span class=\"built_in\">CString</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> pos);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* _s;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//CString.cpp </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;CString.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o, <span class=\"keyword\">const</span> CString&amp; s) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">strlen</span>(s._s);i++)</span><br><span class=\"line\">\t\tcout &lt;&lt; s._s[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span>&amp; CString::<span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> index) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= <span class=\"built_in\">strlen</span>(_s)) <span class=\"keyword\">throw</span> (<span class=\"string\">&quot;下标越界&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _s[index];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CString::<span class=\"built_in\">CString</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str) &#123;</span><br><span class=\"line\">\t_s = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(_s, str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CString::~<span class=\"built_in\">CString</span>() &#123; <span class=\"keyword\">delete</span>[] _s; &#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;CString.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">CString <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;I love China!&quot;</span>)</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        str[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;L&#x27;</span>;</span><br><span class=\"line\">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">        str[<span class=\"number\">20</span>] = <span class=\"string\">&#x27;L&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;异常:&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>\n      <ol>\n<li>请你简要描述异常处理的语法及基本要点：<ol>\n<li>检测是否满足条件后throw()出报错信息。</li>\n<li>在外面用try{}包括可能出现错误的语句块。</li>\n<li>Try{}后面用catch{}捕获语句，执行catch语句块中的代码。</li>\n<li>一个语句中只能有一个try块，但可以有多个catch语句块，以便与不同的异常类型匹配。catch语句必须有参数，如果try语句块中的代码抛出了异常，无论抛出的异常的值是什么，只要异常的类型与catch的参数类型匹配，异常就会被catch语句捕获。最后一个catch语句参数为…符号，表示可以捕获任意类型的异常。</li>\n<li>一旦某个catch语句捕获到了异常，后面的catch语句将不再被执行，其用法类似switch…case语句。</li>\n<li>try和catch语句块中的代码必须使用大括号{}括起来，即使语句块中只有一行代码。</li>\n<li>try语句和catch语句不能单独使用，必须连起来一起使用。</li>\n</ol>\n</li>\n<li>请你简要回答下标运算符[]的重载为什么要返回引用：<ol>\n<li>因为返回值存在堆中，需要内外对同一段数据进行操作，所以使用引用。</li>\n</ol>\n</li>\n<li>请你简要回答，为什么流输出运算符不能重载为成员函数。<ol>\n<li>如果重载为成员函数，那么使用起来就会变成：参数≪cout，不能进行连续输出，而且用起来还十分不方便。</li>\n</ol>\n</li>\n</ol>\n","categories":["编程语言","C++","课堂笔记"],"tags":["编程语言","C++"]},{"title":"【C++】引用交换实践作业","url":"/Program-C-%E3%80%90c-%E3%80%91%E5%BC%95%E7%94%A8%E4%BA%A4%E6%8D%A2%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/","content":"\n        <h1 id=\"类内定义的交换\"   >\n          <a href=\"#类内定义的交换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#类内定义的交换\" class=\"headerlink\" title=\"类内定义的交换\"></a>类内定义的交换</h1>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Swap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>: </span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap3</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;<span class=\"comment\">//这里要有分号！每一次都忘掉！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里老师强调要类外定义函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">_Swap::swap1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;\\t---swap1---&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">_Swap::swap2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pa = &amp;a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pb = &amp;b;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* temp;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;\\t---swap2---&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;初始化：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;pa = &quot;</span> &lt;&lt; *pa &lt;&lt; <span class=\"string\">&quot;, &amp;pa = &quot;</span> &lt;&lt; pa &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;pb = &quot;</span> &lt;&lt; *pb &lt;&lt; <span class=\"string\">&quot;, &amp;pb = &quot;</span> &lt;&lt; pb &lt;&lt; endl;</span><br><span class=\"line\">    temp = pa;</span><br><span class=\"line\">    pa = pb;</span><br><span class=\"line\">    pb = temp;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;pa = &quot;</span> &lt;&lt; *pa &lt;&lt; <span class=\"string\">&quot;, &amp;pa = &quot;</span> &lt;&lt; pa &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;pb = &quot;</span> &lt;&lt; *pb &lt;&lt; <span class=\"string\">&quot;, &amp;pb = &quot;</span> &lt;&lt; pb &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">_Swap::swap3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ra = a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;rb = b;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;\\t---swap3---&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot;, &amp;a = &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"string\">&quot;, &amp;b = &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;ra = &quot;</span> &lt;&lt; ra &lt;&lt; <span class=\"string\">&quot;, &amp;pa = &quot;</span> &lt;&lt; &amp;ra &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;rb = &quot;</span> &lt;&lt; rb &lt;&lt; <span class=\"string\">&quot;, &amp;pb = &quot;</span> &lt;&lt; &amp;rb &lt;&lt; endl;</span><br><span class=\"line\">    ra += rb;</span><br><span class=\"line\">    rb = ra - rb;</span><br><span class=\"line\">    ra -= rb;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot;, &amp;a = &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"string\">&quot;, &amp;b = &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;ra = &quot;</span> &lt;&lt; ra &lt;&lt; <span class=\"string\">&quot;, &amp;ra = &quot;</span> &lt;&lt; &amp;ra &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;rb = &quot;</span> &lt;&lt; rb &lt;&lt; <span class=\"string\">&quot;, &amp;rb = &quot;</span> &lt;&lt; &amp;rb &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义对象</span></span><br><span class=\"line\">    _Swap test;</span><br><span class=\"line\">    <span class=\"comment\">//对象内类的函数调用</span></span><br><span class=\"line\">    test.<span class=\"built_in\">swap1</span>();</span><br><span class=\"line\">    test.<span class=\"built_in\">swap2</span>();</span><br><span class=\"line\">    test.<span class=\"built_in\">swap3</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"按照实验要求写的程序\"   >\n          <a href=\"#按照实验要求写的程序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#按照实验要求写的程序\" class=\"headerlink\" title=\"按照实验要求写的程序\"></a>按照实验要求写的程序</h1>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里用了一个算法，没有使用中间变量过渡，而是通过运算进行交换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap1</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    a += b;</span><br><span class=\"line\">    b = a - b;</span><br><span class=\"line\">    a -= b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap2</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> *b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *temp;</span><br><span class=\"line\">    temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap3</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; a,<span class=\"keyword\">int</span>&amp; b)</span></span>&#123;</span><br><span class=\"line\">    a += b;</span><br><span class=\"line\">    b = a - b;</span><br><span class=\"line\">    a -= b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y = <span class=\"number\">200</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Before swap1:&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">swap1</span>(x, y);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;After swap1:&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    y = <span class=\"number\">200</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Before swap2:&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">swap2</span>(&amp;x, &amp;y);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;After swap2:&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    y = <span class=\"number\">200</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Before swap3:&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">swap3</span>(x, y);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;After swap3:&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"实验分析与总结\"   >\n          <a href=\"#实验分析与总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#实验分析与总结\" class=\"headerlink\" title=\"实验分析与总结\"></a>实验分析与总结</h1>\n      <ol>\n<li><p>变量交换结果：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Before swap1:100,200</span><br><span class=\"line\">After swap1:100,200</span><br></pre></td></tr></table></div></figure>\n<p>未成功交换，因为交换后的变量随函数栈释放了。</p>\n</li>\n<li><p>指针交换结果：</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Before swap2:100,200</span><br><span class=\"line\">After swap2:100,200</span><br></pre></td></tr></table></div></figure>\n<p>未成功交换，因为交换后的指针随函数栈释放了。</p>\n</li>\n<li><p>引用交换</p>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">Before swap3:100,200</span><br><span class=\"line\">After swap3:200,100</span><br></pre></td></tr></table></div></figure>\n<p>成功交换！因为函数内外操作的是同一地址。</p>\n</li>\n</ol>\n\n        <h1 id=\"出错总结\"   >\n          <a href=\"#出错总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#出错总结\" class=\"headerlink\" title=\"出错总结\"></a>出错总结</h1>\n      <ol>\n<li>定义类后一定要有<code>;</code>！</li>\n</ol>\n","categories":["编程语言","C++","课堂笔记"],"tags":["编程语言","C++"]},{"title":"【C++】类Point的设计与实现","url":"/Program-C-%E3%80%90c-%E3%80%91%E7%B1%BBpoint%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","content":"\n        <h1 id=\"实验目的\"   >\n          <a href=\"#实验目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h1>\n      <ul>\n<li>通过实验掌握常见运算符的重载规则。</li>\n<li>任务<ul>\n<li>请编写程序，设计并实现表示二维坐标下的点类 Point（其中封装了float x,y 两个坐标），以完成以下功能：<ol>\n<li>按照[x,y]的形式输出一个点对象；</li>\n<li>实现点对象的前++、后++的功能，其中 x 和 y 分别自增；</li>\n<li>实现点对象的加法运算。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h1 id=\"源码\"   >\n          <a href=\"#源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1>\n      <blockquote>\n<p>Point102.h</p>\n</blockquote>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once    <span class=\"comment\">//保证同一个文件不会被编译多次</span></span></span><br><span class=\"line\"><span class=\"comment\">//#include&lt;iostream&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point102</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; cout, <span class=\"keyword\">const</span> Point102&amp; point);</span><br><span class=\"line\">    <span class=\"comment\">//重载ostream类中的&lt;&lt;并友元</span></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> Point102 <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; x, <span class=\"keyword\">const</span> Point102&amp; other);</span><br><span class=\"line\">    <span class=\"comment\">//双目运算符需要类外重载，常数+x</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Point102</span>(<span class=\"keyword\">float</span> xx = <span class=\"number\">0</span>, <span class=\"keyword\">float</span> yy = <span class=\"number\">0</span>) :<span class=\"built_in\">x</span>(xx), <span class=\"built_in\">y</span>(yy) &#123;&#125;</span><br><span class=\"line\">\tPoint102 <span class=\"keyword\">operator</span>++();  <span class=\"comment\">//前置++</span></span><br><span class=\"line\">\tPoint102 <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>);   <span class=\"comment\">//后置++</span></span><br><span class=\"line\">\tPoint102 <span class=\"keyword\">operator</span>+(<span class=\"keyword\">int</span> xx); <span class=\"comment\">//x+常数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<blockquote>\n<p>Point102.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Point102.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; cout, <span class=\"keyword\">const</span> Point102&amp; point) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;[&quot;</span> &lt;&lt; point.x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; point.y &lt;&lt; <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cout;</span><br><span class=\"line\">&#125;<span class=\"comment\">//重载&lt;&lt;，必须在类外重载，类内友元</span></span><br><span class=\"line\"></span><br><span class=\"line\">Point102 Point102::<span class=\"keyword\">operator</span>++() &#123;</span><br><span class=\"line\">\t++x;</span><br><span class=\"line\">\t++y;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//前置++</span></span><br><span class=\"line\"></span><br><span class=\"line\">Point102 Point102::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"function\">Point102 <span class=\"title\">r</span><span class=\"params\">(*<span class=\"keyword\">this</span>)</span></span>;<span class=\"comment\">//复制一个出来</span></span><br><span class=\"line\">\t++(*<span class=\"keyword\">this</span>);<span class=\"comment\">//这里的++已经被前面重载了</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;<span class=\"comment\">//返回之前复制的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point102 Point102::<span class=\"keyword\">operator</span>+(<span class=\"keyword\">int</span> xx) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Point102</span>(xx+x,y);<span class=\"comment\">//这里return出来了，但并不更改对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point102 <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;x,<span class=\"keyword\">const</span> Point102&amp; other) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Point102</span>(x + other.x, other.y);</span><br><span class=\"line\">&#125;<span class=\"comment\">//类外定义常数+x，常数在前</span></span><br></pre></td></tr></table></div></figure>\n\n<blockquote>\n<p>PointProject102.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Point102.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Point102 <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span>, b</span>;<span class=\"comment\">//定义对象a和b</span></span><br><span class=\"line\">    cout &lt;&lt; a++ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = <span class=\"number\">10</span>;</span><br><span class=\"line\">    b = a + d;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; <span class=\"string\">&quot;+&quot;</span> &lt;&lt; d &lt;&lt; <span class=\"string\">&quot;=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    b = d + a;</span><br><span class=\"line\">    cout &lt;&lt; d &lt;&lt; <span class=\"string\">&quot;+&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot;=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>\n      <ol>\n<li>双目运算符为什么要类外重载还不得而知==、</li>\n<li>输入输出运算符必须要类外重载，如果用成员函数重载那么就会变成<code>test&lt;&lt;cout</code>，和习惯不符，且这样就莫得办法连续运算。</li>\n</ol>\n","categories":["编程语言","C++","课堂笔记"],"tags":["编程语言","C++"]},{"title":"【蓝桥】学前热身题：阶乘计算","url":"/Program-lanqiao-%E3%80%90%E8%93%9D%E6%A1%A5%E3%80%91%E5%AD%A6%E5%89%8D%E7%83%AD%E8%BA%AB%E9%A2%98%EF%BC%9A%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97/","content":"\n        <h1 id=\"题目描述\"   >\n          <a href=\"#题目描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1>\n      \n        <h2 id=\"题目描述-1\"   >\n          <a href=\"#题目描述-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2>\n      <p>给定一个正整数 n，求出 n! 的值。</p>\n\n        <h2 id=\"输入描述\"   >\n          <a href=\"#输入描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述\"></a>输入描述</h2>\n      <p>输入一个正整数 n，n&lt;=1000。</p>\n\n        <h2 id=\"输出描述\"   >\n          <a href=\"#输出描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述\"></a>输出描述</h2>\n      <p>输出n!。</p>\n\n        <h2 id=\"输入输出样例\"   >\n          <a href=\"#输入输出样例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2>\n      \n        <h3 id=\"示例\"   >\n          <a href=\"#示例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3>\n      <blockquote>\n<p>输入</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>输出</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">3628800</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"运行限制\"   >\n          <a href=\"#运行限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运行限制\" class=\"headerlink\" title=\"运行限制\"></a>运行限制</h2>\n      <ul>\n<li>最大运行时间：1s</li>\n<li>最大运行内存: 128M</li>\n</ul>\n\n        <h1 id=\"解题\"   >\n          <a href=\"#解题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h1>\n      \n        <h2 id=\"源码\"   >\n          <a href=\"#源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2>\n      \n        <h3 id=\"C\"   >\n          <a href=\"#C\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> A[<span class=\"number\">10000</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        p = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">            p = A[j] * i + p;</span><br><span class=\"line\">            A[j] = p % <span class=\"number\">10</span>;</span><br><span class=\"line\">            p = p / <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">10000</span>; A[i] == <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        tail = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = tail; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        cout &lt;&lt; A[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"Python\"   >\n          <a href=\"#Python\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3>\n      <figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\">ans = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,n+<span class=\"number\">1</span>):</span><br><span class=\"line\">  ans *= i</span><br><span class=\"line\"><span class=\"built_in\">print</span>(ans)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>\n      \n        <h2 id=\"C-版\"   >\n          <a href=\"#C-版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-版\" class=\"headerlink\" title=\"C++版\"></a>C++版</h2>\n      <ol>\n<li>C++的思路是利用数组突破数据限制，创建了一个极大的数组，并初始化为0，每一位表示一位，利用p做中间变量进行进位。</li>\n<li>输出的时候由于不确定数组多长，所以要从后向前找到第一个不为0的作为尾部。</li>\n<li>然后从尾部循环输出结束</li>\n</ol>\n\n        <h2 id=\"Python版\"   >\n          <a href=\"#Python版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python版\" class=\"headerlink\" title=\"Python版\"></a>Python版</h2>\n      <ol>\n<li>Python能自动扩充数据长度，所以直接写个循环就行了</li>\n<li>需要注意python的range最后结尾到n+1但不包括n+1</li>\n</ol>\n","categories":["编程语言","蓝桥"],"tags":["编程语言","蓝桥"]},{"title":"【蓝桥】学前热身题：高精度加法","url":"/Program-lanqiao-%E3%80%90%E8%93%9D%E6%A1%A5%E3%80%91%E5%AD%A6%E5%89%8D%E7%83%AD%E8%BA%AB%E9%A2%98%EF%BC%9A%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/","content":"\n        <h1 id=\"题目\"   >\n          <a href=\"#题目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1>\n      \n        <h2 id=\"题目描述\"   >\n          <a href=\"#题目描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2>\n      <p>给定两个整数 <strong>a</strong> 和 <strong>b</strong>，请你求出这两个整数的和。</p>\n\n        <h2 id=\"输入描述\"   >\n          <a href=\"#输入描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述\"></a>输入描述</h2>\n      <p>输入两个正整数 <strong>a,b</strong>，<strong>a</strong> 和 <strong>b</strong> 都不超过 <strong>100</strong> 位。</p>\n\n        <h2 id=\"输出描述\"   >\n          <a href=\"#输出描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述\"></a>输出描述</h2>\n      <p>输出a+b</p>\n\n        <h2 id=\"输入输出样例\"   >\n          <a href=\"#输入输出样例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2>\n      \n        <h3 id=\"示例\"   >\n          <a href=\"#示例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3>\n      <blockquote>\n<p>输入</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1234567890123456789</span><br><span class=\"line\">9876543210987654321</span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>输出</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111101111111110</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"运行限制\"   >\n          <a href=\"#运行限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运行限制\" class=\"headerlink\" title=\"运行限制\"></a>运行限制</h2>\n      <ul>\n<li>最大运行时间：1s</li>\n<li>最大运行内存: 128M</li>\n</ul>\n\n        <h1 id=\"解题\"   >\n          <a href=\"#解题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h1>\n      \n        <h2 id=\"源码\"   >\n          <a href=\"#源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2>\n      \n        <h3 id=\"C\"   >\n          <a href=\"#C\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">add</span><span class=\"params\">(string a, string b)</span> </span>&#123;</span><br><span class=\"line\">\tstring c;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> up = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"built_in\"><span class=\"keyword\">int</span></span>(a.<span class=\"built_in\">size</span>()) - <span class=\"number\">1</span>, j = <span class=\"built_in\"><span class=\"keyword\">int</span></span>(b.<span class=\"built_in\">size</span>()) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> || j &gt;= <span class=\"number\">0</span> || up &gt; <span class=\"number\">0</span>; i--, j--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tup += a[i] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tup += b[j] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t\tc += up % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t\tup /= <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">reverse</span>(c.<span class=\"built_in\">begin</span>(), c.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring a, b;</span><br><span class=\"line\">\tcin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">add</span>(a, b);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"Python\"   >\n          <a href=\"#Python\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3>\n      <figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\">b=<span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a+b)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>\n      \n        <h2 id=\"C-版\"   >\n          <a href=\"#C-版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-版\" class=\"headerlink\" title=\"C++版\"></a>C++版</h2>\n      <ol>\n<li>将数据转换成了字符串类型，类似循环入栈，最后逆转结果字符串就可以了</li>\n<li>重要的是对循环的把控，由于AB的位数可能不同，所以需要i,j两个变量控制循环，有时候最后一位进位无法进入循环，所以要在条件中增加up进位标志&gt;0。</li>\n<li> reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值。</li>\n</ol>\n\n        <h2 id=\"Python版\"   >\n          <a href=\"#Python版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python版\" class=\"headerlink\" title=\"Python版\"></a>Python版</h2>\n      <ol>\n<li>和上一题一样，python能自动扩容，不需要多处理</li>\n</ol>\n","categories":["编程语言","蓝桥"],"tags":["编程语言","蓝桥"]},{"title":"自用软件下载地址合集","url":"/Other-%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%90%88%E9%9B%86/","content":"\n        <h1 id=\"Environment\"   >\n          <a href=\"#Environment\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h1>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.python.org/downloads/\" >Python</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（Python环境，建议开加速，不然下一年）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://git-scm.com/download/win\" >Git</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（Github客户端）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://nodejs.org/en/\" >Nodejs</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.java.com/zh-CN/\" >JAVA</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://msdn.itellyou.cn/\" >SQL Server 2019</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（在里面的服务器里，自己找找吧）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://sourceforge.net/projects/mingw-w64/\" >mingw-w64</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>(C语言编译器)</li>\n</ul>\n\n        <h1 id=\"IDE\"   >\n          <a href=\"#IDE\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h1>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://code.visualstudio.com/\" >VS Code</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>(集成环境，我主要用来写markdown)</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://visualstudio.microsoft.com/zh-hans/\" >Visual Studio</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>(C++编译集成环境)</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.jetbrains.com/pycharm/\" >Pycharm</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>(Python集成编译环境)</li>\n</ul>\n\n        <h1 id=\"Softwares\"   >\n          <a href=\"#Softwares\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Softwares\" class=\"headerlink\" title=\"Softwares\"></a>Softwares</h1>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://im.qq.com/pcqq\" >QQ</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>(PC版QQ官网)</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://music.163.com/#/download\" >网易云音乐</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（精神毒药）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.dingtalk.com/\" >钉钉</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（日你妈钉钉）</li>\n</ul>\n\n        <h2 id=\"Tools\"   >\n          <a href=\"#Tools\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Tools\" class=\"headerlink\" title=\"Tools\"></a>Tools</h2>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.7-zip.org/\" >7Z</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（压缩包工具）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://obsproject.com/\" >OBS</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（录屏工具）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.xunlei.com/\" >迅雷</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（下载工具）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.nn.com/\" >nn加速器</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（免费的加速器）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?redirectedfrom=MSDN&view=sql-server-ver15\" >SSMS</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（数据库管理工具）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.xp.cn/download.html\" >PhpStudy</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（本地web环境搭建）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html\" >VMware</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（虚拟机）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.huorong.cn/\" >火绒安全</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（杀毒软件、启动项管理、右键管理）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.123pan.com/s/HQeA-9O1Sh\" >StartIsBack</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（美化开始窗口、任务栏居中）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://guanjia.qq.com/product/zmzl/\" >腾讯桌面管家</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（桌面文件美化）</li>\n</ul>\n\n        <h2 id=\"Game\"   >\n          <a href=\"#Game\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Game\" class=\"headerlink\" title=\"Game\"></a>Game</h2>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://store.steampowered.com/\" >Steam</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>(Steam平台)</li>\n</ul>\n\n        <h2 id=\"Theme\"   >\n          <a href=\"#Theme\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Theme\" class=\"headerlink\" title=\"Theme\"></a>Theme</h2>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.itmop.com/downinfo/198699.html\" >鼠标主题</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（Mac主题的鼠标）</li>\n</ul>\n","categories":["其它"],"tags":["其它"]},{"title":"【蓝桥】队列操作","url":"/%E3%80%90%E8%93%9D%E6%A1%A5%E3%80%91%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C/","content":"\n        <h1 id=\"题目\"   >\n          <a href=\"#题目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1>\n      \n        <h2 id=\"题目描述\"   >\n          <a href=\"#题目描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2>\n      \n        <h2 id=\"输入描述\"   >\n          <a href=\"#输入描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述\"></a>输入描述</h2>\n      \n        <h2 id=\"输出描述\"   >\n          <a href=\"#输出描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述\"></a>输出描述</h2>\n      \n        <h2 id=\"输入输出样例\"   >\n          <a href=\"#输入输出样例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2>\n      \n        <h3 id=\"示例\"   >\n          <a href=\"#示例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3>\n      <blockquote>\n<p>输入</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>输出</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"运行限制\"   >\n          <a href=\"#运行限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运行限制\" class=\"headerlink\" title=\"运行限制\"></a>运行限制</h2>\n      <ul>\n<li>最大运行时间：1s</li>\n<li>最大运行内存: 128M</li>\n</ul>\n\n        <h1 id=\"解题\"   >\n          <a href=\"#解题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h1>\n      \n        <h2 id=\"源码\"   >\n          <a href=\"#源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2>\n      \n        <h3 id=\"C\"   >\n          <a href=\"#C\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"Python\"   >\n          <a href=\"#Python\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3>\n      <figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>\n      \n        <h2 id=\"C-版\"   >\n          <a href=\"#C-版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-版\" class=\"headerlink\" title=\"C++版\"></a>C++版</h2>\n      <ol>\n<li></li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常规手写队列模板以及原子操作</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXQSIZE 100003        <span class=\"comment\">//自定义队列大小</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">myqueue</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[MAXQSIZE];      <span class=\"comment\">//分配静态空间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> head;                  <span class=\"comment\">//队头，指向队头的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rear;                <span class=\"comment\">//队尾，指向下一个可以放元素的空位置</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;             <span class=\"comment\">//初始化</span></span><br><span class=\"line\">        head = rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>&#123;              <span class=\"comment\">//返回队列长度</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (rear - head + MAXQSIZE) % MAXQSIZE; <span class=\"comment\">//防止出现负数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span></span>&#123;            <span class=\"comment\">//判断队列是否为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">size</span>()==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>          <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> e)</span></span>&#123;        <span class=\"comment\">//队尾插入新元素。新的rear指向下一个空的位置</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>((rear + <span class=\"number\">1</span>) % MAXQSIZE == head ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">//队列满</span></span><br><span class=\"line\">         data[rear] = e;</span><br><span class=\"line\">         rear = (rear + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;e)</span></span>&#123;        <span class=\"comment\">//删除队头元素，并返回它</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>(head == rear) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;   <span class=\"comment\">//队列空</span></span><br><span class=\"line\">         e = data[head];</span><br><span class=\"line\">         head = (head + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">front</span><span class=\"params\">()</span></span>&#123;            <span class=\"comment\">//返回队首，但是不删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[head];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"Python版\"   >\n          <a href=\"#Python版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python版\" class=\"headerlink\" title=\"Python版\"></a>Python版</h2>\n      <p>1. </p>\n","categories":["编程语言","蓝桥"],"tags":["编程语言","蓝桥"]},{"title":"【蓝桥】学前热身题：回形取数","url":"/Program-lanqiao-%E3%80%90%E8%93%9D%E6%A1%A5%E3%80%91%E5%AD%A6%E5%89%8D%E7%83%AD%E8%BA%AB%E9%A2%98%EF%BC%9A%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/","content":"\n        <h1 id=\"题目\"   >\n          <a href=\"#题目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1>\n      \n        <h2 id=\"题目描述\"   >\n          <a href=\"#题目描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2>\n      <p>回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。</p>\n\n        <h2 id=\"输入描述\"   >\n          <a href=\"#输入描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述\"></a>输入描述</h2>\n      <p>输入第一行是两个不超过 200 的正整数 m, n，表示矩阵的行和列。接下来 m 行每行 n 个整数，表示这个矩阵。</p>\n\n        <h2 id=\"输出描述\"   >\n          <a href=\"#输出描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述\"></a>输出描述</h2>\n      <p>输出只有一行，共 mn 个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。</p>\n\n        <h2 id=\"输入输出样例\"   >\n          <a href=\"#输入输出样例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2>\n      \n        <h3 id=\"示例\"   >\n          <a href=\"#示例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3>\n      <blockquote>\n<p>输入</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 3</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">4 5 6</span><br><span class=\"line\">7 8 9</span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>输出</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 4 7 8 9 6 3 2 5</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"运行限制\"   >\n          <a href=\"#运行限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运行限制\" class=\"headerlink\" title=\"运行限制\"></a>运行限制</h2>\n      <ul>\n<li>最大运行时间：1s</li>\n<li>最大运行内存: 128M</li>\n</ul>\n\n        <h1 id=\"解题\"   >\n          <a href=\"#解题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h1>\n      \n        <h2 id=\"源码\"   >\n          <a href=\"#源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2>\n      \n        <h3 id=\"C\"   >\n          <a href=\"#C\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m, n;</span><br><span class=\"line\">\tcin &gt;&gt; m &gt;&gt; n;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[m][n] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">\t\t\tcin &gt;&gt; a[i][j];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = m * n; </span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (sum)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (a[++i][j] != <span class=\"number\">-1</span> &amp;&amp; i &lt; m)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[i][j]);</span><br><span class=\"line\">\t\t\ta[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ti--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (a[i][++j] != <span class=\"number\">-1</span> &amp;&amp; j &lt; n)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[i][j]);</span><br><span class=\"line\">\t\t\ta[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tj--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (a[--i][j] != <span class=\"number\">-1</span> &amp;&amp; i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[i][j]);</span><br><span class=\"line\">\t\t\ta[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (a[i][--j] != <span class=\"number\">-1</span> &amp;&amp; j &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[i][j]);</span><br><span class=\"line\">\t\t\ta[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"Python\"   >\n          <a href=\"#Python\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3>\n      <figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">m,n = <span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>,<span class=\"built_in\">input</span>().split())</span><br><span class=\"line\">s=[[]*n]*m</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">    s[i]=[<span class=\"built_in\">int</span>(j) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">input</span>().split()] <span class=\"comment\"># 这里传进去是数组，所以最外面是中括号</span></span><br><span class=\"line\"><span class=\"comment\"># 这个时候的s：[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> m&lt;n:<span class=\"built_in\">min</span>=m</span><br><span class=\"line\"><span class=\"keyword\">else</span>:<span class=\"built_in\">min</span>=n</span><br><span class=\"line\"><span class=\"built_in\">len</span>=<span class=\"built_in\">int</span>((<span class=\"built_in\">min</span>+<span class=\"number\">1</span>)/<span class=\"number\">2</span>)  <span class=\"comment\">#获得中间线</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t==<span class=\"built_in\">len</span>-<span class=\"number\">1</span> <span class=\"keyword\">and</span> (<span class=\"built_in\">min</span>+<span class=\"number\">1</span>)%<span class=\"number\">2</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m&lt;n:<span class=\"comment\">#横向输出</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(t,n-t):</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(s[t][i],sep=<span class=\"string\">&#x27; &#x27;</span>,end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:<span class=\"comment\">#纵向输出</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(t,m-t):</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(s[i][t],sep=<span class=\"string\">&#x27; &#x27;</span>,end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(t,m-t):<span class=\"comment\">#向下读</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(s[i][t],sep=<span class=\"string\">&#x27; &#x27;</span>,end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(t+<span class=\"number\">1</span>,n-t):<span class=\"comment\">#向右读</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(s[m-<span class=\"number\">1</span>-t][i],sep=<span class=\"string\">&#x27; &#x27;</span>,end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m-<span class=\"number\">2</span>-t,t-<span class=\"number\">1</span>,-<span class=\"number\">1</span>):<span class=\"comment\">#向上读</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(s[i][n-<span class=\"number\">1</span>-t],sep=<span class=\"string\">&#x27; &#x27;</span>,end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n-<span class=\"number\">2</span>-t,t,-<span class=\"number\">1</span>):<span class=\"comment\">#向左读</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(s[t][i],sep=<span class=\"string\">&#x27; &#x27;</span>,end=<span class=\"string\">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>\n      \n        <h2 id=\"C-版\"   >\n          <a href=\"#C-版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-版\" class=\"headerlink\" title=\"C++版\"></a>C++版</h2>\n      <ol>\n<li>整体思路就是写通用，从a[-1][0]进入，循环检测前一个是否越界或者为-1。</li>\n<li>sum计数大循环，循环内部四个方向。</li>\n<li>方向循环的时候一定要把自加放到前面！因为&amp;&amp;后面的判断需要自加后的结果，如果顺序错了就会导致越界输出一次，最后的输出结果就对不上了！</li>\n</ol>\n\n        <h2 id=\"Python版\"   >\n          <a href=\"#Python版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python版\" class=\"headerlink\" title=\"Python版\"></a>Python版</h2>\n      <ol>\n<li>python版本的和C++的结构不太一样，C++用的二维数组，但是Python用的是嵌套数组，因此在方向上进行调整的方法同，但也是大同小异</li>\n</ol>\n","categories":["编程语言","蓝桥"],"tags":["编程语言","蓝桥"]},{"title":"【蓝桥】链表练习题：自行车停放","url":"/Program-lanqiao-%E3%80%90%E8%93%9D%E6%A1%A5%E3%80%91%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%9A%E8%87%AA%E8%A1%8C%E8%BD%A6%E5%81%9C%E6%94%BE/","content":"\n        <h1 id=\"题目\"   >\n          <a href=\"#题目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1>\n      \n        <h2 id=\"题目描述\"   >\n          <a href=\"#题目描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2>\n      <p>有 n 辆自行车依次来到停车棚，除了第一辆自行车外，每辆自行车都会恰好停放在已经在停车棚里的某辆自行车的左边或右边。(e.g.停车棚里已经有 3 辆自行车，从左到右编号为：3,5,1。现在编号为 2 的第 4 辆自行车要停在 5 号自行车的左边，所以现在停车棚里的自行车编号是：3,2,5,1)。给定nn辆自行车的停放情况，按顺序输出最后停车棚里的自行车编号。n≤100000。</p>\n\n        <h2 id=\"输入描述\"   >\n          <a href=\"#输入描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述\"></a>输入描述</h2>\n      <p>第一行一个整数 n。 第二行一个整数x。表示第一辆自行车的编号。 以下 n-1 行，每行 3 个整数 x,y,z。 z=0 时，表示编号为 x 的自行车恰停放在编号为 y 的自行车的左边。 z=1 时，表示编号为 x 的自行车恰停放在编号为 y 的自行车的右边。</p>\n\n        <h2 id=\"输出描述\"   >\n          <a href=\"#输出描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述\"></a>输出描述</h2>\n      <p>从左到右输出停车棚里的自行车编号</p>\n\n        <h2 id=\"输入输出样例\"   >\n          <a href=\"#输入输出样例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2>\n      \n        <h3 id=\"示例\"   >\n          <a href=\"#示例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3>\n      <blockquote>\n<p>输入</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">1 3 1</span><br><span class=\"line\">2 1 0</span><br><span class=\"line\">5 2 1</span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>输出</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 2 5 1</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"运行限制\"   >\n          <a href=\"#运行限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运行限制\" class=\"headerlink\" title=\"运行限制\"></a>运行限制</h2>\n      <ul>\n<li>最大运行时间：1s</li>\n<li>最大运行内存: 128M</li>\n</ul>\n\n        <h1 id=\"解题\"   >\n          <a href=\"#解题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h1>\n      \n        <h2 id=\"源码\"   >\n          <a href=\"#源码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2>\n      \n        <h3 id=\"C\"   >\n          <a href=\"#C\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3>\n      <figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num, first, x, y, z;</span><br><span class=\"line\">list&lt;<span class=\"keyword\">int</span>&gt;::iterator loc[<span class=\"number\">100003</span>]; <span class=\"comment\">//使用编号作为数组地需要，在相应的数组中存入结点的位置！高啊！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tlist&lt;<span class=\"keyword\">int</span>&gt; L;  <span class=\"comment\">//链表</span></span><br><span class=\"line\">\tcin &gt;&gt; num &gt;&gt; first;</span><br><span class=\"line\">\tL.<span class=\"built_in\">push_back</span>(first); <span class=\"comment\">//把第一辆车放到链表里</span></span><br><span class=\"line\">\tloc[first] = L.<span class=\"built_in\">begin</span>();\t  <span class=\"comment\">//把第一辆车的位置，存到以车编号为序号的数字里</span></span><br><span class=\"line\">\tlist&lt;<span class=\"keyword\">int</span>&gt;::iterator temp; <span class=\"comment\">//遍历用的迭代器</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class=\"line\">\t\ttemp = loc[y]; <span class=\"comment\">//将这个y需要的车的位置拿出来给了temp</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (z &gt; <span class=\"number\">0</span>)  <span class=\"comment\">//放右边的时候</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tL.<span class=\"built_in\">insert</span>(++temp, x);  <span class=\"comment\">//放到temp后一个位置的前一个，也就是temp后面</span></span><br><span class=\"line\">\t\t\tloc[x] = --temp;  <span class=\"comment\">//把刚放入的车子位置以车编号为数组下标存入数组</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tL.<span class=\"built_in\">insert</span>(temp, x);  <span class=\"comment\">//同理</span></span><br><span class=\"line\">\t\t\tloc[x] = --temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (temp = L.<span class=\"built_in\">begin</span>(); temp != L.<span class=\"built_in\">end</span>(); temp++) <span class=\"comment\">//遍历序列输出</span></span><br><span class=\"line\">\t\tcout &lt;&lt; *temp &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"Python\"   >\n          <a href=\"#Python\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3>\n      <figure class=\"highlight python\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">n=<span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\">res=[<span class=\"built_in\">input</span>()]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n-<span class=\"number\">1</span>):</span><br><span class=\"line\">  x,y,z=<span class=\"built_in\">input</span>().split()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> z==<span class=\"string\">&#x27;0&#x27;</span>:</span><br><span class=\"line\">    res.insert(res.index(y),x)</span><br><span class=\"line\">  <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    res.insert(res.index(y)+<span class=\"number\">1</span>,x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27; &#x27;</span>.join(res))</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1>\n      \n        <h2 id=\"C-版\"   >\n          <a href=\"#C-版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#C-版\" class=\"headerlink\" title=\"C++版\"></a>C++版</h2>\n      <ol>\n<li>有一个小技巧是利用数组记录每一辆车子的位置，这样可以直接定位到车子的位置，极大地减少了需要的时间。</li>\n<li>用了STL容器，太舒服了，比直接写方便多。</li>\n</ol>\n<figure class=\"highlight c++\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//list容器的使用</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//end()指向末尾的下一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义链表</span></span><br><span class=\"line\">    list&lt;<span class=\"keyword\">int</span>&gt;node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化链表，包含n个结点的链表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        node.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历链表，用it遍历链表</span></span><br><span class=\"line\">    list&lt;<span class=\"keyword\">int</span>&gt;::iterator it = node.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(node.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        it++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//结束时回到首位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(it == node.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">            it = node <span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    list&lt;<span class=\"keyword\">int</span>&gt;::iterator next = ++it;</span><br><span class=\"line\">    <span class=\"comment\">//结束时回到头部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(next == node.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">        next = node.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    node.<span class=\"built_in\">erase</span>(--it);</span><br><span class=\"line\">    <span class=\"comment\">//删除这个结点</span></span><br><span class=\"line\">    it = next;</span><br><span class=\"line\">    <span class=\"comment\">//加载到下一个结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"Python版\"   >\n          <a href=\"#Python版\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Python版\" class=\"headerlink\" title=\"Python版\"></a>Python版</h2>\n      <ol>\n<li>RNM这个简单太多了，因为python可以自动转换数据结构，所以只用注意流程就行了==、</li>\n</ol>\n","categories":["编程语言","蓝桥"],"tags":["编程语言","蓝桥"]}]